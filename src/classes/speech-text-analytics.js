/**
 * @module gc-platform-api-speech-text-analytics
 * @license MIT
 */

// This file was automatically generated by the Generate Genesys Cloud Platform API classes utility on 2025-04-24T15:04:25.308Z

// TODO: Implement JSON schema verification for input and output objects
// TODO: Implement HTTP response typedefs

// Set strict mode
"use strict";

// Errors
import { errors } from "../gc-platform-api-client-errors.js";

// Symbols
import { symbols } from "../gc-platform-api-client-symbols.js";

/** @typedef {import("../gc-platform-api-client-class.js").GCPlatformAPIClient} GCPlatformAPIClient */
/** @typedef {import("@jfabello/http-client").HTTPResponse} HTTPResponse */

/**
 * @typedef {object} AddressableEntityRef
 * @property {string} [id]
 * @property {string} [selfUri]
 */
 
/**
 * @typedef {object} CategoryRequest
 * @property {string} name - The name of the category
 * @property {string} [description] - The description of the category
 * @property {string} interactionType - The type of interaction the category will apply to
 * @property {Operand} criteria - A collection of conditions joined together by logical operation to provide more refined filtering of conversations
 */
 
/**
 * @typedef {object} DictionaryFeedback
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} term - The dictionary term which needs to be added to dictionary feedback system
 * @property {string} dialect - The dialect for the given term, dialect format is {language}-{country} where language follows ISO 639-1 standard and country follows ISO 3166-1 alpha 2 standard
 * @property {number} [boostValue] - A weighted value assigned to a phrase. The higher the value, the higher the likelihood that the system will choose the word or phrase from the possible alternatives. Boost range is from 1.0 to 10.0. Default is 2.0
 * @property {string} [source] - The source of the given dictionary feedback
 * @property {string} [dateCreated] - The Timestamp when dictionary feedback created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {UserReference} [createdBy] - The Id of the user who created the dictionary feedback
 * @property {string} [dateModified] - The Timestamp when dictionary feedback modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {UserReference} [modifiedBy] - The Id of the user who modified the dictionary feedback
 * @property {DictionaryFeedbackExamplePhrase[]} examplePhrases - A list of at least 3 and up to 20 unique phrases that are example usage of the term
 * @property {string[]} [soundsLike] - A list of up to 10 terms that give examples of how the term sounds
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} DictionaryFeedbackExamplePhrase
 * @property {string} phrase - The Example Phrase text. At least 3 words and up to 20 words
 * @property {string} [source] - The source of the given Example Phrase
 */
 
/**
 * @typedef {object} EngineIntegration
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} GeneralProgramJobRequest
 * @property {string} dialect - The dialect of the topics to link with the general program, dialect format is {language}-{country} where language follows ISO 639-1 standard and country follows ISO 3166-1 alpha 2 standard
 * @property {string} [mode] - The mode to use for the general program job, default value is Skip
 */
 
/**
 * @typedef {object} InfixOperator
 * @property {string} operatorType - The logical operation that is applied on the operand against the following operand
 * @property {OperatorPosition} [operatorPosition] - Dictates when the following operand should occur relative to current operand
 */
 
/**
 * @typedef {object} InsightsSettingsRequest
 * @property {boolean} enabled - The AI Insights setting
 */
 
/**
 * @typedef {object} Operand
 * @property {string} type - The Operand type of the category
 * @property {number} [occurrence] - The minimum number of occurrences of the defined operand type
 * @property {boolean} [inverted] - Applies a NOT modifier to the operand group
 * @property {Term} [term] - Filter interaction by word(s)
 * @property {string} [topicId] - Filter interaction by topic ID
 * @property {OperandPosition} [voiceSecondsPosition] - Dictates when the operand must occur in a voice interaction
 * @property {OperandPosition} [digitalWordsPosition] - Dictates when the operand must occur in a digital interaction
 * @property {InfixOperator} [infixOperator] - Defines a logical operation that is applied on the current operand, against the following operand
 * @property {Operand[]} [operands] - Contains a new level of operands
 */
 
/**
 * @typedef {object} OperandPosition
 * @property {number} [startingPositionValue] - Defines starting point of a position range - number of seconds or words from the start or from the end of the interaction
 * @property {string} [startingPositionDirection] - Dictates starting position directionality
 * @property {number} [endingPositionValue] - Defines ending point of a position range - number of seconds or words from the start or from the end of the interaction
 * @property {string} [endingPositionDirection] - Dictates ending position directionality
 */
 
/**
 * @typedef {object} OperatorPosition
 * @property {number} [voiceSecondsPosition] - Number of seconds (for voice interactions) from operand match
 * @property {number} [digitalWordsPosition] - Number of words (for digital interactions) from operand match
 */
 
/**
 * @typedef {object} Phrase
 * @property {string} text - The phrase text
 * @property {string} [strictness] - The phrase strictness, default value is null
 * @property {string} [sentiment] - The phrase sentiment, default value is Unspecified. Note: Sentiment value for phrases is currently not in use and has no impact to the system.
 */
 
/**
 * @typedef {object} ProgramJobRequest
 * @property {string[]} programIds - The ids of the programs used for this job
 */
 
/**
 * @typedef {object} ProgramMappingsRequest
 * @property {string[]} queueIds - The program queues
 * @property {string[]} flowIds - The program flows
 */
 
/**
 * @typedef {object} ProgramRequest
 * @property {string} name - The program name
 * @property {string} [description] - The program description
 * @property {string[]} [topicIds] - The ids of topics associated to the program
 * @property {string[]} [tags] - The program tags
 */
 
/**
 * @typedef {object} ProgramTranscriptionEngine
 * @property {string} [engine]
 * @property {string[]} [dialects]
 * @property {EngineIntegration} [engineIntegration]
 */
 
/**
 * @typedef {object} SearchSort
 * @property {string} [sortOrder] - The sort order for results
 * @property {string} [sortBy] - The field in the resource that you want to sort the results by
 */
 
/**
 * @typedef {object} SentimentFeedback
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} phrase - The phrase for which sentiment feedback is provided
 * @property {string} dialect - The dialect for the given phrase, dialect format is {language}-{country} where language follows ISO 639-1 standard and country follows ISO 3166-1 alpha 2 standard
 * @property {string} feedbackValue - The sentiment feedback value for the given phrase
 * @property {string} [dateCreated] - The Timestamp when sentiment feedback created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {AddressableEntityRef} [createdBy] - The Id of user who created the sentiment feedback
 */
 
/**
 * @typedef {object} SpeechTextAnalyticsSettingsRequest
 * @property {string} [defaultProgramId] - Setting to choose name for the default program for topic detection
 * @property {string[]} [expectedDialects] - Setting to choose expected dialects
 * @property {boolean} [textAnalyticsEnabled] - Setting to enable/disable text analytics
 * @property {boolean} [agentEmpathyEnabled] - Setting to enable/disable Agent Empathy setting
 */
 
/**
 * @typedef {object} Term
 * @property {string} word - Find term in interaction
 * @property {string} participantType - Dictates if term operand must come from the internal, external or both participants
 */
 
/**
 * @typedef {object} TopicJobRequest
 * @property {string[]} topicIds - The ids of the topics used for this job
 */
 
/**
 * @typedef {object} TopicRequest
 * @property {string} name - The topic name
 * @property {string} [description] - The topic description
 * @property {string} [strictness] - The topic strictness, default value is 72
 * @property {string[]} [programIds] - The ids of programs associated to the topic
 * @property {string[]} [tags] - The topic tags
 * @property {string} dialect - The topic dialect
 * @property {string} [participants] - The topic participants, default value is All
 * @property {Phrase[]} [phrases] - The topic phrases
 */
 
/**
 * @typedef {object} TranscriptionEnginesRequest
 * @property {ProgramTranscriptionEngine[]} transcriptionEngines - The transcription engine setting
 */
 
/**
 * @typedef {object} TranscriptSearchCriteria
 * @property {string} [endValue] - The end value of the range. This field is used for range search types.
 * @property {string[]} [values] - A list of values for the search to match against
 * @property {string} [startValue] - The start value of the range. This field is used for range search types.
 * @property {string} [value] - A value for the search to match against
 * @property {string} [operator] - How to apply this search criteria against other criteria
 * @property {TranscriptSearchCriteria[]} [group] - Groups multiple conditions
 * @property {string} [dateFormat] - Set date format for criteria values when using date range search type.  Supports Java date format syntax, example yyyy-MM-dd'T'HH:mm:ss.SSSX.
 * @property {string} [type]
 * @property {string[]} [fields] - Field names to search against
 */
 
/**
 * @typedef {object} TranscriptSearchRequest
 * @property {string} [sortOrder] - The sort order for results
 * @property {string} [sortBy] - The field in the resource that you want to sort the results by
 * @property {number} [pageSize] - The number of results per page
 * @property {number} [pageNumber] - The page of resources you want to retrieve
 * @property {SearchSort[]} [sort] - Multi-value sort order, list of multiple sort values
 * @property {string[]} [returnFields]
 * @property {string[]} types - Resource domain type to search
 * @property {TranscriptSearchCriteria[]} [query] - The search criteria
 */
 
/**
 * @typedef {object} UserReference
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [selfUri] - The URI for this object
 */
 

/**
 * SpeechTextAnalytics
 * @class SpeechTextAnalytics
 */
class SpeechTextAnalyticsAPI {
	// Private instance properties
	#gcPlatformAPIClient = null;

	/**
	 * Constructor for the SpeechTextAnalytics class
	 * @constructor
	 * @param {GCPlatformAPIClient} gcPlatformAPIClient - The Genesys Cloud Platform API client instance.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_INSTANCE_TYPE_INVALID} If the Genesys Cloud Platform API client instance argument is not an object.
	 */
	constructor(gcPlatformAPIClient) {
		// Check the Genesys Cloud Platform API client instance argument
		if (typeof gcPlatformAPIClient !== "object" || symbols.GCPlatformAPIClient in gcPlatformAPIClient === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_INSTANCE_TYPE_INVALID();
		}

		// Initialize the instance properties
		this.#gcPlatformAPIClient = gcPlatformAPIClient;
	}

	/**
	 * Get the list of Speech and Text Analytics categories
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  The page size for the listing. The max that will be returned is 25.
	 * @param {number} [query.pageNumber] -  The page number for the listing
	 * @param {string} [query.name] -  The category name filter applied to the listing
	 * @param {string} [query.sortOrder] -  The sort order for the listing
	 * @param {string} [query.sortBy] -  The field to sort by for the listing
	 * @param {string[]} [query.ids] -  Comma separated Category IDs to filter by. Cannot be used with other filters. Maximum of 25 IDs allowed.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/categories" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getSpeechandtextanalyticsCategories(query) {
		const endpointPath = "/api/v2/speechandtextanalytics/categories";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
			if ("sortOrder" in query && this.#checkJSONSchemaType(query["sortOrder"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortOrder", "string");
			}
			if ("sortBy" in query && this.#checkJSONSchemaType(query["sortBy"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortBy", "string");
			}
			if ("ids" in query && this.#checkJSONSchemaType(query["ids"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "ids", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create new Speech & Text Analytics category
	 * @async
	 * @param {CategoryRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/categories" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postSpeechandtextanalyticsCategories(body) {
		const endpointPath = "/api/v2/speechandtextanalytics/categories";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a Speech & Text Analytics Category by ID
	 * @async
	 * @param {string} categoryId - The id of the category
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/categories/{categoryId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getSpeechandtextanalyticsCategory(categoryId) {
		const endpointPath = "/api/v2/speechandtextanalytics/categories/{categoryId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(categoryId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "categoryId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.categoryId = categoryId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a Speech & Text Analytics category by ID
	 * @async
	 * @param {string} categoryId - The id of the category
	 * @param {CategoryRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/categories/{categoryId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putSpeechandtextanalyticsCategory(categoryId, body) {
		const endpointPath = "/api/v2/speechandtextanalytics/categories/{categoryId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(categoryId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "categoryId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.categoryId = categoryId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a Speech & Text Analytics category by ID
	 * @async
	 * @param {string} categoryId - The id of the category
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/categories/{categoryId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteSpeechandtextanalyticsCategory(categoryId) {
		const endpointPath = "/api/v2/speechandtextanalytics/categories/{categoryId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(categoryId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "categoryId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.categoryId = categoryId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get Speech and Text Analytics for a specific conversation
	 * @async
	 * @param {string} conversationId - Conversation Id
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/conversations/{conversationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getSpeechandtextanalyticsConversation(conversationId) {
		const endpointPath = "/api/v2/speechandtextanalytics/conversations/{conversationId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get conversation summaries by conversation id.
	 * @async
	 * @param {string} conversationId - The conversation ID of the summaries
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/conversations/{conversationId}/summaries" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getSpeechandtextanalyticsConversationSummaries(conversationId) {
		const endpointPath = "/api/v2/speechandtextanalytics/conversations/{conversationId}/summaries";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a Speech & Text Analytics dictionary feedback by id
	 * @async
	 * @param {string} dictionaryFeedbackId - The Id of the Dictionary Feedback
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/dictionaryfeedback/{dictionaryFeedbackId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getSpeechandtextanalyticsDictionaryfeedbackDictionaryFeedbackId(dictionaryFeedbackId) {
		const endpointPath = "/api/v2/speechandtextanalytics/dictionaryfeedback/{dictionaryFeedbackId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(dictionaryFeedbackId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "dictionaryFeedbackId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.dictionaryFeedbackId = dictionaryFeedbackId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update existing Speech & Text Analytics dictionary feedback by id
	 * @async
	 * @param {string} dictionaryFeedbackId - The Id of the Dictionary Feedback
	 * @param {DictionaryFeedback} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/dictionaryfeedback/{dictionaryFeedbackId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putSpeechandtextanalyticsDictionaryfeedbackDictionaryFeedbackId(dictionaryFeedbackId, body) {
		const endpointPath = "/api/v2/speechandtextanalytics/dictionaryfeedback/{dictionaryFeedbackId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(dictionaryFeedbackId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "dictionaryFeedbackId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.dictionaryFeedbackId = dictionaryFeedbackId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a Speech & Text Analytics DictionaryFeedback by Id
	 * @async
	 * @param {string} dictionaryFeedbackId - The Id of the Dictionary Feedback
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/dictionaryfeedback/{dictionaryFeedbackId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteSpeechandtextanalyticsDictionaryfeedbackDictionaryFeedbackId(dictionaryFeedbackId) {
		const endpointPath = "/api/v2/speechandtextanalytics/dictionaryfeedback/{dictionaryFeedbackId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(dictionaryFeedbackId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "dictionaryFeedbackId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.dictionaryFeedbackId = dictionaryFeedbackId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the list of Speech & Text Analytics dictionary feedbacks
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.dialect] -  The key for filter the listing by dialect, dialect format is {language}-{country} where language follows ISO 639-1 standard and country follows ISO 3166-1 alpha 2 standard
	 * @param {string} [query.nextPage] -  The key for listing the next page
	 * @param {number} [query.pageSize] -  The page size for the listing
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/dictionaryfeedback" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getSpeechandtextanalyticsDictionaryfeedback(query) {
		const endpointPath = "/api/v2/speechandtextanalytics/dictionaryfeedback";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("dialect" in query && this.#checkJSONSchemaType(query["dialect"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "dialect", "string");
			}
			if ("nextPage" in query && this.#checkJSONSchemaType(query["nextPage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "nextPage", "string");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a Speech & Text Analytics DictionaryFeedback
	 * @async
	 * @param {DictionaryFeedback} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/dictionaryfeedback" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postSpeechandtextanalyticsDictionaryfeedback(body) {
		const endpointPath = "/api/v2/speechandtextanalytics/dictionaryfeedback";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a Speech & Text Analytics SentimentFeedback by Id
	 * @async
	 * @param {string} sentimentFeedbackId - The Id of the SentimentFeedback
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/sentimentfeedback/{sentimentFeedbackId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteSpeechandtextanalyticsSentimentfeedbackSentimentFeedbackId(sentimentFeedbackId) {
		const endpointPath = "/api/v2/speechandtextanalytics/sentimentfeedback/{sentimentFeedbackId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(sentimentFeedbackId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sentimentFeedbackId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.sentimentFeedbackId = sentimentFeedbackId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the list of Speech & Text Analytics SentimentFeedback
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.dialect] -  The key for filter the listing by dialect, dialect format is {language}-{country} where language follows ISO 639-1 standard and country follows ISO 3166-1 alpha 2 standard
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/sentimentfeedback" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getSpeechandtextanalyticsSentimentfeedback(query) {
		const endpointPath = "/api/v2/speechandtextanalytics/sentimentfeedback";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("dialect" in query && this.#checkJSONSchemaType(query["dialect"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "dialect", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a Speech & Text Analytics SentimentFeedback
	 * @async
	 * @param {SentimentFeedback} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/sentimentfeedback" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postSpeechandtextanalyticsSentimentfeedback(body) {
		const endpointPath = "/api/v2/speechandtextanalytics/sentimentfeedback";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete All Speech & Text Analytics SentimentFeedback
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/sentimentfeedback" endpoint.
	 */
	deleteSpeechandtextanalyticsSentimentfeedback() {
		const endpointPath = "/api/v2/speechandtextanalytics/sentimentfeedback";
		const endpointMethod = "DELETE";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get AI Insights settings of a program
	 * @async
	 * @param {string} programId - The id of the program
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/programs/{programId}/settings/insights" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getSpeechandtextanalyticsProgramSettingsInsights(programId) {
		const endpointPath = "/api/v2/speechandtextanalytics/programs/{programId}/settings/insights";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(programId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "programId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.programId = programId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update AI Insights settings of a program
	 * @async
	 * @param {string} programId - The id of the program
	 * @param {InsightsSettingsRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/programs/{programId}/settings/insights" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putSpeechandtextanalyticsProgramSettingsInsights(programId, body) {
		const endpointPath = "/api/v2/speechandtextanalytics/programs/{programId}/settings/insights";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(programId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "programId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.programId = programId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get transcription engine settings of a program
	 * @async
	 * @param {string} programId - The id of the program
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/programs/{programId}/transcriptionengines" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getSpeechandtextanalyticsProgramTranscriptionengines(programId) {
		const endpointPath = "/api/v2/speechandtextanalytics/programs/{programId}/transcriptionengines";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(programId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "programId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.programId = programId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update transcription engine settings of a program
	 * @async
	 * @param {string} programId - The id of the program
	 * @param {TranscriptionEnginesRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/programs/{programId}/transcriptionengines" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putSpeechandtextanalyticsProgramTranscriptionengines(programId, body) {
		const endpointPath = "/api/v2/speechandtextanalytics/programs/{programId}/transcriptionengines";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(programId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "programId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.programId = programId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the list of program AI Insights settings for the organization
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  The page size for the listing. The max that will be returned is 100.
	 * @param {number} [query.pageNumber] -  The page number for the listing
	 * @param {string[]} [query.programIds] -  Comma separated Program IDs to filter by. Maximum of 50 IDs allowed.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/programs/settings/insights" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getSpeechandtextanalyticsProgramsSettingsInsights(query) {
		const endpointPath = "/api/v2/speechandtextanalytics/programs/settings/insights";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("programIds" in query && this.#checkJSONSchemaType(query["programIds"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "programIds", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get supported dialects for each transcription engine
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/programs/transcriptionengines/dialects" endpoint.
	 */
	getSpeechandtextanalyticsProgramsTranscriptionenginesDialects() {
		const endpointPath = "/api/v2/speechandtextanalytics/programs/transcriptionengines/dialects";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the list of Speech & Text Analytics sentiment supported dialects
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/sentiment/dialects" endpoint.
	 */
	getSpeechandtextanalyticsSentimentDialects() {
		const endpointPath = "/api/v2/speechandtextanalytics/sentiment/dialects";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get Speech And Text Analytics Settings
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/settings" endpoint.
	 */
	getSpeechandtextanalyticsSettings() {
		const endpointPath = "/api/v2/speechandtextanalytics/settings";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update Speech And Text Analytics Settings
	 * @async
	 * @param {SpeechTextAnalyticsSettingsRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/settings" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putSpeechandtextanalyticsSettings(body) {
		const endpointPath = "/api/v2/speechandtextanalytics/settings";
		const endpointMethod = "PUT";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Patch Speech And Text Analytics Settings
	 * @async
	 * @param {SpeechTextAnalyticsSettingsRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/settings" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchSpeechandtextanalyticsSettings(body) {
		const endpointPath = "/api/v2/speechandtextanalytics/settings";
		const endpointMethod = "PATCH";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the list of detected Speech and Text Analytics categories of conversation
	 * @async
	 * @param {string} conversationId - The id of the conversation
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  The page size for the listing. The max that will be returned is 50.
	 * @param {number} [query.pageNumber] -  The page number for the listing
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/conversations/{conversationId}/categories" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getSpeechandtextanalyticsConversationCategories(conversationId, query) {
		const endpointPath = "/api/v2/speechandtextanalytics/conversations/{conversationId}/categories";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a Speech & Text Analytics general program job by id
	 * @async
	 * @param {string} jobId - The id of the publish programs job
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/programs/general/jobs/{jobId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getSpeechandtextanalyticsProgramsGeneralJob(jobId) {
		const endpointPath = "/api/v2/speechandtextanalytics/programs/general/jobs/{jobId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(jobId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "jobId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.jobId = jobId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create new Speech & Text Analytics general program job
	 * @async
	 * @param {GeneralProgramJobRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/programs/general/jobs" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postSpeechandtextanalyticsProgramsGeneralJobs(body) {
		const endpointPath = "/api/v2/speechandtextanalytics/programs/general/jobs";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the Speech & Text Analytics general topics for a given dialect
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.dialect] -  The dialect of the general topics, dialect format is {language}-{country} where language follows ISO 639-1 standard and country follows ISO 3166-1 alpha 2 standard
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/topics/general" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getSpeechandtextanalyticsTopicsGeneral(query) {
		const endpointPath = "/api/v2/speechandtextanalytics/topics/general";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("dialect" in query && this.#checkJSONSchemaType(query["dialect"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "dialect", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get Speech & Text Analytics program mappings to queues and flows by id
	 * @async
	 * @param {string} programId - The id of the program
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/programs/{programId}/mappings" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getSpeechandtextanalyticsProgramMappings(programId) {
		const endpointPath = "/api/v2/speechandtextanalytics/programs/{programId}/mappings";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(programId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "programId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.programId = programId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Set Speech & Text Analytics program mappings to queues and flows
	 * @async
	 * @param {string} programId - The id of the program
	 * @param {ProgramMappingsRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/programs/{programId}/mappings" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putSpeechandtextanalyticsProgramMappings(programId, body) {
		const endpointPath = "/api/v2/speechandtextanalytics/programs/{programId}/mappings";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(programId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "programId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.programId = programId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a Speech & Text Analytics publish programs job by id
	 * @async
	 * @param {string} jobId - The id of the publish programs job
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/programs/publishjobs/{jobId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getSpeechandtextanalyticsProgramsPublishjob(jobId) {
		const endpointPath = "/api/v2/speechandtextanalytics/programs/publishjobs/{jobId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(jobId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "jobId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.jobId = jobId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create new Speech & Text Analytics publish programs job
	 * @async
	 * @param {ProgramJobRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/programs/publishjobs" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postSpeechandtextanalyticsProgramsPublishjobs(body) {
		const endpointPath = "/api/v2/speechandtextanalytics/programs/publishjobs";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a Speech & Text Analytics program by id
	 * @async
	 * @param {string} programId - The id of the program
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/programs/{programId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getSpeechandtextanalyticsProgram(programId) {
		const endpointPath = "/api/v2/speechandtextanalytics/programs/{programId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(programId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "programId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.programId = programId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update existing Speech & Text Analytics program
	 * @async
	 * @param {string} programId - The id of the program
	 * @param {ProgramRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/programs/{programId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putSpeechandtextanalyticsProgram(programId, body) {
		const endpointPath = "/api/v2/speechandtextanalytics/programs/{programId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(programId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "programId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.programId = programId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a Speech & Text Analytics program by id
	 * @async
	 * @param {string} programId - The id of the program
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.forceDelete] -  Indicates whether the program is forced to be deleted or not. Required when the program to delete is the default program.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/programs/{programId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	deleteSpeechandtextanalyticsProgram(programId, query) {
		const endpointPath = "/api/v2/speechandtextanalytics/programs/{programId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(programId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "programId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("forceDelete" in query && this.#checkJSONSchemaType(query["forceDelete"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "forceDelete", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.programId = programId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the list of Speech & Text Analytics programs mappings to queues and flows
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.nextPage] -  The key for listing the next page
	 * @param {number} [query.pageSize] -  The page size for the listing
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/programs/mappings" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getSpeechandtextanalyticsProgramsMappings(query) {
		const endpointPath = "/api/v2/speechandtextanalytics/programs/mappings";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("nextPage" in query && this.#checkJSONSchemaType(query["nextPage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "nextPage", "string");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the list of Speech & Text Analytics programs
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.nextPage] -  The key for listing the next page
	 * @param {number} [query.pageSize] -  The page size for the listing
	 * @param {string} [query.state] -  Program state. Defaults to Latest
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/programs" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getSpeechandtextanalyticsPrograms(query) {
		const endpointPath = "/api/v2/speechandtextanalytics/programs";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("nextPage" in query && this.#checkJSONSchemaType(query["nextPage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "nextPage", "string");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("state" in query && this.#checkJSONSchemaType(query["state"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "state", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create new Speech & Text Analytics program
	 * @async
	 * @param {ProgramRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/programs" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postSpeechandtextanalyticsPrograms(body) {
		const endpointPath = "/api/v2/speechandtextanalytics/programs";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a Speech & Text Analytics publish topics job by id
	 * @async
	 * @param {string} jobId - The id of the publish topics job
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/topics/publishjobs/{jobId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getSpeechandtextanalyticsTopicsPublishjob(jobId) {
		const endpointPath = "/api/v2/speechandtextanalytics/topics/publishjobs/{jobId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(jobId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "jobId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.jobId = jobId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create new Speech & Text Analytics publish topics job
	 * @async
	 * @param {TopicJobRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/topics/publishjobs" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postSpeechandtextanalyticsTopicsPublishjobs(body) {
		const endpointPath = "/api/v2/speechandtextanalytics/topics/publishjobs";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a Speech & Text Analytics topic by id
	 * @async
	 * @param {string} topicId - The id of the topic
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/topics/{topicId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getSpeechandtextanalyticsTopic(topicId) {
		const endpointPath = "/api/v2/speechandtextanalytics/topics/{topicId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(topicId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "topicId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.topicId = topicId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update existing Speech & Text Analytics topic
	 * @async
	 * @param {string} topicId - The id of the topic
	 * @param {TopicRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/topics/{topicId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putSpeechandtextanalyticsTopic(topicId, body) {
		const endpointPath = "/api/v2/speechandtextanalytics/topics/{topicId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(topicId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "topicId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.topicId = topicId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a Speech & Text Analytics topic by id
	 * @async
	 * @param {string} topicId - The id of the topic
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/topics/{topicId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteSpeechandtextanalyticsTopic(topicId) {
		const endpointPath = "/api/v2/speechandtextanalytics/topics/{topicId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(topicId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "topicId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.topicId = topicId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get list of supported Speech & Text Analytics topics dialects
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/topics/dialects" endpoint.
	 */
	getSpeechandtextanalyticsTopicsDialects() {
		const endpointPath = "/api/v2/speechandtextanalytics/topics/dialects";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the list of Speech & Text Analytics topics
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.nextPage] -  The key for listing the next page
	 * @param {number} [query.pageSize] -  The page size for the listing. The max that will be returned is 500.
	 * @param {string} [query.state] -  Topic state. Defaults to latest
	 * @param {string} [query.name] -  Case insensitive partial name to filter by
	 * @param {string[]} [query.ids] -  Comma separated Topic IDs to filter by. Cannot be used with other filters. Maximum of 50 IDs allowed.
	 * @param {string[]} [query.dialects] -  Comma separated dialect strings to filter by. Maximum of 15 dialects allowed.
	 * @param {string} [query.sortBy] -  Sort results by. Defaults to name
	 * @param {string} [query.sortOrder] -  Sort order. Defaults to asc
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/topics" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getSpeechandtextanalyticsTopics(query) {
		const endpointPath = "/api/v2/speechandtextanalytics/topics";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("nextPage" in query && this.#checkJSONSchemaType(query["nextPage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "nextPage", "string");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("state" in query && this.#checkJSONSchemaType(query["state"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "state", "string");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
			if ("ids" in query && this.#checkJSONSchemaType(query["ids"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "ids", "array");
			}
			if ("dialects" in query && this.#checkJSONSchemaType(query["dialects"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "dialects", "array");
			}
			if ("sortBy" in query && this.#checkJSONSchemaType(query["sortBy"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortBy", "string");
			}
			if ("sortOrder" in query && this.#checkJSONSchemaType(query["sortOrder"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortOrder", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create new Speech & Text Analytics topic
	 * @async
	 * @param {TopicRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/topics" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postSpeechandtextanalyticsTopics(body) {
		const endpointPath = "/api/v2/speechandtextanalytics/topics";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the list of general topics from the org and the system with their current status
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.dialect] -  The dialect of the general topics, dialect format is {language}-{country} where language follows ISO 639-1 standard and country follows ISO 3166-1 alpha 2 standard
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/topics/general/status" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getSpeechandtextanalyticsTopicsGeneralStatus(query) {
		const endpointPath = "/api/v2/speechandtextanalytics/topics/general/status";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("dialect" in query && this.#checkJSONSchemaType(query["dialect"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "dialect", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the list of Speech & Text Analytics unpublished programs
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.nextPage] -  The key for listing the next page
	 * @param {number} [query.pageSize] -  The page size for the listing
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/programs/unpublished" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getSpeechandtextanalyticsProgramsUnpublished(query) {
		const endpointPath = "/api/v2/speechandtextanalytics/programs/unpublished";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("nextPage" in query && this.#checkJSONSchemaType(query["nextPage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "nextPage", "string");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Search resources.
	 * @async
	 * @param {TranscriptSearchRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/transcripts/search" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postSpeechandtextanalyticsTranscriptsSearch(body) {
		const endpointPath = "/api/v2/speechandtextanalytics/transcripts/search";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the pre-signed S3 URL for the transcript of a specific communication of a conversation
	 * @async
	 * @param {string} conversationId - Conversation ID
	 * @param {string} communicationId - Communication ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/conversations/{conversationId}/communications/{communicationId}/transcripturl" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getSpeechandtextanalyticsConversationCommunicationTranscripturl(conversationId, communicationId) {
		const endpointPath = "/api/v2/speechandtextanalytics/conversations/{conversationId}/communications/{communicationId}/transcripturl";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.communicationId = communicationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the list of pre-signed S3 URL for the transcripts of a specific communication of a conversation
	 * @async
	 * @param {string} conversationId - Conversation ID
	 * @param {string} communicationId - Communication ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/speechandtextanalytics/conversations/{conversationId}/communications/{communicationId}/transcripturls" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getSpeechandtextanalyticsConversationCommunicationTranscripturls(conversationId, communicationId) {
		const endpointPath = "/api/v2/speechandtextanalytics/conversations/{conversationId}/communications/{communicationId}/transcripturls";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.communicationId = communicationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * @description Checks that a value is of the proper JSON schema type
	 * @param {*} value - The value to check
	 * @param {string} jsonSchemaType - The JSON schema type to check against
	 * @returns {boolean} Returns true if the value is of the proper JSON schema type, false otherwise
	 */
	#checkJSONSchemaType(value, jsonSchemaType) {
		const PASSTHROUGH_JSON_SCHEMA_TYPES = ["boolean", "number", "string", "object"];

		// Check if the type is a passthrough type
		if (PASSTHROUGH_JSON_SCHEMA_TYPES.includes(jsonSchemaType)) {
			return typeof value === jsonSchemaType;
		}

		// Check if the type is an integer
		if (jsonSchemaType === "integer") {
			return Number.isInteger(value);
		}

		// Check if the type is an array
		if (jsonSchemaType === "array") {
			return Array.isArray(value);
		}

		// Check if the type is null
		if (jsonSchemaType === "null") {
			return value === null;
		}

		// Otherwise, return false
		return false;
	}
}

export { SpeechTextAnalyticsAPI };