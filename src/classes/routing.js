/**
 * Queues, wrapup codes, skills, email & sms config, predictive routing
 * @module gc-platform-api-routing
 * @documentation https://developer.genesys.cloud/routing/routing/
 * @license MIT
 */

// This file was automatically generated by the Generate Genesys Cloud Platform API classes utility on 2025-11-26T23:43:17.531Z

// TODO: Implement JSON schema verification for input and output objects
// TODO: Implement HTTP response typedefs

// Set strict mode
"use strict";

// Errors
import { errors } from "../gc-platform-api-client-errors.js";

// Symbols
import { symbols } from "../gc-platform-api-client-symbols.js";

/** @typedef {import("../gc-platform-api-client-class.js").GCPlatformAPIClient} GCPlatformAPIClient */
/** @typedef {import("@jfabello/http-client").HTTPResponse} HTTPResponse */

/**
 * @typedef {object} Actions
 * @property {SkillsToRemove[]} [skillsToRemove]
 */
 
/**
 * @typedef {object} AcwSettings
 * @property {string} [wrapupPrompt] - This field controls how the UI prompts the agent for a wrapup.
 * @property {number} [timeoutMs] - The amount of time the agent can stay in ACW (Min: 1 sec, Max: 60 min).  Can only be used when ACW is AGENT_REQUESTED, MANDATORY_TIMEOUT or MANDATORY_FORCED_TIMEOUT.
 */
 
/**
 * @typedef {object} AddressableEntityRef
 * @property {string} [id]
 * @property {string} [selfUri]
 */
 
/**
 * @typedef {object} AgentDirectRoutingBackupSettings
 * @property {string} [queueId] - ID of queue to be used as backup. If queueId and userId are both specified, queue behaves as secondary backup.
 * @property {string} [userId] - ID of user to be used as backup. If queueId and userId are both specified, user behaves as primary backup.
 * @property {boolean} [waitForAgent] - Flag indicating if Direct Routing interactions should wait for Direct Routing agent or go immediately to selected backup.
 * @property {number} [agentWaitSeconds] - Time (in seconds) that a Direct Routing interaction will wait for Direct Routing agent before going to selected backup. Valid range [60, 864000].
 * @property {string[]} [backedUpUsers] - Set of users that this user is a backup for.
 */
 
/**
 * @typedef {object} AgentOwnedRouting
 * @property {boolean} [enableAgentOwnedCallbacks] - Indicates if Agent Owned Callbacks are enabled for the queue
 * @property {number} [maxOwnedCallbackHours] - The max amount of time a callback can be owned (in hours); Allowable range 1 - 168 hour(s) (inclusive)
 * @property {number} [maxOwnedCallbackDelayHours] - The max amount of time a callback can be scheduled out into the future (in hours); Allowable range 1 - 720 hour(s) (inclusive)
 */
 
/**
 * @typedef {object} Biography
 * @property {string} [biography] - Personal detailed description
 * @property {string[]} [interests]
 * @property {string[]} [hobbies]
 * @property {string} [spouse]
 * @property {Education[]} [education] - User education details
 */
 
/**
 * @typedef {object} Bullseye
 * @property {Ring[]} [rings] - The bullseye rings configured for this queue.
 */
 
/**
 * @typedef {object} CallbackMediaSettings
 * @property {boolean} [enableAutoAnswer] - Indicates if auto-answer is enabled for the given media type or subtype (default is false).  Subtype settings take precedence over media type settings.
 * @property {number} [alertingTimeoutSeconds] - The alerting timeout for the media type, in seconds
 * @property {ServiceLevel} [serviceLevel] - The targeted service level for the media type
 * @property {number} [autoAnswerAlertToneSeconds] - How long to play the alerting tone for an auto-answer interaction
 * @property {number} [manualAnswerAlertToneSeconds] - How long to play the alerting tone for a manual-answer interaction
 * @property {string} [mode] - The mode callbacks will use on this queue.
 * @property {boolean} [enableAutoDialAndEnd] - Flag to enable Auto-Dial and Auto-End automation for callbacks on this queue.
 * @property {number} [autoDialDelaySeconds] - Time in seconds after agent connects to callback before outgoing call is auto-dialed. Allowable values in range 0 - 1200 seconds. Defaults to 300 seconds.
 * @property {number} [autoEndDelaySeconds] - Time in seconds after agent disconnects from the outgoing call before the encasing callback is auto-ended. Allowable values in range 0 - 1200 seconds. Defaults to 300 seconds.
 * @property {number} [pacingModifier] - Controls the maximum number of outbound calls at one time when mode is CustomerFirst.
 * @property {number} [maxRetryCount] - Maximum number of retries that should be attempted to try and connect a customer first callback to a customer when the initial callback attempt did not connect.
 * @property {number} [retryDelaySeconds] - Delay in seconds between each retry of a customer first callback.
 * @property {string} [liveVoiceReactionType] - The action to take if a live voice is detected during the outbound call of a customer first callback.
 * @property {DomainEntityRef} [liveVoiceFlow] - The inbound flow to transfer to if a live voice is detected during the outbound call of a customer first callback.
 * @property {string} [answeringMachineReactionType] - The action to take if an answering machine is detected during the outbound call of a customer first callback.
 * @property {DomainEntityRef} [answeringMachineFlow] - The inbound flow to transfer to if an answering machine is detected during the outbound call of a customer first callback when answeringMachineReactionType is set to TransferToFlow.
 */
 
/**
 * @typedef {object} CannedResponseLibraries
 * @property {string[]} [libraryIds] - Set of canned response library IDs associated with the queue only when mode is SelectedOnly.
 * @property {string} [mode] - The association mode of canned response libraries to queue
 */
 
/**
 * @typedef {object} Chat
 * @property {string} [jabberId]
 */
 
/**
 * @typedef {object} Compliance
 * @property {StopSettings[]} stopSettings - List of configurations for 'StopSettings' compliance
 * @property {OptInSettings[]} optInSettings - List of configurations for 'OptInSettings' compliance
 * @property {HelpSettings[]} helpSettings - List of configurations for 'HelpSettings' compliance
 */
 
/**
 * @typedef {object} ComplianceResponse
 * @property {string} message - Message response
 */
 
/**
 * @typedef {object} ConditionalGroupActivation
 * @property {ConditionalGroupActivationPilotRule} [pilotRule] - The pilot rule for this queue, which executes periodically to determine queue health
 * @property {ConditionalGroupActivationRule[]} [rules] - The set of rules to be periodically executed on the queue (if the pilot rule evaluates as true or there is no pilot rule)
 */
 
/**
 * @typedef {object} ConditionalGroupActivationCondition
 * @property {ConditionalGroupActivationSimpleMetric} [simpleMetric] - Instructs this condition to evaluate a simple queue-level metric
 * @property {string} [operator] - The operator used to compare the actual value against the threshold value
 * @property {number} [value] - The threshold value, beyond which a rule evaluates as true
 */
 
/**
 * @typedef {object} ConditionalGroupActivationPilotRule
 * @property {ConditionalGroupActivationCondition[]} [conditions] - The list of conditions used in this rule
 * @property {string} [conditionExpression] - A string expression that defines the relationships of conditions in this rule
 */
 
/**
 * @typedef {object} ConditionalGroupActivationRule
 * @property {ConditionalGroupActivationCondition[]} [conditions] - The list of conditions used in this rule
 * @property {string} [conditionExpression] - A string expression that defines the relationships of conditions in this rule
 * @property {MemberGroup[]} [groups] - The group(s) that this rule activates (if rule evaluates as true) or deactivates (if rule evaluates as false)
 */
 
/**
 * @typedef {object} ConditionalGroupActivationSimpleMetric
 * @property {string} [metric] - The queue metric being evaluated
 * @property {DomainEntityRef} [queue] - The queue being evaluated for this rule.  If null, the current queue will be used.
 */
 
/**
 * @typedef {object} ConditionalGroupRouting
 * @property {ConditionalGroupRoutingRule[]} [rules] - The set of rules to be executed for each conversation
 */
 
/**
 * @typedef {object} ConditionalGroupRoutingRule
 * @property {DomainEntityRef} [queue] - The queue being evaluated for this rule.  If null, the current queue will be used.
 * @property {string} [metric] - The queue metric being evaluated
 * @property {string} [operator] - The operator that compares the actual value against the condition value
 * @property {number} [conditionValue] - The limit value, beyond which a rule evaluates as true
 * @property {MemberGroup[]} [groups] - The group(s) to activate if the rule evaluates as true
 * @property {number} [waitSeconds] - The number of seconds to wait in this rule, if it evaluates as true, before evaluating the next rule.  For the final rule, this is ignored, so need not be specified.
 */
 
/**
 * @typedef {object} Contact
 * @property {string} [address] - Email address or phone number for this contact type
 * @property {string} [display] - Formatted version of the address property
 * @property {string} [mediaType]
 * @property {string} [type]
 * @property {string} [extension] - Use internal extension instead of address. Mutually exclusive with the address field.
 * @property {string} [countryCode]
 * @property {string} [integration] - Integration tag value if this number is associated with an external integration.
 */
 
/**
 * @typedef {object} ContactCenterSettings
 * @property {boolean} [removeSkillsFromBlindTransfer] - Strip skills from transfer
 */
 
/**
 * @typedef {object} CreateBenefitAssessmentJobRequest
 * @property {string[]} [divisionIds] - The list of division ids for routing queues that are to be assessed for Predictive Routing benefit.
 */
 
/**
 * @typedef {object} CreateBenefitAssessmentRequest
 * @property {string[]} queueIds - The list of queue ids that are to be assessed for Predictive Routing benefit.
 */
 
/**
 * @typedef {object} CreatePredictorRequest
 * @property {string[]} queueIds - The queue IDs associated with the predictor.
 * @property {string} kpi - The KPI that the predictor attempts to maximize/minimize.
 * @property {number} [routingTimeoutSeconds] - Number of seconds allocated to predictive routing before attempting a different routing method. This is a value between 12 and 900 seconds.
 * @property {PredictorSchedule} [schedule] - The predictor schedule that determines when the predictor is used for routing interactions.
 * @property {PredictorWorkloadBalancing} [workloadBalancingConfig] - The predictor balancing configuration to enable workload balancing
 */
 
/**
 * @typedef {object} CreateQueueRequest
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The queue name
 * @property {WritableDivision} [division] - The division to which this entity belongs.
 * @property {string} [description] - The queue description.
 * @property {string} [dateCreated] - The date the queue was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateModified] - The date of the last modification to the queue. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [modifiedBy] - The ID of the user that last modified the queue.
 * @property {string} [createdBy] - The ID of the user that created the queue.
 * @property {number} [memberCount] - The total number of members in the queue.
 * @property {number} [userMemberCount] - The number of user members (i.e., non-group members) in the queue.
 * @property {number} [joinedMemberCount] - The number of joined members in the queue.
 * @property {QueueMediaSettings} [mediaSettings] - The media settings for the queue.
 * @property {RoutingRule[]} [routingRules] - The routing rules for the queue, used for Preferred Agent Routing.
 * @property {ConditionalGroupRouting} [conditionalGroupRouting] - The Conditional Group Routing settings for the queue.
 * @property {ConditionalGroupActivation} [conditionalGroupActivation] - The Conditional Group Activation settings for the queue.
 * @property {Bullseye} [bullseye] - The bullseye settings for the queue.
 * @property {string} [scoringMethod] - The Scoring Method for the queue.
 * @property {string} [lastAgentRoutingMode] - The Last Agent Routing Mode for the queue.
 * @property {AcwSettings} [acwSettings] - The ACW settings for the queue.
 * @property {string} [skillEvaluationMethod] - The skill evaluation method to use when routing conversations.
 * @property {MemberGroup[]} [memberGroups] - The groups of agents associated with the queue, if any.  Queue membership will update to match group membership changes.
 * @property {DomainEntityRef} [queueFlow] - The in-queue flow to use for call conversations waiting in queue.
 * @property {DomainEntityRef} [emailInQueueFlow] - The in-queue flow to use for email conversations waiting in queue.
 * @property {DomainEntityRef} [messageInQueueFlow] - The in-queue flow to use for message conversations waiting in queue.
 * @property {DomainEntityRef} [whisperPrompt] - The prompt used for whisper on the queue, if configured.
 * @property {DomainEntityRef} [onHoldPrompt] - The audio to be played when calls on this queue are on hold. If not configured, the default on-hold music will play.
 * @property {boolean} [autoAnswerOnly] - Specifies whether the configured whisper should play for all ACD calls, or only for those which are auto-answered.
 * @property {CannedResponseLibraries} [cannedResponseLibraries] - Canned response library IDs and mode with which they are associated with the queue
 * @property {boolean} [enableTranscription] - Indicates whether voice transcription is enabled for this queue.
 * @property {boolean} [enableAudioMonitoring] - Indicates whether audio monitoring is enabled for this queue.
 * @property {boolean} [enableManualAssignment] - Indicates whether manual assignment is enabled for this queue.
 * @property {AgentOwnedRouting} [agentOwnedRouting] - The Agent Owned Routing settings for the queue
 * @property {DirectRouting} [directRouting] - The Direct Routing settings for the queue
 * @property {string} [callingPartyName] - The name to use for caller identification for outbound calls from this queue.
 * @property {string} [callingPartyNumber] - The phone number to use for caller identification for outbound calls from this queue.
 * @property {object} [defaultScripts] - The default script Ids for the communication types.
 * @property {QueueMessagingAddresses} [outboundMessagingAddresses] - The messaging addresses for the queue.
 * @property {QueueEmailAddress} [outboundEmailAddress] - The default email address to use for outbound email from this queue.
 * @property {string} [peerId] - The ID of an associated external queue.
 * @property {boolean} [suppressInQueueCallRecording] - Indicates whether recording in-queue calls is suppressed for this queue.
 * @property {string} [sourceQueueId] - The id of an existing queue to copy the settings (does not include GPR settings) from when creating a new queue.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} CreateUtilizationLabelRequest
 * @property {string} name - The utilization label name.
 * @property {LabelUtilizationRequest} [utilization] - Org level utilization settings for the new label. If not specified, default utilization settings will be applied.
 */
 
/**
 * @typedef {object} DirectRouting
 * @property {DirectRoutingMediaSettings} [callMediaSettings] - Direct Routing Settings specific to Call media.
 * @property {DirectRoutingMediaSettings} [emailMediaSettings] - Direct Routing Settings specific to Email media.
 * @property {DirectRoutingMediaSettings} [messageMediaSettings] - Direct Routing Settings specific to Message media.
 * @property {string} [backupQueueId] - ID of another queue to be used as the default backup if an agent does not have their Backup Settings configured. If not set, the current queue will be used as backup, but with Direct Routing criteria removed from the conversation.
 * @property {boolean} [waitForAgent] - Flag indicating if Direct Routing interactions should wait for Direct Routing agent or go immediately to selected backup.
 * @property {number} [agentWaitSeconds] - Time (in seconds) that a Direct Routing interaction will wait for Direct Routing agent before going to selected backup. Valid range [60, 864000].
 */
 
/**
 * @typedef {object} DirectRoutingMediaSettings
 * @property {boolean} [useAgentAddressOutbound] - Toggle that enables using an agent's Direct Routing address outbound on behalf of queue for this media type.
 */
 
/**
 * @typedef {object} Division
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} DomainEntityRef
 * @property {string} [id]
 * @property {string} [name]
 * @property {string} [selfUri]
 */
 
/**
 * @typedef {object} DomainRole
 * @property {string} [id] - The ID of the role
 * @property {string} [name] - The name of the role
 */
 
/**
 * @typedef {object} Education
 * @property {string} [school]
 * @property {string} [fieldOfStudy]
 * @property {string} [notes] - Notes about education has a 2000 character limit
 * @property {string} [dateStart] - Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd
 * @property {string} [dateEnd] - Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd
 */
 
/**
 * @typedef {object} EmailAddress
 * @property {string} [email]
 * @property {string} [name]
 */
 
/**
 * @typedef {object} EmailErrorInfo
 * @property {string} [message] - Error Message
 * @property {string} [code] - Error Code
 */
 
/**
 * @typedef {object} EmailMediaSettings
 * @property {boolean} [enableAutoAnswer] - Indicates if auto-answer is enabled for the given media type or subtype (default is false).  Subtype settings take precedence over media type settings.
 * @property {number} [alertingTimeoutSeconds] - The alerting timeout for the media type, in seconds
 * @property {ServiceLevel} [serviceLevel] - The targeted service level for the media type
 * @property {number} [autoAnswerAlertToneSeconds] - How long to play the alerting tone for an auto-answer interaction
 * @property {number} [manualAnswerAlertToneSeconds] - How long to play the alerting tone for a manual-answer interaction
 */
 
/**
 * Email Setting reference for email routing settings
 * @typedef {object} EmailSettingReference
 * @property {string} id - The email setting unique identifier
 * @property {string} [name]
 * @property {string} [selfUri] - The email setting URI
 */
 
/**
 * @typedef {object} EmployerInfo
 * @property {string} [officialName]
 * @property {string} [employeeId]
 * @property {string} [employeeType]
 * @property {string} [dateHire]
 */
 
/**
 * @typedef {object} ExpansionCriterium
 * @property {string} [type]
 * @property {number} [threshold]
 */
 
/**
 * @typedef {object} Geolocation
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [type] - A string used to describe the type of client the geolocation is being updated from e.g. ios, android, web, etc.
 * @property {boolean} [primary] - A boolean used to tell whether or not to set this geolocation client as the primary on a PATCH
 * @property {number} [latitude]
 * @property {number} [longitude]
 * @property {string} [country]
 * @property {string} [region]
 * @property {string} [city]
 * @property {LocationDefinition[]} [locations]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} Group
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The group name.
 * @property {string} [description]
 * @property {string} [dateModified] - Last modified date/time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {number} [memberCount] - Number of members.
 * @property {string} [state] - Active, inactive, or deleted state.
 * @property {number} [version] - Current version for this resource.
 * @property {string} type - Type of group.
 * @property {Image[]} [images]
 * @property {GroupContact[]} [addresses]
 * @property {boolean} rulesVisible - Are membership rules visible to the person requesting to view the group
 * @property {string} visibility - Who can view this group
 * @property {boolean} [rolesEnabled] - Allow roles to be assigned to this group
 * @property {boolean} [includeOwners] - Allow owners to be included as members of the group
 * @property {boolean} [callsEnabled] - Allow calls to be placed to this group.
 * @property {User[]} [owners] - Owners of the group
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} GroupContact
 * @property {string} address - Phone number for this contact type
 * @property {string} [extension] - Extension is set if the number is e164 valid
 * @property {string} [display] - Formatted version of the address property
 * @property {string} type - Contact type of the address
 * @property {string} mediaType - Media type of the address
 */
 
/**
 * @typedef {object} HelpSettings
 * @property {string[]} keyword - List of keywords for compliance
 * @property {ComplianceResponse} response - The response configuration for the keywords
 */
 
/**
 * @typedef {object} IdentityResolutionQueueConfig
 * @property {OutboundQueueIdentityResolutionConfig} [callOnBehalfOfQueue]
 */
 
/**
 * @typedef {object} Image
 * @property {string} [resolution] - Height and/or width of image. ex: 640x480 or x128
 * @property {string} [imageUri]
 */
 
/**
 * @typedef {object} ImapSettings
 * @property {DomainEntityRef} [integration] - The IMAP server integration to use for ingesting emails.
 * @property {string} [status] - Imap Server Status
 * @property {EmailErrorInfo} [errorInfo] - Additional Imap Server error information
 */
 
/**
 * @typedef {object} InboundDomainCreateRequest
 * @property {string} id - Unique Id of the domain such as: example.com
 * @property {boolean} [subDomain] - Indicates if this a PureCloud sub-domain. If true, then the appropriate DNS records are created for sending/receiving email.
 * @property {MailFromResult} [mailFromSettings] - The DNS settings if the inbound domain is using a custom Mail From. These settings can only be used on InboundDomains where subDomain is false.
 * @property {DomainEntityRef} [customSMTPServer] - The custom SMTP server integration to use when sending outbound emails from this domain.
 * @property {EmailSettingReference} [emailSetting] - The email settings to associate with this domain.
 */
 
/**
 * @typedef {object} InboundDomainPatchRequest
 * @property {MailFromResult} [mailFromSettings] - The DNS settings if the inbound domain is using a custom Mail From. These settings can only be used on InboundDomains where subDomain is false.
 * @property {DomainEntityRef} [customSMTPServer] - The custom SMTP server integration to use when sending outbound emails from this domain.
 * @property {ImapSettings} [imapSettings] - The IMAP server integration and settings to use for processing inbound emails.
 * @property {EmailSettingReference} [emailSetting] - The email settings to associate with this domain.
 */
 
/**
 * @typedef {object} InboundRoute
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} pattern - The search pattern that the mailbox name should match.
 * @property {DomainEntityRef} [queue] - The queue to route the emails to.
 * @property {number} [priority] - The priority to use for routing.
 * @property {DomainEntityRef[]} [skills] - The skills to use for routing.
 * @property {DomainEntityRef} [language] - The language to use for routing.
 * @property {string} fromName - The sender name to use for outgoing replies.
 * @property {string} [fromEmail] - The sender email to use for outgoing replies.
 * @property {DomainEntityRef} [flow] - The flow to use for processing the email.
 * @property {QueueEmailAddress} [replyEmailAddress] - The route to use for email replies.
 * @property {EmailAddress[]} [autoBcc] - The recipients that should be automatically blind copied on outbound emails associated with this InboundRoute.
 * @property {DomainEntityRef} [spamFlow] - The flow to use for processing inbound emails that have been marked as spam.
 * @property {Signature} [signature] - The configuration for the canned response signature that will be appended to outbound emails sent via this route
 * @property {string} [historyInclusion] - The configuration to indicate how the history of a conversation has to be included in a draft
 * @property {boolean} [allowMultipleActions] - Control if multiple actions are allowed on this route. When true the disconnect has to be done manually. When false a conversation will be disconnected by the system after every action
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} LabelUtilizationRequest
 * @property {number} [maximumCapacity] - Defines the maximum number of interactions with this label that an agent can handle at one time.
 * @property {string[]} [interruptingLabelIds] - Defines other labels that can interrupt an interaction with this label.
 */
 
/**
 * @typedef {object} Language
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The language name.
 * @property {string} [dateModified] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [state]
 * @property {string} [version]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} Location
 * @property {string} [id] - Unique identifier for the location
 * @property {string} [floorplanId] - Unique identifier for the location floorplan image
 * @property {object} [coordinates] - Users coordinates on the floorplan. Only used when floorplanImage is set
 * @property {string} [notes] - Optional description on the users location
 * @property {LocationDefinition} [locationDefinition]
 */
 
/**
 * @typedef {object} LocationAddress
 * @property {string} [city]
 * @property {string} [country]
 * @property {string} [countryName]
 * @property {string} [state]
 * @property {string} [street1]
 * @property {string} [street2]
 * @property {string} [zipcode]
 */
 
/**
 * @typedef {object} LocationAddressVerificationDetails
 * @property {string} [status] - Status of address verification process
 * @property {string} [dateFinished] - Finished time of address verification process. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateStarted] - Time started of address verification process. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [service] - Third party service used for address verification
 */
 
/**
 * @typedef {object} LocationDefinition
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {AddressableEntityRef} [contactUser] - Site contact for the location entity
 * @property {LocationEmergencyNumber} [emergencyNumber] - Emergency number for the location entity
 * @property {LocationAddress} [address]
 * @property {string} [state] - Current state of the location entity
 * @property {string} [notes] - Notes for the location entity
 * @property {number} [version] - Current version of the location entity, value to be supplied should be retrieved by a GET or on create/update response
 * @property {string[]} [path] - A list of ancestor IDs in order
 * @property {LocationImage[]} [profileImage] - Profile image of the location entity, retrieved with ?expand=images query parameter
 * @property {LocationImage[]} [floorplanImage] - Floorplan images of the location entity, retrieved with ?expand=images query parameter
 * @property {LocationAddressVerificationDetails} [addressVerificationDetails] - Address verification information, retrieve dwith the ?expand=addressVerificationDetails query parameter
 * @property {boolean} [addressVerified] - Boolean field which states if the address has been verified as an actual address
 * @property {boolean} [addressStored] - Boolean field which states if the address has been stored for E911
 * @property {string} [images]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} LocationEmergencyNumber
 * @property {string} [e164]
 * @property {string} [number]
 * @property {string} [type] - The type of emergency number.
 */
 
/**
 * @typedef {object} LocationImage
 * @property {string} [resolution] - Height and/or width of image. ex: 640x480 or x128
 * @property {string} [imageUri]
 */
 
/**
 * @typedef {object} MailFromResult
 * @property {string} [status] - The verification status.
 * @property {Record[]} [records] - The list of DNS records that pertain that need to exist for verification.
 * @property {string} mailFromDomain - The custom MAIL FROM domain.
 */
 
/**
 * @typedef {object} MediaSettings
 * @property {boolean} [enableAutoAnswer] - Indicates if auto-answer is enabled for the given media type or subtype (default is false).  Subtype settings take precedence over media type settings.
 * @property {number} [alertingTimeoutSeconds] - The alerting timeout for the media type, in seconds
 * @property {ServiceLevel} [serviceLevel] - The targeted service level for the media type
 * @property {number} [autoAnswerAlertToneSeconds] - How long to play the alerting tone for an auto-answer interaction
 * @property {number} [manualAnswerAlertToneSeconds] - How long to play the alerting tone for a manual-answer interaction
 */
 
/**
 * @typedef {object} MediaSummary
 * @property {MediaSummaryDetail} [contactCenter]
 * @property {MediaSummaryDetail} [enterprise]
 */
 
/**
 * @typedef {object} MediaSummaryDetail
 * @property {number} [active]
 * @property {number} [acw]
 */
 
/**
 * Media type definition
 * @typedef {object} MediaType
 * @property {string} [type] - The media type string as defined by RFC 2046. You can define specific types such as 'image/jpeg', 'video/mpeg', or specify wild cards for a range of types, 'image/*', or all types '* /*'. See https://www.iana.org/assignments/media-types/media-types.xhtml for a list of registered media types.
 */
 
/**
 * Media type access definitions
 * @typedef {object} MediaTypeAccess
 * @property {MediaType[]} [inbound] - List of media types allowed for inbound messages from customers. If inbound messages from a customer contain media that is not in this list, the media will be dropped from the outbound message.
 * @property {MediaType[]} [outbound] - List of media types allowed for outbound messages to customers. If an outbound message is sent that contains media that is not in this list, the message will not be sent.
 */
 
/**
 * Media types
 * @typedef {object} MediaTypes
 * @property {MediaTypeAccess} [allow] - Specify allowed media types for inbound and outbound messages. If this field is empty, all inbound and outbound media will be blocked.
 */
 
/**
 * @typedef {object} MemberGroup
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {WritableDivision} [division] - The division to which this entity belongs.
 * @property {string} [type] - The group type
 * @property {number} [memberCount] - The number of members in this group
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} MessageMediaSettings
 * @property {boolean} [enableAutoAnswer] - Indicates if auto-answer is enabled for the given media type or subtype (default is false).  Subtype settings take precedence over media type settings.
 * @property {number} [alertingTimeoutSeconds] - The alerting timeout for the media type, in seconds
 * @property {ServiceLevel} [serviceLevel] - The targeted service level for the media type
 * @property {number} [autoAnswerAlertToneSeconds] - How long to play the alerting tone for an auto-answer interaction
 * @property {number} [manualAnswerAlertToneSeconds] - How long to play the alerting tone for a manual-answer interaction
 * @property {object} [subTypeSettings] - Map of media subtype to media subtype specific settings.
 */
 
/**
 * @typedef {object} NumericRange
 * @property {number} [gt] - Greater than
 * @property {number} [gte] - Greater than or equal to
 * @property {number} [lt] - Less than
 * @property {number} [lte] - Less than or equal to
 */
 
/**
 * @typedef {object} OAuthLastTokenIssued
 * @property {string} [dateIssued] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 */
 
/**
 * @typedef {object} OptInSettings
 * @property {string[]} keyword - List of keywords for compliance
 * @property {ComplianceResponse} response - The response configuration for the keywords
 */
 
/**
 * @typedef {object} OutboundDomainCreateRequest
 * @property {string} id - Unique Id of the domain such as: example.com
 * @property {string} [senderType] - Sender Type
 * @property {EmailSettingReference} [emailSetting] - The email settings to associate with this domain.
 * @property {string} name - The domain such as: example.com
 */
 
/**
 * @typedef {object} OutboundQueueIdentityResolutionConfig
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {WritableStarrableDivision} [division] - The division to use when performing identity resolution.
 * @property {boolean} resolveIdentities - Whether the channel should resolve identities
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} OutOfOffice
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {User} [user]
 * @property {string} [startDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [endDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {boolean} [active]
 * @property {boolean} [indefinite]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} PatchPredictorRequest
 * @property {number} [routingTimeoutSeconds] - Number of seconds allocated to predictive routing before attempting a different routing method. This is a value between 12 and 900 seconds.
 * @property {PredictorSchedule} [schedule] - The predictor schedule that determines when the predictor is used for routing interactions.
 * @property {PredictorWorkloadBalancing} [workloadBalancingConfig] - The predictor balancing configuration to enable workload balancing
 */
 
/**
 * @typedef {object} PredictorSchedule
 * @property {string} scheduleType - The predictor schedule type.
 * @property {string} [dateStarted] - DateTime indicating when the predictor schedule was started. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 */
 
/**
 * @typedef {object} PredictorWorkloadBalancing
 * @property {boolean} enabled - Flag to activate and deactivate workload balancing.
 * @property {number} [minimumOccupancy] - Desired minimum occupancy threshold of agents. Must be between 0 and 100.
 * @property {number} [maximumOccupancy] - Desired maximum occupancy threshold of agents. Must be between 0 and 100.
 */
 
/**
 * @typedef {object} PresenceDefinition
 * @property {string} [id] - description
 * @property {string} [systemPresence]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} QueueEmailAddress
 * @property {DomainEntityRef} [domain]
 * @property {InboundRoute} [route]
 */
 
/**
 * @typedef {object} QueueMediaSettings
 * @property {MediaSettings} [call] - The queue media settings for call interactions.
 * @property {CallbackMediaSettings} [callback] - The queue media settings for callback interactions.
 * @property {MediaSettings} [chat] - The queue media settings for chat interactions.
 * @property {EmailMediaSettings} [email] - The queue media settings for email interactions.
 * @property {MessageMediaSettings} [message] - The queue media settings for message interactions.
 */
 
/**
 * @typedef {object} QueueMember
 * @property {string} [id] - The queue member's id.
 * @property {string} [name]
 * @property {User} [user]
 * @property {number} [ringNumber]
 * @property {boolean} [joined]
 * @property {string} [memberBy]
 * @property {RoutingStatus} [routingStatus]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} QueueMessagingAddresses
 * @property {DomainEntityRef} [smsAddress]
 * @property {DomainEntityRef} [openMessagingRecipient]
 * @property {DomainEntityRef} [whatsAppRecipient]
 */
 
/**
 * @typedef {object} QueueObservationQuery
 * @property {QueueObservationQueryFilter} filter - Filter to return a subset of observations. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {string[]} [detailMetrics] - Metrics for which to include additional detailed observations
 */
 
/**
 * @typedef {object} QueueObservationQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {QueueObservationQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} QueueObservationQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {QueueObservationQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {QueueObservationQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} QueueObservationQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} QueueRequest
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The queue name
 * @property {WritableDivision} [division] - The division to which this entity belongs.
 * @property {string} [description] - The queue description.
 * @property {string} [dateCreated] - The date the queue was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateModified] - The date of the last modification to the queue. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [modifiedBy] - The ID of the user that last modified the queue.
 * @property {string} [createdBy] - The ID of the user that created the queue.
 * @property {number} [memberCount] - The total number of members in the queue.
 * @property {number} [userMemberCount] - The number of user members (i.e., non-group members) in the queue.
 * @property {number} [joinedMemberCount] - The number of joined members in the queue.
 * @property {QueueMediaSettings} [mediaSettings] - The media settings for the queue.
 * @property {RoutingRule[]} [routingRules] - The routing rules for the queue, used for Preferred Agent Routing.
 * @property {ConditionalGroupRouting} [conditionalGroupRouting] - The Conditional Group Routing settings for the queue.
 * @property {ConditionalGroupActivation} [conditionalGroupActivation] - The Conditional Group Activation settings for the queue.
 * @property {Bullseye} [bullseye] - The bullseye settings for the queue.
 * @property {string} [scoringMethod] - The Scoring Method for the queue.
 * @property {string} [lastAgentRoutingMode] - The Last Agent Routing Mode for the queue.
 * @property {AcwSettings} [acwSettings] - The ACW settings for the queue.
 * @property {string} [skillEvaluationMethod] - The skill evaluation method to use when routing conversations.
 * @property {MemberGroup[]} [memberGroups] - The groups of agents associated with the queue, if any.  Queue membership will update to match group membership changes.
 * @property {DomainEntityRef} [queueFlow] - The in-queue flow to use for call conversations waiting in queue.
 * @property {DomainEntityRef} [emailInQueueFlow] - The in-queue flow to use for email conversations waiting in queue.
 * @property {DomainEntityRef} [messageInQueueFlow] - The in-queue flow to use for message conversations waiting in queue.
 * @property {DomainEntityRef} [whisperPrompt] - The prompt used for whisper on the queue, if configured.
 * @property {DomainEntityRef} [onHoldPrompt] - The audio to be played when calls on this queue are on hold. If not configured, the default on-hold music will play.
 * @property {boolean} [autoAnswerOnly] - Specifies whether the configured whisper should play for all ACD calls, or only for those which are auto-answered.
 * @property {CannedResponseLibraries} [cannedResponseLibraries] - Canned response library IDs and mode with which they are associated with the queue
 * @property {boolean} [enableTranscription] - Indicates whether voice transcription is enabled for this queue.
 * @property {boolean} [enableAudioMonitoring] - Indicates whether audio monitoring is enabled for this queue.
 * @property {boolean} [enableManualAssignment] - Indicates whether manual assignment is enabled for this queue.
 * @property {AgentOwnedRouting} [agentOwnedRouting] - The Agent Owned Routing settings for the queue
 * @property {DirectRouting} [directRouting] - The Direct Routing settings for the queue
 * @property {string} [callingPartyName] - The name to use for caller identification for outbound calls from this queue.
 * @property {string} [callingPartyNumber] - The phone number to use for caller identification for outbound calls from this queue.
 * @property {object} [defaultScripts] - The default script Ids for the communication types.
 * @property {QueueMessagingAddresses} [outboundMessagingAddresses] - The messaging addresses for the queue.
 * @property {QueueEmailAddress} [outboundEmailAddress] - The default email address to use for outbound email from this queue.
 * @property {string} [peerId] - The ID of an associated external queue.
 * @property {boolean} [suppressInQueueCallRecording] - Indicates whether recording in-queue calls is suppressed for this queue.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} RecipientFlow
 * @property {string} [id] - The flow identifier
 */
 
/**
 * @typedef {object} RecipientRequest
 * @property {RecipientFlow} [flow] - An automate flow object which defines the set of actions to be taken, when a message is received by this recipient.
 */
 
/**
 * @typedef {object} Record
 * @property {string} name - The name of the record.
 * @property {string} type - The type of the record. (Example values:  MX, TXT, CNAME)
 * @property {string} value - The value of the record.
 */
 
/**
 * @typedef {object} RequestScoredAgent
 * @property {string} [id] - Agent's user ID
 * @property {number} [score] - Agent's score for the current conversation, from 0 - 100, higher being better
 */
 
/**
 * @typedef {object} ResourceConditionNode
 * @property {string} [variableName]
 * @property {string} [conjunction]
 * @property {string} [operator]
 * @property {ResourceConditionValue[]} [operands]
 * @property {ResourceConditionNode[]} [terms]
 */
 
/**
 * @typedef {object} ResourceConditionValue
 * @property {string} [type]
 * @property {string} [value]
 */
 
/**
 * @typedef {object} ResourcePermissionPolicy
 * @property {string} [id]
 * @property {string} [domain]
 * @property {string} [entityName]
 * @property {string} [policyName]
 * @property {string} [policyDescription]
 * @property {string} [actionSetKey]
 * @property {boolean} [allowConditions]
 * @property {ResourceConditionNode} [resourceConditionNode]
 * @property {string[]} [namedResources]
 * @property {string} [resourceCondition]
 * @property {string[]} [actionSet]
 */
 
/**
 * @typedef {object} Ring
 * @property {ExpansionCriterium[]} [expansionCriteria] - The conditions that will trigger conversations to move to the next bullseye ring.
 * @property {Actions} [actions] - The actions that will be performed just before moving conversations to the next bullseye ring.
 * @property {MemberGroup[]} [memberGroups] - The groups of agents associated with the ring, if any.  Ring membership will update to match group membership changes.
 */
 
/**
 * @typedef {object} RouteIdentityResolutionConfig
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {WritableStarrableDivision} [division] - The division to use when performing identity resolution.
 * @property {boolean} resolveIdentities - Whether the channel should resolve identities
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} RoutingActivityQuery
 * @property {RoutingActivityQueryMetric[]} metrics - List of requested metrics
 * @property {string[]} groupBy - Dimension(s) to group by
 * @property {RoutingActivityQueryFilter} [filter] - Filter to return a subset of observations. Expresses boolean logical predicates as well as dimensional filters
 * @property {string} [order] - Sort the result set in ascending/descending order. Default is ascending
 */
 
/**
 * @typedef {object} RoutingActivityQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {RoutingActivityQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} RoutingActivityQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {RoutingActivityQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {RoutingActivityQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} RoutingActivityQueryMetric
 * @property {string} metric - The requested metric
 * @property {boolean} [details] - Flag for including observation details for this metric in the response
 */
 
/**
 * @typedef {object} RoutingActivityQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} RoutingConversationAttributesRequest
 * @property {number} [priority] - Priority for the conversation.  Each point of priority is equivalent to one minute of time in queue.  Range:[-25000000, 25000000].  To reset, specify 0.
 * @property {string[]} [skillIds] - Skill requirements for the conversation.  To remove all skill requirements, specify an empty list, i.e. [].
 * @property {string} [languageId] - Language requirement for the conversation.  To remove the language requirement, specify an empty string, i.e., "".
 * @property {string} [labelId] - Label requirement for the conversation.  To remove the label requirement (setting it to System Default Label), specify an empty string, i.e., "".
 * @property {RequestScoredAgent[]} [requestScoredAgents]
 */
 
/**
 * @typedef {object} RoutingRule
 * @property {string} [operator] - matching operator.  MEETS_THRESHOLD matches any agent with a score at or above the rule's threshold.  ANY matches all specified agents, regardless of score.
 * @property {number} [threshold] - threshold required for routing attempt (generally an agent score).  may be null for operator ANY.
 * @property {number} [waitSeconds] - seconds to wait in this rule before moving to the next
 */
 
/**
 * @typedef {object} RoutingSettings
 * @property {boolean} [resetAgentScoreOnPresenceChange] - Reset agent score when agent presence changes from off-queue to on-queue
 */
 
/**
 * @typedef {object} RoutingSkill
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The name of the skill.
 * @property {string} [dateModified] - Date last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [state] - The current state for this skill.
 * @property {string} [version] - Required when updating. Version must be the current version. Only the system can assign version.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} RoutingStatus
 * @property {string} [userId] - The userId of the agent
 * @property {string} [status] - Indicates the Routing State of the agent.  A value of OFF_QUEUE will be returned if the specified user does not exist.
 * @property {string} [startTime] - The timestamp when the agent went into this state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 */
 
/**
 * @typedef {object} ServiceLevel
 * @property {number} [percentage] - The desired Service Level. A value between 0 and 1.
 * @property {number} [durationMs] - Service Level target in milliseconds.
 */
 
/**
 * @typedef {object} Signature
 * @property {boolean} [enabled] - A toggle to enable the signature on email send.
 * @property {string} [cannedResponseId] - The identifier referring to an email signature canned response.
 * @property {boolean} [alwaysIncluded] - A toggle that defines if a signature is always included or only set on the first email in an email chain.
 * @property {string} [inclusionType] - The configuration to indicate when the signature of a conversation has to be included
 */
 
/**
 * @typedef {object} SkillGroup
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The group name.
 * @property {WritableDivision} [division] - The division to which this entity belongs.
 * @property {string} [description] - Group description
 * @property {number} [memberCount] - Estimated number of members in this group. It can take some time for the count to be updated after expressions are changed.
 * @property {string} [dateModified] - Last modified date/time of the skill group. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateCreated] - Created date/time of the skill group. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [status] - Group's filling status
 * @property {SkillGroupCondition[]} skillConditions - Conditions for this group
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} SkillGroupCondition
 * @property {SkillGroupRoutingCondition[]} routingSkillConditions - Routing skill conditions that will be used for building the query
 * @property {SkillGroupLanguageCondition[]} languageSkillConditions - Routing skill conditions that will be used for building the query
 * @property {string} operation - Operator that will be applied to the conditions
 */
 
/**
 * @typedef {object} SkillGroupLanguageCondition
 * @property {string} languageSkill - The language skill to be used in the skill condition query
 * @property {string} comparator - Comparator that will be applied to the proficiency
 * @property {number} proficiency - The skill proficiency that will be used for the language skill. Integer range 0-5
 * @property {SkillGroupCondition[]} [childConditions] - Nested conditions to be applied to this skill condition
 */
 
/**
 * @typedef {object} SkillGroupMemberDivisions
 * @property {string[]} [addDivisionIds]
 * @property {string[]} [removeDivisionIds]
 */
 
/**
 * @typedef {object} SkillGroupRoutingCondition
 * @property {string} routingSkill - The routing skill to be used in the skill condition query
 * @property {string} comparator - Comparator that will be applied to the proficiency
 * @property {number} proficiency - The skill proficiency that will be used for the routing skill. Integer range 0-5
 * @property {SkillGroupCondition[]} [childConditions] - Nested conditions to be applied to this skill condition
 */
 
/**
 * @typedef {object} SkillGroupWithMemberDivisions
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The group name.
 * @property {WritableDivision} [division] - The division to which this entity belongs.
 * @property {string} [description] - Group description
 * @property {number} [memberCount] - Estimated number of members in this group. It can take some time for the count to be updated after expressions are changed.
 * @property {string} [dateModified] - Last modified date/time of the skill group. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateCreated] - Created date/time of the skill group. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [status] - Group's filling status
 * @property {SkillGroupCondition[]} skillConditions - Conditions for this group
 * @property {string[]} [memberDivisions] - Member divisions for this skill group
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} SkillsToRemove
 * @property {string} [name]
 * @property {string} [id]
 * @property {string} [selfUri]
 */
 
/**
 * @typedef {object} SmsAddressProvision
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - Name associated with this address
 * @property {string} street - The number and street address where this address is located.
 * @property {string} city - The city in which this address is in
 * @property {string} region - The state or region this address is in
 * @property {string} postalCode - The postal code this address is in
 * @property {string} countryCode - The ISO country code of this address
 * @property {boolean} [autoCorrectAddress] - This is used when the address is created. If the value is not set or true, then the system will, if necessary, auto-correct the address you provide. Set this value to false if the system should not auto-correct the address.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} SmsIdentityResolutionConfig
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {WritableStarrableDivision} [division] - The division to use when performing identity resolution.
 * @property {boolean} resolveIdentities - Whether the channel should resolve identities
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} SmsPhoneNumberImport
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} phoneNumber - A phone number to be used for SMS communications. E.g. +13175555555 or +34234234234
 * @property {string} phoneNumberType - Type of the phone number provisioned.
 * @property {string} countryCode - The ISO 3166-1 alpha-2 country code of the country this phone number is associated with.
 * @property {string} integrationId - The id of the Genesys Cloud integration this phone number belongs to.
 * @property {Compliance} [compliance] - Compliance configuration for short codes, including help, stop and opt in.
 * @property {SupportedContentReference} [supportedContent] - Defines the media SupportedContent profile configured for an MMS capable phone number.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} SmsPhoneNumberPatchRequest
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {SupportedContentReference} [supportedContent] - Defines the media SupportedContent profile configured for an MMS capable phone number.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} SmsPhoneNumberProvision
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} phoneNumber - A phone number to be used for SMS communications. E.g. +13175555555 or +34234234234
 * @property {string} phoneNumberType - Type of the phone number provisioned.
 * @property {string} countryCode - The ISO 3166-1 alpha-2 country code of the country this phone number is associated with.
 * @property {string} [name]
 * @property {string} [addressId] - The id of an address added on your account. Due to regulatory requirements in some countries, an address may be required when provisioning a sms number. In those cases you should provide the provisioned sms address id here
 * @property {SupportedContentReference} [supportedContent] - Defines the media SupportedContent profile configured for an MMS capable phone number.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} StopSettings
 * @property {string[]} keyword - List of keywords for compliance
 * @property {ComplianceResponse} response - The response configuration for the keywords
 */
 
/**
 * Reference to supported content profile associated with the integration
 * @typedef {object} SupportedContentReference
 * @property {string} id - The SupportedContent unique identifier associated with this integration
 * @property {string} [name] - The SupportedContent profile name
 * @property {string} [selfUri] - The SupportedContent profile URI
 * @property {MediaTypes} [mediaTypes] - Media types definition for the supported content
 */
 
/**
 * @typedef {object} Team
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The team name
 * @property {WritableDivision} [division] - The division to which this entity belongs.
 * @property {string} [description] - Team information.
 * @property {string} [dateCreated] - Last modified datetime. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateModified] - Last modified datetime. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {number} [memberCount] - Number of members in a team
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} TestMessage
 * @property {string} [id] - After the message has been sent, this is the value of the Message-ID email header.
 * @property {EmailAddress[]} to - The recipients of the email message.
 * @property {EmailAddress} from - The sender of the email message.
 * @property {string} [subject] - The subject of the email message.
 * @property {string} textBody - The text body of the email message.
 * @property {string} [htmlBody] - The html body of the email message
 * @property {string} [time] - The time when the message was sent. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 */
 
/**
 * @typedef {object} TranscriptionSettings
 * @property {string} transcription - Setting to enable/disable transcription capability
 * @property {number} transcriptionConfidenceThreshold - Configure confidence threshold. The possible values are from 1 to 100.
 * @property {boolean} [lowLatencyTranscriptionEnabled] - Boolean flag indicating whether low latency transcription via Notification API is enabled
 * @property {boolean} [contentSearchEnabled] - Setting to enable/disable content search
 * @property {boolean} [pciDssRedactionEnabled] - Setting to enable/disable PCI DSS Redaction
 * @property {boolean} [piiRedactionEnabled] - Setting to enable/disable PII Redaction
 */
 
/**
 * @typedef {object} UpdateUtilizationLabelRequest
 * @property {string} name - The utilization label name.
 */
 
/**
 * @typedef {object} User
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {Division} [division] - The division to which this entity belongs.
 * @property {Chat} [chat]
 * @property {string} [department]
 * @property {string} [email]
 * @property {Contact[]} [primaryContactInfo] - Auto populated from addresses.
 * @property {Contact[]} [addresses] - Email addresses and phone numbers for this user
 * @property {string} [state] - The current state for this user.
 * @property {string} [title]
 * @property {string} [username]
 * @property {User} [manager]
 * @property {Image[]} [images]
 * @property {number} version - Required when updating a user, this value should be the current version of the user.  The current version can be obtained with a GET on the user before doing a PATCH.
 * @property {string[]} [certifications]
 * @property {Biography} [biography]
 * @property {EmployerInfo} [employerInfo]
 * @property {string} [preferredName] - Preferred full name of the agent
 * @property {RoutingStatus} [routingStatus] - ACD routing status
 * @property {UserPresence} [presence] - Active presence
 * @property {UserPresence} [integrationPresence] - Integration presence
 * @property {UserConversationSummary} [conversationSummary] - Summary of conversion statistics for conversation types.
 * @property {OutOfOffice} [outOfOffice] - Determine if out of office is enabled
 * @property {Geolocation} [geolocation] - Current geolocation position
 * @property {UserStations} [station] - Effective, default, and last station information
 * @property {UserAuthorization} [authorization] - Roles and permissions assigned to the user
 * @property {string[]} [profileSkills] - Profile skills possessed by the user
 * @property {Location[]} [locations] - The user placement at each site location.
 * @property {Group[]} [groups] - The groups the user is a member of
 * @property {Team} [team] - The team the user is a member of
 * @property {WorkPlanBidRanks} [workPlanBidRanks] - The WFM work plan bid rank settings for the user
 * @property {UserRoutingSkill[]} [skills] - Routing (ACD) skills possessed by the user
 * @property {UserRoutingLanguage[]} [languages] - Routing (ACD) languages possessed by the user
 * @property {boolean} [acdAutoAnswer] - acd auto answer
 * @property {string} [languagePreference] - preferred language by the user
 * @property {OAuthLastTokenIssued} [lastTokenIssued]
 * @property {string} [dateLastLogin] - The last time the user logged in using username and password. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateWelcomeSent] - The date & time the user was sent their welcome email. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} UserAuthorization
 * @property {DomainRole[]} [roles]
 * @property {DomainRole[]} [unusedRoles] - A collection of the roles the user is not using
 * @property {string[]} [permissions] - A collection of the permissions granted by all assigned roles
 * @property {ResourcePermissionPolicy[]} [permissionPolicies] - The policies configured for assigned permissions.
 */
 
/**
 * @typedef {object} UserConversationSummary
 * @property {string} [userId]
 * @property {MediaSummary} [call]
 * @property {MediaSummary} [callback]
 * @property {MediaSummary} [email]
 * @property {MediaSummary} [message]
 * @property {MediaSummary} [chat]
 * @property {MediaSummary} [socialExpression]
 * @property {MediaSummary} [video]
 */
 
/**
 * @typedef {object} UserPresence
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [source] - Deprecated - The sourceID field should be used as a replacement.
 * @property {string} [sourceId] - Represents the ID of a registered source
 * @property {boolean} [primary] - A boolean used to tell whether or not to set this presence source as the primary on a PATCH
 * @property {PresenceDefinition} [presenceDefinition]
 * @property {string} [message]
 * @property {string} [modifiedDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} UserQueue
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {Division} [division] - The division to which this entity belongs.
 * @property {string} [description] - The queue description.
 * @property {string} [dateCreated] - The date the queue was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateModified] - The date of the last modification to the queue. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [modifiedBy] - The ID of the user that last modified the queue.
 * @property {string} [createdBy] - The ID of the user that created the queue.
 * @property {number} [memberCount] - The total number of members in the queue.
 * @property {number} [userMemberCount] - The number of user members (i.e., non-group members) in the queue.
 * @property {number} [joinedMemberCount] - The number of joined members in the queue.
 * @property {QueueMediaSettings} [mediaSettings] - The media settings for the queue.
 * @property {RoutingRule[]} [routingRules] - The routing rules for the queue, used for Preferred Agent Routing.
 * @property {ConditionalGroupRouting} [conditionalGroupRouting] - The Conditional Group Routing settings for the queue.
 * @property {ConditionalGroupActivation} [conditionalGroupActivation] - The Conditional Group Activation settings for the queue.
 * @property {Bullseye} [bullseye] - The bullseye settings for the queue.
 * @property {string} [scoringMethod] - The Scoring Method for the queue.
 * @property {string} [lastAgentRoutingMode] - The Last Agent Routing Mode for the queue.
 * @property {AcwSettings} [acwSettings] - The ACW settings for the queue.
 * @property {string} [skillEvaluationMethod] - The skill evaluation method to use when routing conversations.
 * @property {MemberGroup[]} [memberGroups] - The groups of agents associated with the queue, if any.  Queue membership will update to match group membership changes.
 * @property {DomainEntityRef} [queueFlow] - The in-queue flow to use for call conversations waiting in queue.
 * @property {DomainEntityRef} [emailInQueueFlow] - The in-queue flow to use for email conversations waiting in queue.
 * @property {DomainEntityRef} [messageInQueueFlow] - The in-queue flow to use for message conversations waiting in queue.
 * @property {DomainEntityRef} [whisperPrompt] - The prompt used for whisper on the queue, if configured.
 * @property {DomainEntityRef} [onHoldPrompt] - The audio to be played when calls on this queue are on hold. If not configured, the default on-hold music will play.
 * @property {CannedResponseLibraries} [cannedResponseLibraries] - Canned response library IDs and mode with which they are associated with the queue
 * @property {boolean} [enableTranscription] - Indicates whether voice transcription is enabled for this queue.
 * @property {boolean} [enableAudioMonitoring] - Indicates whether audio monitoring is enabled for this queue.
 * @property {boolean} [enableManualAssignment] - Indicates whether manual assignment is enabled for this queue.
 * @property {AgentOwnedRouting} [agentOwnedRouting] - The Agent Owned Routing settings for the queue
 * @property {DirectRouting} [directRouting] - The Direct Routing settings for the queue
 * @property {string} [callingPartyName] - The name to use for caller identification for outbound calls from this queue.
 * @property {string} [callingPartyNumber] - The phone number to use for caller identification for outbound calls from this queue.
 * @property {object} [defaultScripts] - The default script Ids for the communication types.
 * @property {QueueMessagingAddresses} [outboundMessagingAddresses] - The messaging addresses for the queue.
 * @property {QueueEmailAddress} [outboundEmailAddress] - The default email address to use for outbound email from this queue.
 * @property {string} [peerId] - The ID of an associated external queue.
 * @property {boolean} [suppressInQueueCallRecording] - Indicates whether recording in-queue calls is suppressed for this queue.
 * @property {boolean} [joined]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * Represents an organization language assigned to a user. When assigning to a user specify the organization language id as the id.
 * @typedef {object} UserRoutingLanguage
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {number} [proficiency] - A rating from 0.0 to 5.0 that indicates how fluent an agent is in a particular language. ACD interactions are routed to agents with higher proficiency ratings.
 * @property {string} [state] - Activate or deactivate this routing language.
 * @property {string} [languageUri] - URI to the organization language used by this user language.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * Represents an organization language assigned to a user. When assigning to a user specify the organization langauge id as the id.
 * @typedef {object} UserRoutingLanguagePost
 * @property {string} id - The id of the existing routing language to add to the user
 * @property {number} proficiency - Proficiency is a rating from 0.0 to 5.0 on how competent an agent is for a particular language. It is used when a queue is set to "Best available language" mode to allow acd interactions to target agents with higher proficiency ratings.
 * @property {string} [languageUri] - URI to the organization language used by this user language.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * Represents an organization skill assigned to a user. When assigning to a user specify the organization skill id as the id.
 * @typedef {object} UserRoutingSkill
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {number} [proficiency] - A rating from 0.0 to 5.0 that indicates how adept an agent is at a particular skill. When "Best available skills" is enabled for a queue in Genesys Cloud, ACD interactions in that queue are routed to agents with higher proficiency ratings.
 * @property {string} [state] - Activate or deactivate this routing skill.
 * @property {string} [skillUri] - URI to the organization skill used by this user skill.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * Represents an organization skill assigned to a user. When assigning to a user specify the organization skill id as the id.
 * @typedef {object} UserRoutingSkillPost
 * @property {string} id - The id of the existing routing skill to add to the user
 * @property {number} proficiency - Proficiency is a rating from 0.0 to 5.0 on how competent an agent is for a particular skill. It is used when a queue is set to "Best available skills" mode to allow acd interactions to target agents with higher proficiency ratings.
 * @property {string} [skillUri] - URI to the organization skill used by this user skill.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} UserStation
 * @property {string} [id] - A globally unique identifier for this station
 * @property {string} [name]
 * @property {string} [type]
 * @property {User} [associatedUser]
 * @property {string} [associatedDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {User} [defaultUser]
 * @property {object} [providerInfo] - Provider-specific info for this station, e.g. { "edgeGroupId": "ffe7b15c-a9cc-4f4c-88f5-781327819a49" }
 * @property {number} [webRtcCallAppearances] - The number of call appearances on the station.
 */
 
/**
 * @typedef {object} UserStations
 * @property {UserStation} [associatedStation] - Current associated station for this user.
 * @property {UserStation} [effectiveStation] - The station where the user can be reached based on their default and associated station.
 * @property {UserStation} [defaultStation] - Default station to be used if not associated with a station.
 * @property {UserStation} [lastAssociatedStation] - Last associated station for this user.
 */
 
/**
 * @typedef {object} UtilizationRequest
 * @property {object} [utilization] - Map of media type to utilization settings.
 * @property {object} [labelUtilizations] - Map of label ids to utilization settings.
 */
 
/**
 * @typedef {object} WorkPlanBidRanks
 * @property {string} [id] - The globally unique identifier for the user.
 * @property {number} [workPlanBiddingPerformance] - Work plan bidding agent performance ranking. The range of values is between 0 and 9999.
 * @property {string} [biddingTieBreaker] - Custom agent ranking metric that some customers can use.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} WrapUpCodeReference
 * @property {string} [id] - The globally unique identifier for the object.
 */
 
/**
 * @typedef {object} WrapupCodeRequest
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The wrap-up code name.
 * @property {WritableStarrableDivision} [division] - The division to which this entity belongs.
 * @property {string} [description] - The wrap-up code description.
 * @property {string} [dateCreated] - Date when the wrap-up code was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateModified] - Date when the wrap-up code was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [createdBy] - The ID of the user that created the wrap-up code.
 * @property {string} [modifiedBy] - The ID of the user that modified the wrap-up code.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} WritableDivision
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} WritableEntity
 * @property {string} [id] - The globally unique identifier for the object.
 */
 
/**
 * @typedef {object} WritableStarrableDivision
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [selfUri] - The URI for this object
 */
 

/**
 * Routing - Queues, wrapup codes, skills, email & sms config, predictive routing
 * @class Routing
 */
class RoutingAPI {
	// Private instance properties
	#gcPlatformAPIClient = null;

	/**
	 * Constructor for the Routing class
	 * @constructor
	 * @param {GCPlatformAPIClient} gcPlatformAPIClient - The Genesys Cloud Platform API client instance.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_INSTANCE_TYPE_INVALID} If the Genesys Cloud Platform API client instance argument is not an object.
	 */
	constructor(gcPlatformAPIClient) {
		// Check the Genesys Cloud Platform API client instance argument
		if (typeof gcPlatformAPIClient !== "object" || symbols.GCPlatformAPIClient in gcPlatformAPIClient === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_INSTANCE_TYPE_INVALID();
		}

		// Initialize the instance properties
		this.#gcPlatformAPIClient = gcPlatformAPIClient;
	}

	/**
	 * Query for queue observations
	 * @async
	 * @param {QueueObservationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/queues/observations/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsQueuesObservationsQuery(body) {
		const endpointPath = "/api/v2/analytics/queues/observations/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for user activity observations
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  The desired page size
	 * @param {number} [query.pageNumber] -  The desired page number
	 * @param {RoutingActivityQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/routing/activity/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsRoutingActivityQuery(query, body) {
		const endpointPath = "/api/v2/analytics/routing/activity/query";
		const endpointMethod = "POST";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get Estimated Wait Time
	 * @async
	 * @param {string} queueId - queueId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.conversationId] -  conversationId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}/estimatedwaittime" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingQueueEstimatedwaittime(queueId, query) {
		const endpointPath = "/api/v2/routing/queues/{queueId}/estimatedwaittime";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("conversationId" in query && this.#checkJSONSchemaType(query["conversationId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get Estimated Wait Time
	 * @async
	 * @param {string} queueId - queueId
	 * @param {string} mediaType - mediaType
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.labelId] -  Unique id that represents the interaction label used with media type for EWT calculation
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}/mediatypes/{mediaType}/estimatedwaittime" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingQueueMediatypeEstimatedwaittime(queueId, mediaType, query) {
		const endpointPath = "/api/v2/routing/queues/{queueId}/mediatypes/{mediaType}/estimatedwaittime";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		if (this.#checkJSONSchemaType(mediaType, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "mediaType", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("labelId" in query && this.#checkJSONSchemaType(query["labelId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "labelId", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;
		apiCallOptions.pathParameters.mediaType = mediaType;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get available media types
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/availablemediatypes" endpoint.
	 */
	getRoutingAvailablemediatypes() {
		const endpointPath = "/api/v2/routing/availablemediatypes";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a routing language
	 * @async
	 * @param {string} languageId - Language ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/languages/{languageId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingLanguage(languageId) {
		const endpointPath = "/api/v2/routing/languages/{languageId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(languageId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "languageId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.languageId = languageId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a routing language
	 * @async
	 * @param {string} languageId - Language ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/languages/{languageId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteRoutingLanguage(languageId) {
		const endpointPath = "/api/v2/routing/languages/{languageId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(languageId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "languageId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.languageId = languageId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the list of supported languages.
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.sortOrder] -  Ascending or descending sort order
	 * @param {string} [query.name] -  Name
	 * @param {string[]} [query.id] -  id
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/languages" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingLanguages(query) {
		const endpointPath = "/api/v2/routing/languages";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("sortOrder" in query && this.#checkJSONSchemaType(query["sortOrder"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortOrder", "string");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
			if ("id" in query && this.#checkJSONSchemaType(query["id"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "id", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create Language
	 * @async
	 * @param {Language} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/languages" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRoutingLanguages(body) {
		const endpointPath = "/api/v2/routing/languages";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a paged listing of simplified queue objects, filterable by name, queue ID(s), or division ID(s).
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size [max value is 100]
	 * @param {number} [query.pageNumber] -  Page number [max value is 5]
	 * @param {string} [query.sortBy] -  Sort by
	 * @param {string} [query.sortOrder] -  Sort order
	 * @param {string} [query.name] -  Name
	 * @param {string[]} [query.id] -  Queue ID(s)
	 * @param {string[]} [query.divisionId] -  Division ID(s)
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/divisionviews" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingQueuesDivisionviews(query) {
		const endpointPath = "/api/v2/routing/queues/divisionviews";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("sortBy" in query && this.#checkJSONSchemaType(query["sortBy"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortBy", "string");
			}
			if ("sortOrder" in query && this.#checkJSONSchemaType(query["sortOrder"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortOrder", "string");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
			if ("id" in query && this.#checkJSONSchemaType(query["id"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "id", "array");
			}
			if ("divisionId" in query && this.#checkJSONSchemaType(query["divisionId"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "divisionId", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a paged listing of simplified queue objects, sorted by name.  Can be used to get a digest of all queues in an organization.
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size [max value is 500]
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.sortOrder] -  Sort order
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/divisionviews/all" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingQueuesDivisionviewsAll(query) {
		const endpointPath = "/api/v2/routing/queues/divisionviews/all";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("sortOrder" in query && this.#checkJSONSchemaType(query["sortOrder"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortOrder", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get Queue IdentityResolution Settings.
	 * @async
	 * @param {string} queueId - Queue ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}/identityresolution" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingQueueIdentityresolution(queueId) {
		const endpointPath = "/api/v2/routing/queues/{queueId}/identityresolution";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update Queue IdentityResolution Settings.
	 * @async
	 * @param {string} queueId - Queue ID
	 * @param {IdentityResolutionQueueConfig} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}/identityresolution" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putRoutingQueueIdentityresolution(queueId, body) {
		const endpointPath = "/api/v2/routing/queues/{queueId}/identityresolution";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get details about this queue.
	 * @async
	 * @param {string} queueId - Queue ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string[]} [query.expand] -  Which fields, if any, to expand
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingQueue(queueId, query) {
		const endpointPath = "/api/v2/routing/queues/{queueId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a queue
	 * @async
	 * @param {string} queueId - Queue ID
	 * @param {QueueRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putRoutingQueue(queueId, body) {
		const endpointPath = "/api/v2/routing/queues/{queueId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a queue
	 * @async
	 * @param {string} queueId - Queue ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.forceDelete] -  forceDelete
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	deleteRoutingQueue(queueId, query) {
		const endpointPath = "/api/v2/routing/queues/{queueId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("forceDelete" in query && this.#checkJSONSchemaType(query["forceDelete"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "forceDelete", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the wrap-up codes for a queue
	 * @async
	 * @param {string} queueId - Queue ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.name] -  Wrapup code's name (trailing asterisks allowed)
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}/wrapupcodes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingQueueWrapupcodes(queueId, query) {
		const endpointPath = "/api/v2/routing/queues/{queueId}/wrapupcodes";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Add up to 100 wrap-up codes to a queue
	 * @async
	 * @param {string} queueId - Queue ID
	 * @param {WrapUpCodeReference[]} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}/wrapupcodes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRoutingQueueWrapupcodes(queueId, body) {
		const endpointPath = "/api/v2/routing/queues/{queueId}/wrapupcodes";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "array") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "array", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a wrap-up code from a queue
	 * @async
	 * @param {string} queueId - Queue ID
	 * @param {string} codeId - Code ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}/wrapupcodes/{codeId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteRoutingQueueWrapupcode(queueId, codeId) {
		const endpointPath = "/api/v2/routing/queues/{queueId}/wrapupcodes/{codeId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		if (this.#checkJSONSchemaType(codeId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "codeId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;
		apiCallOptions.pathParameters.codeId = codeId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a paged listing of queues the user is a member of.
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {number} [query.pageSize] -  Page size
	 * @param {boolean} [query.joined] -  Filter by joined status.
	 * @param {string} [query.sortOrder] -  Note: results are sorted by name.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/me" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingQueuesMe(query) {
		const endpointPath = "/api/v2/routing/queues/me";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("joined" in query && this.#checkJSONSchemaType(query["joined"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "joined", "boolean");
			}
			if ("sortOrder" in query && this.#checkJSONSchemaType(query["sortOrder"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortOrder", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get list of queues.
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {number} [query.pageSize] -  Page size
	 * @param {string} [query.sortOrder] -  Note: results are sorted by name.
	 * @param {string} [query.name] -  Include only queues with the given name (leading and trailing asterisks allowed)
	 * @param {string[]} [query.id] -  Include only queues with the specified ID(s)
	 * @param {string[]} [query.divisionId] -  Include only queues in the specified division ID(s)
	 * @param {string[]} [query.peerId] -  Include only queues with the specified peer ID(s)
	 * @param {string} [query.cannedResponseLibraryId] -  Include only queues explicitly associated with the specified canned response library ID
	 * @param {boolean} [query.hasPeer] -  Include only queues with a peer ID
	 * @param {string[]} [query.expand] -  Which fields, if any, to expand
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingQueues(query) {
		const endpointPath = "/api/v2/routing/queues";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("sortOrder" in query && this.#checkJSONSchemaType(query["sortOrder"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortOrder", "string");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
			if ("id" in query && this.#checkJSONSchemaType(query["id"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "id", "array");
			}
			if ("divisionId" in query && this.#checkJSONSchemaType(query["divisionId"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "divisionId", "array");
			}
			if ("peerId" in query && this.#checkJSONSchemaType(query["peerId"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "peerId", "array");
			}
			if ("cannedResponseLibraryId" in query && this.#checkJSONSchemaType(query["cannedResponseLibraryId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "cannedResponseLibraryId", "string");
			}
			if ("hasPeer" in query && this.#checkJSONSchemaType(query["hasPeer"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "hasPeer", "boolean");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a queue
	 * @async
	 * @param {CreateQueueRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRoutingQueues(body) {
		const endpointPath = "/api/v2/routing/queues";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get Transcription Settings
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/settings/transcription" endpoint.
	 */
	getRoutingSettingsTranscription() {
		const endpointPath = "/api/v2/routing/settings/transcription";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update Transcription Settings
	 * @async
	 * @param {TranscriptionSettings} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/settings/transcription" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putRoutingSettingsTranscription(body) {
		const endpointPath = "/api/v2/routing/settings/transcription";
		const endpointMethod = "PUT";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Patch Transcription Settings
	 * @async
	 * @param {TranscriptionSettings} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/settings/transcription" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchRoutingSettingsTranscription(body) {
		const endpointPath = "/api/v2/routing/settings/transcription";
		const endpointMethod = "PATCH";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get Contact Center Settings
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/settings/contactcenter" endpoint.
	 */
	getRoutingSettingsContactcenter() {
		const endpointPath = "/api/v2/routing/settings/contactcenter";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update Contact Center Settings
	 * @async
	 * @param {ContactCenterSettings} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/settings/contactcenter" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchRoutingSettingsContactcenter(body) {
		const endpointPath = "/api/v2/routing/settings/contactcenter";
		const endpointMethod = "PATCH";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get an organization's routing settings
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/settings" endpoint.
	 */
	getRoutingSettings() {
		const endpointPath = "/api/v2/routing/settings";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update an organization's routing settings
	 * @async
	 * @param {RoutingSettings} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/settings" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putRoutingSettings(body) {
		const endpointPath = "/api/v2/routing/settings";
		const endpointMethod = "PUT";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete an organization's routing settings
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/settings" endpoint.
	 */
	deleteRoutingSettings() {
		const endpointPath = "/api/v2/routing/settings";
		const endpointMethod = "DELETE";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get Routing Skill
	 * @async
	 * @param {string} skillId - Skill ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/skills/{skillId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingSkill(skillId) {
		const endpointPath = "/api/v2/routing/skills/{skillId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(skillId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "skillId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.skillId = skillId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete Routing Skill
	 * @async
	 * @param {string} skillId - Skill ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/skills/{skillId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteRoutingSkill(skillId) {
		const endpointPath = "/api/v2/routing/skills/{skillId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(skillId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "skillId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.skillId = skillId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the list of routing skills.
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.name] -  Filter for results that start with this value
	 * @param {string[]} [query.id] -  id
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/skills" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingSkills(query) {
		const endpointPath = "/api/v2/routing/skills";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
			if ("id" in query && this.#checkJSONSchemaType(query["id"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "id", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create Skill
	 * @async
	 * @param {RoutingSkill} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/skills" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRoutingSkills(body) {
		const endpointPath = "/api/v2/routing/skills";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get details about this utilization label
	 * @async
	 * @param {string} labelId - Utilization Label ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/utilization/labels/{labelId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingUtilizationLabel(labelId) {
		const endpointPath = "/api/v2/routing/utilization/labels/{labelId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(labelId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "labelId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.labelId = labelId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a utilization label
	 * @async
	 * @param {string} labelId - Utilization Label ID
	 * @param {UpdateUtilizationLabelRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/utilization/labels/{labelId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putRoutingUtilizationLabel(labelId, body) {
		const endpointPath = "/api/v2/routing/utilization/labels/{labelId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(labelId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "labelId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.labelId = labelId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a utilization label
	 * @async
	 * @param {string} labelId - Utilization Label ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.forceDelete] -  Remove all label usages (if found) without warning
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/utilization/labels/{labelId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	deleteRoutingUtilizationLabel(labelId, query) {
		const endpointPath = "/api/v2/routing/utilization/labels/{labelId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(labelId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "labelId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("forceDelete" in query && this.#checkJSONSchemaType(query["forceDelete"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "forceDelete", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.labelId = labelId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get list of agent ids associated with a utilization label
	 * @async
	 * @param {string} labelId - Utilization Label ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/utilization/labels/{labelId}/agents" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingUtilizationLabelAgents(labelId) {
		const endpointPath = "/api/v2/routing/utilization/labels/{labelId}/agents";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(labelId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "labelId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.labelId = labelId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get list of utilization labels
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.sortOrder] -  Sort order by name
	 * @param {string} [query.name] -  Utilization label's name (Wildcard is supported, e.g., 'label1*', '*label*'
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/utilization/labels" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingUtilizationLabels(query) {
		const endpointPath = "/api/v2/routing/utilization/labels";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("sortOrder" in query && this.#checkJSONSchemaType(query["sortOrder"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortOrder", "string");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a utilization label
	 * @async
	 * @param {CreateUtilizationLabelRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/utilization/labels" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRoutingUtilizationLabels(body) {
		const endpointPath = "/api/v2/routing/utilization/labels";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the organization-wide max utilization settings.
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/utilization" endpoint.
	 */
	getRoutingUtilization() {
		const endpointPath = "/api/v2/routing/utilization";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update the organization-wide max utilization settings.  Include only those media types requiring custom configuration.
	 * @async
	 * @param {UtilizationRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/utilization" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putRoutingUtilization(body) {
		const endpointPath = "/api/v2/routing/utilization";
		const endpointMethod = "PUT";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete the organization-wide max utilization settings and revert to the system default.
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/utilization" endpoint.
	 */
	deleteRoutingUtilization() {
		const endpointPath = "/api/v2/routing/utilization";
		const endpointMethod = "DELETE";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Retrieve a single benefit assessment.
	 * @async
	 * @param {string} assessmentId - Benefit Assessment ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/assessments/{assessmentId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingAssessment(assessmentId) {
		const endpointPath = "/api/v2/routing/assessments/{assessmentId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(assessmentId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "assessmentId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.assessmentId = assessmentId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete single benefit assessment.
	 * @async
	 * @param {string} assessmentId - Benefit Assessment ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/assessments/{assessmentId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteRoutingAssessment(assessmentId) {
		const endpointPath = "/api/v2/routing/assessments/{assessmentId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(assessmentId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "assessmentId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.assessmentId = assessmentId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Retrieve all benefit assessments.
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.before] -  The cursor that points to the start of the set of entities that has been returned.
	 * @param {string} [query.after] -  The cursor that points to the end of the set of entities that has been returned.
	 * @param {string} [query.limit] -  Number of entities to return. Maximum of 200. Deprecated in favour of pageSize
	 * @param {string} [query.pageSize] -  Number of entities to return. Maximum of 200.
	 * @param {string[]} [query.queueId] -  Queue ID(s) to filter assessments by.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/assessments" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingAssessments(query) {
		const endpointPath = "/api/v2/routing/assessments";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("before" in query && this.#checkJSONSchemaType(query["before"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "before", "string");
			}
			if ("after" in query && this.#checkJSONSchemaType(query["after"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "after", "string");
			}
			if ("limit" in query && this.#checkJSONSchemaType(query["limit"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "limit", "string");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "string");
			}
			if ("queueId" in query && this.#checkJSONSchemaType(query["queueId"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a benefit assessment.
	 * @async
	 * @param {CreateBenefitAssessmentRequest} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/assessments" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRoutingAssessments(body) {
		const endpointPath = "/api/v2/routing/assessments";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Retrieve a single benefit assessmentsjob.
	 * @async
	 * @param {string} jobId - Benefit Assessment Job ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/assessments/jobs/{jobId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingAssessmentsJob(jobId) {
		const endpointPath = "/api/v2/routing/assessments/jobs/{jobId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(jobId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "jobId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.jobId = jobId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Retrieve all benefit assessment jobs.
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string[]} [query.divisionId] -  Division ID(s) to filter assessment jobs by.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/assessments/jobs" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingAssessmentsJobs(query) {
		const endpointPath = "/api/v2/routing/assessments/jobs";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("divisionId" in query && this.#checkJSONSchemaType(query["divisionId"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "divisionId", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a benefit assessment job.
	 * @async
	 * @param {CreateBenefitAssessmentJobRequest} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/assessments/jobs" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRoutingAssessmentsJobs(body) {
		const endpointPath = "/api/v2/routing/assessments/jobs";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update attributes of an in-queue conversation
	 * @async
	 * @param {string} conversationId - Conversation ID
	 * @param {RoutingConversationAttributesRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/conversations/{conversationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchRoutingConversation(conversationId, body) {
		const endpointPath = "/api/v2/routing/conversations/{conversationId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get domain
	 * @async
	 * @param {string} domainId - domain ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.expand] -  Expand options. Valid values: settings
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/domains/{domainId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingEmailDomain(domainId, query) {
		const endpointPath = "/api/v2/routing/email/domains/{domainId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a domain
	 * @async
	 * @param {string} domainId - domain ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/domains/{domainId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteRoutingEmailDomain(domainId) {
		const endpointPath = "/api/v2/routing/email/domains/{domainId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update domain settings
	 * @async
	 * @param {string} domainId - domain ID
	 * @param {InboundDomainPatchRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/domains/{domainId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchRoutingEmailDomain(domainId, body) {
		const endpointPath = "/api/v2/routing/email/domains/{domainId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Validate domain settings
	 * @async
	 * @param {string} domainId - domain ID
	 * @param {InboundDomainPatchRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/domains/{domainId}/validate" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchRoutingEmailDomainValidate(domainId, body) {
		const endpointPath = "/api/v2/routing/email/domains/{domainId}/validate";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get domain dkim settings
	 * @async
	 * @param {string} domainId - domain ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/domains/{domainId}/dkim" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingEmailDomainDkim(domainId) {
		const endpointPath = "/api/v2/routing/email/domains/{domainId}/dkim";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Restart domain dkim
	 * @async
	 * @param {string} domainId - domain ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/domains/{domainId}/dkim" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	postRoutingEmailDomainDkim(domainId) {
		const endpointPath = "/api/v2/routing/email/domains/{domainId}/dkim";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get domain verification settings
	 * @async
	 * @param {string} domainId - domain ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/domains/{domainId}/verification" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingEmailDomainVerification(domainId) {
		const endpointPath = "/api/v2/routing/email/domains/{domainId}/verification";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Restart domain verification
	 * @async
	 * @param {string} domainId - domain ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/domains/{domainId}/verification" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	postRoutingEmailDomainVerification(domainId) {
		const endpointPath = "/api/v2/routing/email/domains/{domainId}/verification";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get domain mail from settings
	 * @async
	 * @param {string} domainId - domain ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/domains/{domainId}/mailfrom" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingEmailDomainMailfrom(domainId) {
		const endpointPath = "/api/v2/routing/email/domains/{domainId}/mailfrom";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Set domain mail from settings
	 * @async
	 * @param {string} domainId - domain ID
	 * @param {MailFromResult} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/domains/{domainId}/mailfrom" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRoutingEmailDomainMailfrom(domainId, body) {
		const endpointPath = "/api/v2/routing/email/domains/{domainId}/mailfrom";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Tests the custom SMTP server integration connection set on this ACD domain
	 * @async
	 * @param {string} domainId - domain ID
	 * @param {TestMessage} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/domains/{domainId}/testconnection" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRoutingEmailDomainTestconnection(domainId, body) {
		const endpointPath = "/api/v2/routing/email/domains/{domainId}/testconnection";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get domains
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {boolean} [query.excludeStatus] -  Exclude MX record data
	 * @param {string} [query.filter] -  Optional search filter that, if defined, use the **filter** syntax, eg: **mySearchedPattern**. Note that **** is considered no filter.
	 * @param {string} [query.expand] -  Expand options. Valid values: settings
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/domains" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingEmailDomains(query) {
		const endpointPath = "/api/v2/routing/email/domains";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("excludeStatus" in query && this.#checkJSONSchemaType(query["excludeStatus"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "excludeStatus", "boolean");
			}
			if ("filter" in query && this.#checkJSONSchemaType(query["filter"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "filter", "string");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a domain
	 * @async
	 * @param {InboundDomainCreateRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/domains" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRoutingEmailDomains(body) {
		const endpointPath = "/api/v2/routing/email/domains";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get email setup
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/setup" endpoint.
	 */
	getRoutingEmailSetup() {
		const endpointPath = "/api/v2/routing/email/setup";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get domain
	 * @async
	 * @param {string} domainId - domain ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.expand] -  Expand options. Valid values: settings
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/outbound/domains/{domainId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingEmailOutboundDomain(domainId, query) {
		const endpointPath = "/api/v2/routing/email/outbound/domains/{domainId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete an outbound domain
	 * @async
	 * @param {string} domainId - domain ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/outbound/domains/{domainId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteRoutingEmailOutboundDomain(domainId) {
		const endpointPath = "/api/v2/routing/email/outbound/domains/{domainId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get activation status (cname + dkim) of an outbound domain
	 * @async
	 * @param {string} domainId - domain ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/outbound/domains/{domainId}/activation" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingEmailOutboundDomainActivation(domainId) {
		const endpointPath = "/api/v2/routing/email/outbound/domains/{domainId}/activation";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Request an activation status (cname + dkim) update of an outbound domain
	 * @async
	 * @param {string} domainId - domain ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/outbound/domains/{domainId}/activation" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	putRoutingEmailOutboundDomainActivation(domainId) {
		const endpointPath = "/api/v2/routing/email/outbound/domains/{domainId}/activation";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get outbound domains
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.filter] -  Optional search filter that, if defined, use the **filter** syntax, eg: **mySearchedPattern**. Note that **** is considered no filter.
	 * @param {string} [query.expand] -  Expand options. Valid values: settings
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/outbound/domains" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingEmailOutboundDomains(query) {
		const endpointPath = "/api/v2/routing/email/outbound/domains";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("filter" in query && this.#checkJSONSchemaType(query["filter"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "filter", "string");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a domain
	 * @async
	 * @param {OutboundDomainCreateRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/outbound/domains" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRoutingEmailOutboundDomains(body) {
		const endpointPath = "/api/v2/routing/email/outbound/domains";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a route identity resolution setting.
	 * @async
	 * @param {string} domainName - email domain
	 * @param {string} routeId - route ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/domains/{domainName}/routes/{routeId}/identityresolution" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingEmailDomainRouteIdentityresolution(domainName, routeId) {
		const endpointPath = "/api/v2/routing/email/domains/{domainName}/routes/{routeId}/identityresolution";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainName, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainName", "string");
		}

		if (this.#checkJSONSchemaType(routeId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "routeId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainName = domainName;
		apiCallOptions.pathParameters.routeId = routeId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update identity resolution settings for a route.
	 * @async
	 * @param {string} domainName - email domain
	 * @param {string} routeId - route ID
	 * @param {RouteIdentityResolutionConfig} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/domains/{domainName}/routes/{routeId}/identityresolution" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putRoutingEmailDomainRouteIdentityresolution(domainName, routeId, body) {
		const endpointPath = "/api/v2/routing/email/domains/{domainName}/routes/{routeId}/identityresolution";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainName, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainName", "string");
		}

		if (this.#checkJSONSchemaType(routeId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "routeId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainName = domainName;
		apiCallOptions.pathParameters.routeId = routeId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a route
	 * @async
	 * @param {string} domainName - email domain
	 * @param {string} routeId - route ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string[]} [query.expand] -  Which fields, if any, to expand
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/domains/{domainName}/routes/{routeId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingEmailDomainRoute(domainName, routeId, query) {
		const endpointPath = "/api/v2/routing/email/domains/{domainName}/routes/{routeId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainName, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainName", "string");
		}

		if (this.#checkJSONSchemaType(routeId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "routeId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainName = domainName;
		apiCallOptions.pathParameters.routeId = routeId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a route
	 * @async
	 * @param {string} domainName - email domain
	 * @param {string} routeId - route ID
	 * @param {InboundRoute} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/domains/{domainName}/routes/{routeId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putRoutingEmailDomainRoute(domainName, routeId, body) {
		const endpointPath = "/api/v2/routing/email/domains/{domainName}/routes/{routeId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainName, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainName", "string");
		}

		if (this.#checkJSONSchemaType(routeId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "routeId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainName = domainName;
		apiCallOptions.pathParameters.routeId = routeId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a route
	 * @async
	 * @param {string} domainName - email domain
	 * @param {string} routeId - route ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/domains/{domainName}/routes/{routeId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteRoutingEmailDomainRoute(domainName, routeId) {
		const endpointPath = "/api/v2/routing/email/domains/{domainName}/routes/{routeId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainName, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainName", "string");
		}

		if (this.#checkJSONSchemaType(routeId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "routeId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainName = domainName;
		apiCallOptions.pathParameters.routeId = routeId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get routes
	 * @async
	 * @param {string} domainName - email domain
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.pattern] -  Filter routes by the route's pattern property
	 * @param {string[]} [query.expand] -  Which fields, if any, to expand
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/domains/{domainName}/routes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingEmailDomainRoutes(domainName, query) {
		const endpointPath = "/api/v2/routing/email/domains/{domainName}/routes";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainName, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainName", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("pattern" in query && this.#checkJSONSchemaType(query["pattern"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pattern", "string");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainName = domainName;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a route
	 * @async
	 * @param {string} domainName - email domain
	 * @param {InboundRoute} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/domains/{domainName}/routes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRoutingEmailDomainRoutes(domainName, body) {
		const endpointPath = "/api/v2/routing/email/domains/{domainName}/routes";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainName, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainName", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainName = domainName;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a simulated domain
	 * @async
	 * @param {OutboundDomainCreateRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/email/outbound/domains/simulated" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRoutingEmailOutboundDomainsSimulated(body) {
		const endpointPath = "/api/v2/routing/email/outbound/domains/simulated";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a recipient
	 * @async
	 * @param {string} recipientId - Recipient ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/message/recipients/{recipientId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingMessageRecipient(recipientId) {
		const endpointPath = "/api/v2/routing/message/recipients/{recipientId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(recipientId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "recipientId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.recipientId = recipientId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a recipient
	 * @async
	 * @param {string} recipientId - Recipient ID
	 * @param {RecipientRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/message/recipients/{recipientId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putRoutingMessageRecipient(recipientId, body) {
		const endpointPath = "/api/v2/routing/message/recipients/{recipientId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(recipientId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "recipientId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.recipientId = recipientId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get recipients
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.messengerType] -  Messenger Type
	 * @param {string} [query.name] -  Recipient Name
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/message/recipients" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingMessageRecipients(query) {
		const endpointPath = "/api/v2/routing/message/recipients";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("messengerType" in query && this.#checkJSONSchemaType(query["messengerType"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "messengerType", "string");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get an Address by Id for SMS
	 * @async
	 * @param {string} addressId - Address ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/sms/addresses/{addressId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingSmsAddress(addressId) {
		const endpointPath = "/api/v2/routing/sms/addresses/{addressId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(addressId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "addressId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.addressId = addressId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete an Address by Id for SMS
	 * @async
	 * @param {string} addressId - Address ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/sms/addresses/{addressId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteRoutingSmsAddress(addressId) {
		const endpointPath = "/api/v2/routing/sms/addresses/{addressId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(addressId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "addressId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.addressId = addressId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a list of Addresses for SMS
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/sms/addresses" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingSmsAddresses(query) {
		const endpointPath = "/api/v2/routing/sms/addresses";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Provision an Address for SMS
	 * @async
	 * @param {SmsAddressProvision} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/sms/addresses" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRoutingSmsAddresses(body) {
		const endpointPath = "/api/v2/routing/sms/addresses";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a list of available phone numbers for SMS provisioning.
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} query.countryCode -  The ISO 3166-1 alpha-2 country code of the county for which available phone numbers should be returned
	 * @param {string} [query.region] -  Region/province/state that can be used to restrict the numbers returned
	 * @param {string} [query.city] -  City that can be used to restrict the numbers returned
	 * @param {string} [query.areaCode] -  Area code that can be used to restrict the numbers returned
	 * @param {string} query.phoneNumberType -  Type of available phone numbers searched
	 * @param {string} [query.pattern] -  A pattern to match phone numbers. Valid characters are '*' and [0-9a-zA-Z]. The '*' character will match any single digit.
	 * @param {string} [query.addressRequirement] -  This indicates whether the phone number requires to have an Address registered.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/sms/availablephonenumbers" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING} If a required query string parameter is missing.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingSmsAvailablephonenumbers(query) {
		const endpointPath = "/api/v2/routing/sms/availablephonenumbers";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object" || query === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, true);
		}

		if ("countryCode" in query === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING(endpointPath, endpointMethod, "countryCode");
		}

		if (this.#checkJSONSchemaType(query["countryCode"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "countryCode", "string");
		}

		if ("region" in query && this.#checkJSONSchemaType(query["region"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "region", "string");
		}

		if ("city" in query && this.#checkJSONSchemaType(query["city"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "city", "string");
		}

		if ("areaCode" in query && this.#checkJSONSchemaType(query["areaCode"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "areaCode", "string");
		}

		if ("phoneNumberType" in query === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING(endpointPath, endpointMethod, "phoneNumberType");
		}

		if (this.#checkJSONSchemaType(query["phoneNumberType"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "phoneNumberType", "string");
		}

		if ("pattern" in query && this.#checkJSONSchemaType(query["pattern"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pattern", "string");
		}

		if ("addressRequirement" in query && this.#checkJSONSchemaType(query["addressRequirement"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "addressRequirement", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a SMS identity resolution settings.
	 * @async
	 * @param {string} addressId - Address ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/sms/identityresolution/phonenumbers/{addressId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingSmsIdentityresolutionPhonenumber(addressId) {
		const endpointPath = "/api/v2/routing/sms/identityresolution/phonenumbers/{addressId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(addressId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "addressId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.addressId = addressId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update an SMS identity resolution settings.
	 * @async
	 * @param {string} addressId - Address ID
	 * @param {SmsIdentityResolutionConfig} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/sms/identityresolution/phonenumbers/{addressId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putRoutingSmsIdentityresolutionPhonenumber(addressId, body) {
		const endpointPath = "/api/v2/routing/sms/identityresolution/phonenumbers/{addressId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(addressId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "addressId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.addressId = addressId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Imports a phone number for SMS
	 * @async
	 * @param {SmsPhoneNumberImport} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/sms/phonenumbers/import" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRoutingSmsPhonenumbersImport(body) {
		const endpointPath = "/api/v2/routing/sms/phonenumbers/import";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a phone number provisioned for SMS.
	 * @async
	 * @param {string} phoneNumberId - phone number
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.expand] -  Expand response with additional information
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/sms/phonenumbers/{phoneNumberId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingSmsPhonenumber(phoneNumberId, query) {
		const endpointPath = "/api/v2/routing/sms/phonenumbers/{phoneNumberId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(phoneNumberId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "phoneNumberId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.phoneNumberId = phoneNumberId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a phone number provisioned for SMS.
	 * @async
	 * @param {string} phoneNumberId - phone number
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/sms/phonenumbers/{phoneNumberId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteRoutingSmsPhonenumber(phoneNumberId) {
		const endpointPath = "/api/v2/routing/sms/phonenumbers/{phoneNumberId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(phoneNumberId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "phoneNumberId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.phoneNumberId = phoneNumberId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a phone number provisioned for SMS.
	 * @async
	 * @param {string} phoneNumberId - phone number
	 * @param {SmsPhoneNumberPatchRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/sms/phonenumbers/{phoneNumberId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchRoutingSmsPhonenumber(phoneNumberId, body) {
		const endpointPath = "/api/v2/routing/sms/phonenumbers/{phoneNumberId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(phoneNumberId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "phoneNumberId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.phoneNumberId = phoneNumberId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a list of provisioned phone numbers.
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.phoneNumber] -  Filter on phone number address. Allowable characters are the digits '0-9' and the wild card character '\*'. If just digits are present, a contains search is done on the address pattern. For example, '317' could be matched anywhere in the address. An '\*' will match multiple digits. For example, to match a specific area code within the US a pattern like '1317*' could be used.
	 * @param {string[]} [query.phoneNumberType] -  Filter on phone number type
	 * @param {string[]} [query.phoneNumberStatus] -  Filter on phone number status
	 * @param {string[]} [query.countryCode] -  Filter on country code
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.sortBy] -  Optional field to sort results
	 * @param {string} [query.sortOrder] -  Sort order
	 * @param {string} [query.language] -  A language tag (which is sometimes referred to as a "locale identifier") to use to localize country field and sort operations
	 * @param {string} [query.integration.id] -  Filter on the Genesys Cloud integration id to which the phone number belongs to
	 * @param {string} [query.supportedContent.id] -  Filter based on the supported content ID
	 * @param {string[]} [query.expand] -  Which fields, if any, to expand
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/sms/phonenumbers" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingSmsPhonenumbers(query) {
		const endpointPath = "/api/v2/routing/sms/phonenumbers";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("phoneNumber" in query && this.#checkJSONSchemaType(query["phoneNumber"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "phoneNumber", "string");
			}
			if ("phoneNumberType" in query && this.#checkJSONSchemaType(query["phoneNumberType"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "phoneNumberType", "array");
			}
			if ("phoneNumberStatus" in query && this.#checkJSONSchemaType(query["phoneNumberStatus"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "phoneNumberStatus", "array");
			}
			if ("countryCode" in query && this.#checkJSONSchemaType(query["countryCode"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "countryCode", "array");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("sortBy" in query && this.#checkJSONSchemaType(query["sortBy"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortBy", "string");
			}
			if ("sortOrder" in query && this.#checkJSONSchemaType(query["sortOrder"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortOrder", "string");
			}
			if ("language" in query && this.#checkJSONSchemaType(query["language"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "language", "string");
			}
			if ("integration.id" in query && this.#checkJSONSchemaType(query["integration.id"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "integration.id", "string");
			}
			if ("supportedContent.id" in query && this.#checkJSONSchemaType(query["supportedContent.id"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "supportedContent.id", "string");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Provision a phone number for SMS
	 * @async
	 * @param {SmsPhoneNumberProvision} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/sms/phonenumbers" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRoutingSmsPhonenumbers(body) {
		const endpointPath = "/api/v2/routing/sms/phonenumbers";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Retrieve a single predictor.
	 * @async
	 * @param {string} predictorId - Predictor ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/predictors/{predictorId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingPredictor(predictorId) {
		const endpointPath = "/api/v2/routing/predictors/{predictorId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(predictorId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "predictorId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.predictorId = predictorId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete single predictor.
	 * @async
	 * @param {string} predictorId - Predictor ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/predictors/{predictorId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteRoutingPredictor(predictorId) {
		const endpointPath = "/api/v2/routing/predictors/{predictorId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(predictorId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "predictorId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.predictorId = predictorId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update single predictor.
	 * @async
	 * @param {string} predictorId - Predictor ID
	 * @param {PatchPredictorRequest} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/predictors/{predictorId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchRoutingPredictor(predictorId, body) {
		const endpointPath = "/api/v2/routing/predictors/{predictorId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(predictorId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "predictorId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.predictorId = predictorId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Retrieve all predictors.
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.before] -  The cursor that points to the start of the set of entities that has been returned.
	 * @param {string} [query.after] -  The cursor that points to the end of the set of entities that has been returned.
	 * @param {string} [query.limit] -  Number of entities to return. Maximum of 200. Deprecated in favour of pageSize
	 * @param {string} [query.pageSize] -  Number of entities to return. Maximum of 200.
	 * @param {string[]} [query.queueId] -  Comma-separated list of queue Ids to filter by.
	 * @param {string} [query.kpiId] -  Standard or custom KPI id used to filter predictors.
	 * @param {string} [query.state] -  The state used to filter predictors.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/predictors" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingPredictors(query) {
		const endpointPath = "/api/v2/routing/predictors";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("before" in query && this.#checkJSONSchemaType(query["before"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "before", "string");
			}
			if ("after" in query && this.#checkJSONSchemaType(query["after"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "after", "string");
			}
			if ("limit" in query && this.#checkJSONSchemaType(query["limit"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "limit", "string");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "string");
			}
			if ("queueId" in query && this.#checkJSONSchemaType(query["queueId"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "array");
			}
			if ("kpiId" in query && this.#checkJSONSchemaType(query["kpiId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "kpiId", "string");
			}
			if ("state" in query && this.#checkJSONSchemaType(query["state"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "state", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a predictor.
	 * @async
	 * @param {CreatePredictorRequest} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/predictors" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRoutingPredictors(body) {
		const endpointPath = "/api/v2/routing/predictors";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a list of Key Performance Indicators
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.kpiGroup] -  The Group of Key Performance Indicators to return
	 * @param {string[]} [query.expand] -  Parameter to request additional data to return in KPI payload
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/predictors/keyperformanceindicators" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingPredictorsKeyperformanceindicators(query) {
		const endpointPath = "/api/v2/routing/predictors/keyperformanceindicators";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("kpiGroup" in query && this.#checkJSONSchemaType(query["kpiGroup"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "kpiGroup", "string");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Retrieve Predictor Model Features.
	 * @async
	 * @param {string} predictorId - Predictor ID
	 * @param {string} modelId - Model ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/predictors/{predictorId}/models/{modelId}/features" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingPredictorModelFeatures(predictorId, modelId) {
		const endpointPath = "/api/v2/routing/predictors/{predictorId}/models/{modelId}/features";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(predictorId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "predictorId", "string");
		}

		if (this.#checkJSONSchemaType(modelId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "modelId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.predictorId = predictorId;
		apiCallOptions.pathParameters.modelId = modelId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Retrieve Predictor Models and Top Features.
	 * @async
	 * @param {string} predictorId - Predictor ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/predictors/{predictorId}/models" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingPredictorModels(predictorId) {
		const endpointPath = "/api/v2/routing/predictors/{predictorId}/models";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(predictorId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "predictorId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.predictorId = predictorId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a queue member.
	 * @async
	 * @param {string} queueId - Queue ID
	 * @param {string} memberId - Member ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}/members/{memberId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteRoutingQueueMember(queueId, memberId) {
		const endpointPath = "/api/v2/routing/queues/{queueId}/members/{memberId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		if (this.#checkJSONSchemaType(memberId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "memberId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;
		apiCallOptions.pathParameters.memberId = memberId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update the ring number OR joined status for a queue member.
	 * @async
	 * @param {string} queueId - Queue ID
	 * @param {string} memberId - Member ID
	 * @param {QueueMember} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}/members/{memberId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchRoutingQueueMember(queueId, memberId, body) {
		const endpointPath = "/api/v2/routing/queues/{queueId}/members/{memberId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		if (this.#checkJSONSchemaType(memberId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "memberId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;
		apiCallOptions.pathParameters.memberId = memberId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the members of this queue.
	 * @async
	 * @param {string} queueId - Queue ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageNumber] -  
	 * @param {number} [query.pageSize] -  Max value is 100
	 * @param {string} [query.sortOrder] -  Note: results are sorted by name.
	 * @param {string[]} [query.expand] -  Which fields, if any, to expand.
	 * @param {string} [query.name] -  Filter by queue member name (contains-style search)
	 * @param {string[]} [query.profileSkills] -  Filter by profile skill (contains-style search)
	 * @param {string[]} [query.skills] -  Filter by skill (contains-style search)
	 * @param {string[]} [query.languages] -  Filter by language (contains-style search)
	 * @param {string[]} [query.routingStatus] -  Filter by routing status
	 * @param {string[]} [query.presence] -  Filter by presence
	 * @param {string} [query.memberBy] -  Filter by member type
	 * @param {boolean} [query.joined] -  Filter by joined status
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}/members" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingQueueMembers(queueId, query) {
		const endpointPath = "/api/v2/routing/queues/{queueId}/members";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("sortOrder" in query && this.#checkJSONSchemaType(query["sortOrder"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortOrder", "string");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "array");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
			if ("profileSkills" in query && this.#checkJSONSchemaType(query["profileSkills"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "profileSkills", "array");
			}
			if ("skills" in query && this.#checkJSONSchemaType(query["skills"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "skills", "array");
			}
			if ("languages" in query && this.#checkJSONSchemaType(query["languages"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "languages", "array");
			}
			if ("routingStatus" in query && this.#checkJSONSchemaType(query["routingStatus"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "routingStatus", "array");
			}
			if ("presence" in query && this.#checkJSONSchemaType(query["presence"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "presence", "array");
			}
			if ("memberBy" in query && this.#checkJSONSchemaType(query["memberBy"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "memberBy", "string");
			}
			if ("joined" in query && this.#checkJSONSchemaType(query["joined"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "joined", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Bulk add or delete up to 100 queue members
	 * @async
	 * @param {string} queueId - Queue ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.delete] -  True to delete queue members
	 * @param {WritableEntity[]} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}/members" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRoutingQueueMembers(queueId, query, body) {
		const endpointPath = "/api/v2/routing/queues/{queueId}/members";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("delete" in query && this.#checkJSONSchemaType(query["delete"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "delete", "boolean");
			}
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "array") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "array", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Join or unjoin a set of up to 100 users for a queue
	 * @async
	 * @param {string} queueId - Queue ID
	 * @param {QueueMember[]} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}/members" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchRoutingQueueMembers(queueId, body) {
		const endpointPath = "/api/v2/routing/queues/{queueId}/members";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "array") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "array", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * DEPRECATED: use DELETE /routing/queues/{queueId}/members/{memberId}.  Delete queue member.
	 * @async
	 * @param {string} queueId - Queue ID
	 * @param {string} memberId - Member ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}/users/{memberId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @deprecated
	 */
	deleteRoutingQueueUser(queueId, memberId) {
		const endpointPath = "/api/v2/routing/queues/{queueId}/users/{memberId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		if (this.#checkJSONSchemaType(memberId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "memberId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;
		apiCallOptions.pathParameters.memberId = memberId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * DEPRECATED: use PATCH /routing/queues/{queueId}/members/{memberId}.  Update the ring number OR joined status for a User in a Queue.
	 * @async
	 * @param {string} queueId - Queue ID
	 * @param {string} memberId - Member ID
	 * @param {QueueMember} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}/users/{memberId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	patchRoutingQueueUser(queueId, memberId, body) {
		const endpointPath = "/api/v2/routing/queues/{queueId}/users/{memberId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		if (this.#checkJSONSchemaType(memberId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "memberId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;
		apiCallOptions.pathParameters.memberId = memberId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * DEPRECATED: use GET /routing/queues/{queueId}/members.  Get the members of this queue.
	 * @async
	 * @param {string} queueId - Queue ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageNumber] -  
	 * @param {number} [query.pageSize] -  Max value is 100
	 * @param {string} [query.sortOrder] -  Note: results are sorted by name.
	 * @param {string[]} [query.expand] -  Which fields, if any, to expand.
	 * @param {boolean} [query.joined] -  Filter by joined status
	 * @param {string} [query.name] -  Filter by queue member name
	 * @param {string[]} [query.profileSkills] -  Filter by profile skill
	 * @param {string[]} [query.skills] -  Filter by skill
	 * @param {string[]} [query.languages] -  Filter by language
	 * @param {string[]} [query.routingStatus] -  Filter by routing status
	 * @param {string[]} [query.presence] -  Filter by presence
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}/users" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @deprecated
	 */
	getRoutingQueueUsers(queueId, query) {
		const endpointPath = "/api/v2/routing/queues/{queueId}/users";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("sortOrder" in query && this.#checkJSONSchemaType(query["sortOrder"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortOrder", "string");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "array");
			}
			if ("joined" in query && this.#checkJSONSchemaType(query["joined"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "joined", "boolean");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
			if ("profileSkills" in query && this.#checkJSONSchemaType(query["profileSkills"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "profileSkills", "array");
			}
			if ("skills" in query && this.#checkJSONSchemaType(query["skills"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "skills", "array");
			}
			if ("languages" in query && this.#checkJSONSchemaType(query["languages"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "languages", "array");
			}
			if ("routingStatus" in query && this.#checkJSONSchemaType(query["routingStatus"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "routingStatus", "array");
			}
			if ("presence" in query && this.#checkJSONSchemaType(query["presence"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "presence", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * DEPRECATED: use POST /routing/queues/{queueId}/members.  Bulk add or delete up to 100 queue members.
	 * @async
	 * @param {string} queueId - Queue ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.delete] -  True to delete queue members
	 * @param {WritableEntity[]} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}/users" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	postRoutingQueueUsers(queueId, query, body) {
		const endpointPath = "/api/v2/routing/queues/{queueId}/users";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("delete" in query && this.#checkJSONSchemaType(query["delete"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "delete", "boolean");
			}
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "array") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "array", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * DEPRECATED: use PATCH /routing/queues/{queueId}/members.  Join or unjoin a set of users for a queue.
	 * @async
	 * @param {string} queueId - Queue ID
	 * @param {QueueMember[]} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}/users" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	patchRoutingQueueUsers(queueId, body) {
		const endpointPath = "/api/v2/routing/queues/{queueId}/users";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "array") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "array", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get an assistant associated with a queue.
	 * @async
	 * @param {string} queueId - Queue ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string[]} [query.expand] -  Which fields, if any, to expand.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}/assistant" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingQueueAssistant(queueId, query) {
		const endpointPath = "/api/v2/routing/queues/{queueId}/assistant";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a Comparison Period.
	 * @async
	 * @param {string} queueId - Queue id
	 * @param {string} comparisonPeriodId - ComparisonPeriod id
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}/comparisonperiods/{comparisonPeriodId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingQueueComparisonperiod(queueId, comparisonPeriodId) {
		const endpointPath = "/api/v2/routing/queues/{queueId}/comparisonperiods/{comparisonPeriodId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		if (this.#checkJSONSchemaType(comparisonPeriodId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "comparisonPeriodId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;
		apiCallOptions.pathParameters.comparisonPeriodId = comparisonPeriodId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get list of comparison periods
	 * @async
	 * @param {string} queueId - Queue id
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/queues/{queueId}/comparisonperiods" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingQueueComparisonperiods(queueId) {
		const endpointPath = "/api/v2/routing/queues/{queueId}/comparisonperiods";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get list of member divisions for this skill group.
	 * @async
	 * @param {string} skillGroupId - Skill Group ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.expand] -  Expand the name on each user
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/skillgroups/{skillGroupId}/members/divisions" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingSkillgroupMembersDivisions(skillGroupId, query) {
		const endpointPath = "/api/v2/routing/skillgroups/{skillGroupId}/members/divisions";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(skillGroupId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "skillGroupId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.skillGroupId = skillGroupId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Add or remove member divisions for this skill group.
	 * @async
	 * @param {string} skillGroupId - Skill Group ID
	 * @param {SkillGroupMemberDivisions} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/skillgroups/{skillGroupId}/members/divisions" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRoutingSkillgroupMembersDivisions(skillGroupId, body) {
		const endpointPath = "/api/v2/routing/skillgroups/{skillGroupId}/members/divisions";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(skillGroupId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "skillGroupId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.skillGroupId = skillGroupId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get skill group
	 * @async
	 * @param {string} skillGroupId - Skill Group ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/skillgroups/{skillGroupId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingSkillgroup(skillGroupId) {
		const endpointPath = "/api/v2/routing/skillgroups/{skillGroupId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(skillGroupId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "skillGroupId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.skillGroupId = skillGroupId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Remove skill group definition
	 * @async
	 * @param {string} skillGroupId - Skill Group ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/skillgroups/{skillGroupId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteRoutingSkillgroup(skillGroupId) {
		const endpointPath = "/api/v2/routing/skillgroups/{skillGroupId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(skillGroupId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "skillGroupId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.skillGroupId = skillGroupId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update skill group definition
	 * @async
	 * @param {string} skillGroupId - Skill Group ID
	 * @param {SkillGroup} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/skillgroups/{skillGroupId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchRoutingSkillgroup(skillGroupId, body) {
		const endpointPath = "/api/v2/routing/skillgroups/{skillGroupId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(skillGroupId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "skillGroupId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.skillGroupId = skillGroupId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get skill group members
	 * @async
	 * @param {string} skillGroupId - Skill Group ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {string} [query.after] -  The cursor that points to the next item
	 * @param {string} [query.before] -  The cursor that points to the previous item
	 * @param {string} [query.expand] -  Expand the name on each user
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/skillgroups/{skillGroupId}/members" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingSkillgroupMembers(skillGroupId, query) {
		const endpointPath = "/api/v2/routing/skillgroups/{skillGroupId}/members";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(skillGroupId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "skillGroupId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("after" in query && this.#checkJSONSchemaType(query["after"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "after", "string");
			}
			if ("before" in query && this.#checkJSONSchemaType(query["before"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "before", "string");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.skillGroupId = skillGroupId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get skill group listing
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {string} [query.name] -  Return only skill group names whose names start with this value (case-insensitive matching)
	 * @param {string} [query.after] -  The cursor that points to the next item
	 * @param {string} [query.before] -  The cursor that points to the previous item
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/skillgroups" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingSkillgroups(query) {
		const endpointPath = "/api/v2/routing/skillgroups";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
			if ("after" in query && this.#checkJSONSchemaType(query["after"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "after", "string");
			}
			if ("before" in query && this.#checkJSONSchemaType(query["before"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "before", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a skill group
	 * @async
	 * @param {SkillGroupWithMemberDivisions} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/skillgroups" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRoutingSkillgroups(body) {
		const endpointPath = "/api/v2/routing/skillgroups";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the user's Direct Routing Backup settings.
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/directroutingbackup/settings/me" endpoint.
	 */
	getRoutingDirectroutingbackupSettingsMe() {
		const endpointPath = "/api/v2/routing/directroutingbackup/settings/me";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update the user's Direct Routing Backup settings.
	 * @async
	 * @param {AgentDirectRoutingBackupSettings} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/directroutingbackup/settings/me" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putRoutingDirectroutingbackupSettingsMe(body) {
		const endpointPath = "/api/v2/routing/directroutingbackup/settings/me";
		const endpointMethod = "PUT";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete the user's Direct Routing Backup settings and revert to the Direct Routing Queue default.
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/directroutingbackup/settings/me" endpoint.
	 */
	deleteRoutingDirectroutingbackupSettingsMe() {
		const endpointPath = "/api/v2/routing/directroutingbackup/settings/me";
		const endpointMethod = "DELETE";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the user's Direct Routing Backup settings.
	 * @async
	 * @param {string} userId - User ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/users/{userId}/directroutingbackup/settings" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingUserDirectroutingbackupSettings(userId) {
		const endpointPath = "/api/v2/routing/users/{userId}/directroutingbackup/settings";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update the user's Direct Routing Backup settings.
	 * @async
	 * @param {string} userId - User ID
	 * @param {AgentDirectRoutingBackupSettings} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/users/{userId}/directroutingbackup/settings" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putRoutingUserDirectroutingbackupSettings(userId, body) {
		const endpointPath = "/api/v2/routing/users/{userId}/directroutingbackup/settings";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete the user's Direct Routing Backup settings and revert to the Direct Routing Queue default.
	 * @async
	 * @param {string} userId - User ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/users/{userId}/directroutingbackup/settings" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteRoutingUserDirectroutingbackupSettings(userId) {
		const endpointPath = "/api/v2/routing/users/{userId}/directroutingbackup/settings";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the user's max utilization settings.  If not configured, the organization-wide default is returned.
	 * @async
	 * @param {string} userId - User ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/users/{userId}/utilization" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingUserUtilization(userId) {
		const endpointPath = "/api/v2/routing/users/{userId}/utilization";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update the user's max utilization settings.  Include only those media types requiring custom configuration.
	 * @async
	 * @param {string} userId - User ID
	 * @param {UtilizationRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/users/{userId}/utilization" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putRoutingUserUtilization(userId, body) {
		const endpointPath = "/api/v2/routing/users/{userId}/utilization";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete the user's max utilization settings and revert to the organization-wide default.
	 * @async
	 * @param {string} userId - User ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/users/{userId}/utilization" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteRoutingUserUtilization(userId) {
		const endpointPath = "/api/v2/routing/users/{userId}/utilization";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a simplified wrap-up code.
	 * @async
	 * @param {string} codeId - Wrapup Code ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/wrapupcodes/divisionviews/{codeId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingWrapupcodesDivisionview(codeId) {
		const endpointPath = "/api/v2/routing/wrapupcodes/divisionviews/{codeId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(codeId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "codeId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.codeId = codeId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a paged listing of simplified wrapup code objects, filterable by name, wrapup code ID(s), or division ID(s).
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.name] -  Name (trailing asterisks allowed)
	 * @param {string[]} [query.id] -  Wrapup code ID(s)
	 * @param {string[]} [query.divisionId] -  Division ID(s)
	 * @param {string} [query.includeState] -  Wrapup code state(s) to include
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/wrapupcodes/divisionviews" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingWrapupcodesDivisionviews(query) {
		const endpointPath = "/api/v2/routing/wrapupcodes/divisionviews";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
			if ("id" in query && this.#checkJSONSchemaType(query["id"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "id", "array");
			}
			if ("divisionId" in query && this.#checkJSONSchemaType(query["divisionId"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "divisionId", "array");
			}
			if ("includeState" in query && this.#checkJSONSchemaType(query["includeState"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "includeState", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get details about this wrap-up code.
	 * @async
	 * @param {string} codeId - Wrapup Code ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/wrapupcodes/{codeId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRoutingWrapupcode(codeId) {
		const endpointPath = "/api/v2/routing/wrapupcodes/{codeId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(codeId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "codeId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.codeId = codeId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update wrap-up code
	 * @async
	 * @param {string} codeId - Wrapup Code ID
	 * @param {WrapupCodeRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/wrapupcodes/{codeId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putRoutingWrapupcode(codeId, body) {
		const endpointPath = "/api/v2/routing/wrapupcodes/{codeId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(codeId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "codeId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.codeId = codeId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete wrap-up code
	 * @async
	 * @param {string} codeId - Wrapup Code ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/wrapupcodes/{codeId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteRoutingWrapupcode(codeId) {
		const endpointPath = "/api/v2/routing/wrapupcodes/{codeId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(codeId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "codeId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.codeId = codeId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get list of wrapup codes.
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.sortBy] -  Sort by
	 * @param {string} [query.sortOrder] -  Sort order
	 * @param {string} [query.name] -  Wrapup code's name ('Sort by' param is ignored unless this field is provided)
	 * @param {string[]} [query.id] -  Filter by wrapup code ID(s)
	 * @param {string[]} [query.divisionId] -  Filter by division ID(s)
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/wrapupcodes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRoutingWrapupcodes(query) {
		const endpointPath = "/api/v2/routing/wrapupcodes";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("sortBy" in query && this.#checkJSONSchemaType(query["sortBy"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortBy", "string");
			}
			if ("sortOrder" in query && this.#checkJSONSchemaType(query["sortOrder"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortOrder", "string");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
			if ("id" in query && this.#checkJSONSchemaType(query["id"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "id", "array");
			}
			if ("divisionId" in query && this.#checkJSONSchemaType(query["divisionId"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "divisionId", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a wrap-up code
	 * @async
	 * @param {WrapupCodeRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/routing/wrapupcodes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRoutingWrapupcodes(body) {
		const endpointPath = "/api/v2/routing/wrapupcodes";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Join or unjoin a queue for a user
	 * @async
	 * @param {string} queueId - Queue ID
	 * @param {string} userId - User ID
	 * @param {UserQueue} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/users/{userId}/queues/{queueId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchUserQueue(queueId, userId, body) {
		const endpointPath = "/api/v2/users/{userId}/queues/{queueId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(queueId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
		}

		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.queueId = queueId;
		apiCallOptions.pathParameters.userId = userId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get queues for user
	 * @async
	 * @param {string} userId - User ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {boolean} [query.joined] -  Is joined to the queue
	 * @param {string[]} [query.divisionId] -  Division ID(s)
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/users/{userId}/queues" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getUserQueues(userId, query) {
		const endpointPath = "/api/v2/users/{userId}/queues";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("joined" in query && this.#checkJSONSchemaType(query["joined"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "joined", "boolean");
			}
			if ("divisionId" in query && this.#checkJSONSchemaType(query["divisionId"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "divisionId", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Join or unjoin a set of queues for a user
	 * @async
	 * @param {string} userId - User ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string[]} [query.divisionId] -  Division ID(s)
	 * @param {UserQueue[]} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/users/{userId}/queues" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchUserQueues(userId, query, body) {
		const endpointPath = "/api/v2/users/{userId}/queues";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("divisionId" in query && this.#checkJSONSchemaType(query["divisionId"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "divisionId", "array");
			}
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "array") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "array", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Remove a routing language from a user
	 * @async
	 * @param {string} userId - User ID
	 * @param {string} languageId - languageId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/users/{userId}/routinglanguages/{languageId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteUserRoutinglanguage(userId, languageId) {
		const endpointPath = "/api/v2/users/{userId}/routinglanguages/{languageId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		if (this.#checkJSONSchemaType(languageId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "languageId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;
		apiCallOptions.pathParameters.languageId = languageId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update an assigned routing language's proficiency
	 * @async
	 * @param {string} userId - User ID
	 * @param {string} languageId - languageId
	 * @param {UserRoutingLanguage} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/users/{userId}/routinglanguages/{languageId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchUserRoutinglanguage(userId, languageId, body) {
		const endpointPath = "/api/v2/users/{userId}/routinglanguages/{languageId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		if (this.#checkJSONSchemaType(languageId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "languageId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;
		apiCallOptions.pathParameters.languageId = languageId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * List routing languages assigned to a user
	 * @async
	 * @param {string} userId - User ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.sortOrder] -  Ascending or descending sort order
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/users/{userId}/routinglanguages" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getUserRoutinglanguages(userId, query) {
		const endpointPath = "/api/v2/users/{userId}/routinglanguages";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("sortOrder" in query && this.#checkJSONSchemaType(query["sortOrder"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortOrder", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Assign a routing language to a user
	 * @async
	 * @param {string} userId - User ID
	 * @param {UserRoutingLanguagePost} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/users/{userId}/routinglanguages" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postUserRoutinglanguages(userId, body) {
		const endpointPath = "/api/v2/users/{userId}/routinglanguages";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Assign multiple routing languages to a user. Max 50 routing languages in request body
	 * @async
	 * @param {string} userId - User ID
	 * @param {UserRoutingLanguagePost[]} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/users/{userId}/routinglanguages/bulk" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchUserRoutinglanguagesBulk(userId, body) {
		const endpointPath = "/api/v2/users/{userId}/routinglanguages/bulk";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "array") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "array", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update an assigned routing skill's proficiency
	 * @async
	 * @param {string} userId - User ID
	 * @param {string} skillId - skillId
	 * @param {UserRoutingSkill} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/users/{userId}/routingskills/{skillId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putUserRoutingskill(userId, skillId, body) {
		const endpointPath = "/api/v2/users/{userId}/routingskills/{skillId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		if (this.#checkJSONSchemaType(skillId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "skillId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;
		apiCallOptions.pathParameters.skillId = skillId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Remove a routing skill from a user
	 * @async
	 * @param {string} userId - User ID
	 * @param {string} skillId - skillId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/users/{userId}/routingskills/{skillId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteUserRoutingskill(userId, skillId) {
		const endpointPath = "/api/v2/users/{userId}/routingskills/{skillId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		if (this.#checkJSONSchemaType(skillId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "skillId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;
		apiCallOptions.pathParameters.skillId = skillId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * List routing skills assigned to a user
	 * @async
	 * @param {string} userId - User ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.sortOrder] -  Ascending or descending sort order
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/users/{userId}/routingskills" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getUserRoutingskills(userId, query) {
		const endpointPath = "/api/v2/users/{userId}/routingskills";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("sortOrder" in query && this.#checkJSONSchemaType(query["sortOrder"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortOrder", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Assign a routing skill to a user
	 * @async
	 * @param {string} userId - User ID
	 * @param {UserRoutingSkillPost} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/users/{userId}/routingskills" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postUserRoutingskills(userId, body) {
		const endpointPath = "/api/v2/users/{userId}/routingskills";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Assign multiple routing skills to a user, replacing any current assignments
	 * @async
	 * @param {string} userId - User ID
	 * @param {UserRoutingSkillPost[]} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/users/{userId}/routingskills/bulk" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putUserRoutingskillsBulk(userId, body) {
		const endpointPath = "/api/v2/users/{userId}/routingskills/bulk";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "array") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "array", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Assign multiple routing skills to a user
	 * @async
	 * @param {string} userId - User ID
	 * @param {UserRoutingSkillPost[]} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/users/{userId}/routingskills/bulk" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchUserRoutingskillsBulk(userId, body) {
		const endpointPath = "/api/v2/users/{userId}/routingskills/bulk";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "array") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "array", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get skill groups for a user
	 * @async
	 * @param {string} userId - User ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {string} [query.after] -  The cursor that points to the next page
	 * @param {string} [query.before] -  The cursor that points to the previous page
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/users/{userId}/skillgroups" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getUserSkillgroups(userId, query) {
		const endpointPath = "/api/v2/users/{userId}/skillgroups";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("after" in query && this.#checkJSONSchemaType(query["after"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "after", "string");
			}
			if ("before" in query && this.#checkJSONSchemaType(query["before"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "before", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * @description Checks that a value is of the proper JSON schema type
	 * @param {*} value - The value to check
	 * @param {string} jsonSchemaType - The JSON schema type to check against
	 * @returns {boolean} Returns true if the value is of the proper JSON schema type, false otherwise
	 */
	#checkJSONSchemaType(value, jsonSchemaType) {
		const PASSTHROUGH_JSON_SCHEMA_TYPES = ["boolean", "number", "string", "object"];

		// Check if the type is a passthrough type
		if (PASSTHROUGH_JSON_SCHEMA_TYPES.includes(jsonSchemaType)) {
			return typeof value === jsonSchemaType;
		}

		// Check if the type is an integer
		if (jsonSchemaType === "integer") {
			return Number.isInteger(value);
		}

		// Check if the type is an array
		if (jsonSchemaType === "array") {
			return Array.isArray(value);
		}

		// Check if the type is null
		if (jsonSchemaType === "null") {
			return value === null;
		}

		// Otherwise, return false
		return false;
	}
}

export { RoutingAPI };