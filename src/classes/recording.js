/**
 * Recordings, policies, annotations, orphans
 * @module gc-platform-api-recording
 * @documentation https://developer.genesys.cloud/analyticsdatamanagement/recording/
 * @license MIT
 */

// This file was automatically generated by the Generate Genesys Cloud Platform API classes utility on 2025-04-24T15:04:25.238Z

// TODO: Implement JSON schema verification for input and output objects
// TODO: Implement HTTP response typedefs

// Set strict mode
"use strict";

// Errors
import { errors } from "../gc-platform-api-client-errors.js";

// Symbols
import { symbols } from "../gc-platform-api-client-symbols.js";

/** @typedef {import("../gc-platform-api-client-class.js").GCPlatformAPIClient} GCPlatformAPIClient */
/** @typedef {import("@jfabello/http-client").HTTPResponse} HTTPResponse */

/**
 * @typedef {object} AcknowledgeScreenRecordingRequest
 * @property {string} [participantJid]
 * @property {string} [roomId]
 * @property {string} [conversationId]
 */
 
/**
 * @typedef {object} Actions
 * @property {SkillsToRemove[]} [skillsToRemove]
 */
 
/**
 * @typedef {object} AcwSettings
 * @property {string} [wrapupPrompt] - This field controls how the UI prompts the agent for a wrapup.
 * @property {number} [timeoutMs] - The amount of time the agent can stay in ACW (Min: 1 sec, Max: 60 min).  Can only be used when ACW is AGENT_REQUESTED, MANDATORY_TIMEOUT or MANDATORY_FORCED_TIMEOUT.
 */
 
/**
 * @typedef {object} AddressableEntityRef
 * @property {string} [id]
 * @property {string} [selfUri]
 */
 
/**
 * @typedef {object} AgentOwnedRouting
 * @property {boolean} [enableAgentOwnedCallbacks] - Indicates if Agent Owned Callbacks are enabled for the queue
 * @property {number} [maxOwnedCallbackHours] - The max amount of time a callback can be owned (in hours); Allowable range 1 - 168 hour(s) (inclusive)
 * @property {number} [maxOwnedCallbackDelayHours] - The max amount of time a callback can be scheduled out into the future (in hours); Allowable range 1 - 720 hour(s) (inclusive)
 */
 
/**
 * @typedef {object} AiScoringSetting
 * @property {boolean} [enabled] - True if AI Scoring feature is configured.
 */
 
/**
 * @typedef {object} AiScoringSettings
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {QuestionGroupSettings[]} [questionGroupSettings]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} Annotation
 * @property {string} [id] - Annotation id. All pause annotations on a recording will share an ID value, bookmark annotations will have unique IDs, and hold annotations will have randomly generated UUIDs (i.e. the ID will change at each request).
 * @property {string} [name]
 * @property {string} [type]
 * @property {number} [location] - Offset of annotation in milliseconds.
 * @property {number} [durationMs] - Duration of annotation in milliseconds.
 * @property {number} [absoluteLocation] - Offset of annotation (milliseconds) from start of recording (after removing the cumulative duration of all pauses).
 * @property {number} [absoluteDurationMs] - Duration of annotation (milliseconds).
 * @property {number} [recordingLocation] - Offset of annotation (milliseconds) from start of recording, adjusted for any recording cuts
 * @property {number} [recordingDurationMs] - Duration of annotation (milliseconds), adjusted for any recording cuts.
 * @property {User} [user] - User that created this annotation (if any).
 * @property {string} [description] - Text of annotation. Maximum character limit is 500.
 * @property {string} [reason] - Reason for a pause annotation. Valid values: Hold,SecurePause,FlowOrQueue,Pause
 * @property {Annotation[]} [annotations] - List of annotations
 * @property {number} [realtimeLocation] - Offset of annotation (milliseconds) from start of the recording before removing the cumulative duration of all pauses before this annotation
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} AnswerOption
 * @property {string} [id]
 * @property {string} [text]
 * @property {number} [value]
 * @property {AssistanceCondition[]} [assistanceConditions] - List of assistance conditions which are combined together with a logical AND operator. Eg ( assistanceCondtion1 && assistanceCondition2 ) wherein assistanceCondition could be ( EXISTS topic1 || topic2 || ... ) or (NOTEXISTS topic3 || topic4 || ...).
 */
 
/**
 * @typedef {object} ArchiveRetention
 * @property {number} [days]
 * @property {string} [storageMedium]
 */
 
/**
 * @typedef {object} AssistanceCondition
 * @property {string} [operator] - The operator for the assistance condition. The operator defines whether the listed topicIds should EXIST or NOTEXIST for the condition to be evaluated as true.
 * @property {string[]} [topicIds] - List of topicIds within the assistance condition which would be combined together using logical OR operator. Eg ( topicId_1 || topicId_2 ) .
 */
 
/**
 * @typedef {object} AsyncConversationQuery
 * @property {ConversationDetailQueryFilter[]} [conversationFilters] - Filters that target conversation-level data
 * @property {SegmentDetailQueryFilter[]} [segmentFilters] - Filters that target individual segments within a conversation
 * @property {EvaluationDetailQueryFilter[]} [evaluationFilters] - Filters that target evaluations
 * @property {SurveyDetailQueryFilter[]} [surveyFilters] - Filters that target surveys
 * @property {ResolutionDetailQueryFilter[]} [resolutionFilters] - Filters that target resolutions
 * @property {string} [order] - Sort the result set in ascending/descending order. Default is ascending
 * @property {string} [orderBy] - Specify which data element within the result set to use for sorting. The options  to use as a basis for sorting the results: conversationStart, segmentStart, and segmentEnd. If not specified, the default is conversationStart
 * @property {string} interval - Specifies the date and time range of data being queried. Results will include all conversations that had activity during the interval. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {number} [limit] - Specify number of results to be returned
 * @property {boolean} [startOfDayIntervalMatching] - Add a filter to only include conversations that started after the beginning of the interval start date (UTC)
 */
 
/**
 * @typedef {object} BatchDownloadJobSubmission
 * @property {BatchDownloadRequest[]} batchDownloadRequestList - List of up to 100 items requested
 */
 
/**
 * @typedef {object} BatchDownloadRequest
 * @property {string} [conversationId] - Conversation id requested
 * @property {string} [recordingId] - Recording id requested, optional.  Leave null for all recordings on the conversation
 */
 
/**
 * @typedef {object} Biography
 * @property {string} [biography] - Personal detailed description
 * @property {string[]} [interests]
 * @property {string[]} [hobbies]
 * @property {string} [spouse]
 * @property {Education[]} [education] - User education details
 */
 
/**
 * @typedef {object} Bullseye
 * @property {Ring[]} [rings] - The bullseye rings configured for this queue.
 */
 
/**
 * @typedef {object} ButtonResponse
 * @property {string} [type] - Button response type that captures Button and QuickReply type responses
 * @property {string} [text] - Text to show inside the Button reply. This is also used as the response text after clicking on the Button.
 * @property {string} [payload] - Content of the textback payload after clicking a button
 * @property {string} [messageType] - Button response message type that captures QuickReply , Cards and Carousel .This is used  as label for Card selection
 */
 
/**
 * @typedef {object} CalibrationAssignment
 * @property {User} [calibrator]
 * @property {User[]} [evaluators]
 * @property {EvaluationForm} [evaluationForm]
 * @property {User} [expertEvaluator]
 */
 
/**
 * @typedef {object} CallbackMediaSettings
 * @property {boolean} [enableAutoAnswer] - Indicates if auto-answer is enabled for the given media type or subtype (default is false).  Subtype settings take precedence over media type settings.
 * @property {number} [alertingTimeoutSeconds] - The alerting timeout for the media type, in seconds
 * @property {ServiceLevel} [serviceLevel] - The targeted service level for the media type
 * @property {number} [autoAnswerAlertToneSeconds] - How long to play the alerting tone for an auto-answer interaction
 * @property {number} [manualAnswerAlertToneSeconds] - How long to play the alerting tone for a manual-answer interaction
 * @property {object} [subTypeSettings] - Map of media subtype to media subtype specific settings.
 * @property {string} [mode] - The mode callbacks will use on this queue.
 * @property {boolean} [enableAutoDialAndEnd] - Flag to enable Auto-Dial and Auto-End automation for callbacks on this queue.
 * @property {number} [autoDialDelaySeconds] - Time in seconds after agent connects to callback before outgoing call is auto-dialed. Allowable values in range 0 - 1200 seconds. Defaults to 300 seconds.
 * @property {number} [autoEndDelaySeconds] - Time in seconds after agent disconnects from the outgoing call before the encasing callback is auto-ended. Allowable values in range 0 - 1200 seconds. Defaults to 300 seconds.
 * @property {number} [pacingModifier] - Controls the maximum number of outbound calls at one time when mode is CustomerFirst.
 * @property {string} [liveVoiceReactionType] - The action to take if a live voice is detected during the outbound call of a customer first callback.
 * @property {DomainEntityRef} [liveVoiceFlow] - The inbound flow to transfer to if a live voice is detected during the outbound call of a customer first callback.
 * @property {string} [answeringMachineReactionType] - The action to take if an answering machine is detected during the outbound call of a customer first callback.
 * @property {DomainEntityRef} [answeringMachineFlow] - The inbound flow to transfer to if an answering machine is detected during the outbound call of a customer first callback when answeringMachineReactionType is set to TransferToFlow.
 */
 
/**
 * @typedef {object} CallMediaPolicy
 * @property {PolicyActions} [actions] - Actions applied when specified conditions are met
 * @property {CallMediaPolicyConditions} [conditions] - Conditions for when actions should be applied
 */
 
/**
 * @typedef {object} CallMediaPolicyConditions
 * @property {User[]} [forUsers]
 * @property {string[]} [dateRanges]
 * @property {Queue[]} [forQueues]
 * @property {WrapupCode[]} [wrapupCodes]
 * @property {Language[]} [languages]
 * @property {TimeAllowed} [timeAllowed]
 * @property {Team[]} [teams] - Teams to match conversations against
 * @property {string[]} [directions]
 * @property {DurationCondition} [duration]
 */
 
/**
 * @typedef {object} CannedResponseLibraries
 * @property {string[]} [libraryIds] - Set of canned response library IDs associated with the queue only when mode is SelectedOnly.
 * @property {string} [mode] - The association mode of canned response libraries to queue
 */
 
/**
 * @typedef {object} Card
 * @property {string} [title] - Text to show in the title.
 * @property {string} [description] - Text to show in the description.
 * @property {string} [url] - URL of an image.
 * @property {CardAction} [defaultAction] - The default action to be taken.
 * @property {CardAction[]} [actions] - List of possible action objects.
 */
 
/**
 * A card action that a user can take.
 * @typedef {object} CardAction
 * @property {string} [type] - Describes the type of action.
 * @property {string} [text] - The response text from the button click.
 * @property {string} [payload] - Content of the textback payload after clicking a button.
 * @property {string} [url] - The location of the image file associated with action.
 * @property {boolean} [isSelected] - Indicates if the card option is selected by end customer.
 */
 
/**
 * @typedef {object} Chat
 * @property {string} [jabberId]
 */
 
/**
 * @typedef {object} ChatMediaPolicy
 * @property {PolicyActions} [actions] - Actions applied when specified conditions are met
 * @property {ChatMediaPolicyConditions} [conditions] - Conditions for when actions should be applied
 */
 
/**
 * @typedef {object} ChatMediaPolicyConditions
 * @property {User[]} [forUsers]
 * @property {string[]} [dateRanges]
 * @property {Queue[]} [forQueues]
 * @property {WrapupCode[]} [wrapupCodes]
 * @property {Language[]} [languages]
 * @property {TimeAllowed} [timeAllowed]
 * @property {Team[]} [teams] - Teams to match conversations against
 * @property {DurationCondition} [duration]
 */
 
/**
 * @typedef {object} ChatMessage
 * @property {string} [body] - The message body
 * @property {string} [id]
 * @property {string} [to] - The message recipient
 * @property {string} [from] - The message sender
 * @property {string} [utc]
 * @property {string} [chat] - The interaction id (if available)
 * @property {string} [message] - The message id
 * @property {string} [type]
 * @property {string} [bodyType] - Type of the message body (v2 chats only)
 * @property {string} [senderCommunicationId] - Communication of sender (v2 chats only)
 * @property {string} [participantPurpose] - Participant purpose of sender (v2 chats only)
 * @property {ChatMessageUser} [user] - The user information for the sender (if available)
 */
 
/**
 * @typedef {object} ChatMessageUser
 * @property {string} [id]
 * @property {string} [name]
 * @property {string} [displayName]
 * @property {string} [username]
 * @property {Image[]} [images]
 */
 
/**
 * @typedef {object} ConditionalGroupRouting
 * @property {ConditionalGroupRoutingRule[]} [rules] - The set of rules to be executed for each conversation
 */
 
/**
 * @typedef {object} ConditionalGroupRoutingRule
 * @property {DomainEntityRef} [queue] - The queue being evaluated for this rule.  If null, the current queue will be used.
 * @property {string} [metric] - The queue metric being evaluated
 * @property {string} [operator] - The operator that compares the actual value against the condition value
 * @property {number} [conditionValue] - The limit value, beyond which a rule evaluates as true
 * @property {MemberGroup[]} [groups] - The group(s) to activate if the rule evaluates as true
 * @property {number} [waitSeconds] - The number of seconds to wait in this rule, if it evaluates as true, before evaluating the next rule.  For the final rule, this is ignored, so need not be specified.
 */
 
/**
 * @typedef {object} Contact
 * @property {string} [address] - Email address or phone number for this contact type
 * @property {string} [display] - Formatted version of the address property
 * @property {string} [mediaType]
 * @property {string} [type]
 * @property {string} [extension] - Use internal extension instead of address. Mutually exclusive with the address field.
 * @property {string} [countryCode]
 * @property {string} [integration] - Integration tag value if this number is associated with an external integration.
 */
 
/**
 * @typedef {object} ContactAddress
 * @property {string} [address1]
 * @property {string} [address2]
 * @property {string} [city]
 * @property {string} [state]
 * @property {string} [postalCode]
 * @property {string} [countryCode]
 */
 
/**
 * @typedef {object} ContactAddressableEntityRef
 * @property {string} [id]
 * @property {string} [selfUri]
 */
 
/**
 * @typedef {object} ContactIdentifier
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {WritableStarrableDivision} [division] - The division to which this entity belongs.
 * @property {string} type - The type of this identifier
 * @property {string} value - The string value of the identifier. Will vary in syntax by type.
 * @property {string} [dateCreated] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {ExternalSource} [externalSource] - The External Source ID of the identifier
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} ConversationDeletionProtectionQuery
 * @property {string[]} conversationIds - This is a list of ConversationIds. The list cannot exceed 100 conversationids.
 */
 
/**
 * @typedef {object} ConversationDetailQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {ConversationDetailQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ConversationDetailQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {ConversationDetailQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {ConversationDetailQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ConversationDetailQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [metric] - Left hand side for metric predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension or metric predicates
 * @property {NumericRange} [range] - Right hand side for dimension or metric predicates
 */
 
/**
 * A CoBrowse event.
 * @typedef {object} ConversationEventCoBrowse
 * @property {string} type - Describes the type of CoBrowse event.
 * @property {string} [sessionId] - The CoBrowse session ID.
 * @property {string} [sessionJoinToken] - The CoBrowse session join token.
 */
 
/**
 * A Presence event.
 * @typedef {object} ConversationEventPresence
 * @property {string} type - Describes the type of Presence event.
 */
 
/**
 * A Typing event.
 * @typedef {object} ConversationEventTyping
 * @property {string} type - Describes the type of Typing event.
 * @property {number} [duration] - The duration of the Typing event in milliseconds.
 */
 
/**
 * A Video event.
 * @typedef {object} ConversationEventVideo
 * @property {string} type - Describes the type of Video event.
 * @property {string} [offeringId] - The Video offering ID.
 * @property {string} [jwt] - The Video offering JWT token.
 */
 
/**
 * Message event element.  Examples include: system messages, typing indicators, cobrowse offerings.
 * @typedef {object} ConversationMessageEvent
 * @property {string} eventType - Type of this event element
 * @property {ConversationEventCoBrowse} [coBrowse] - CoBrowse event.
 * @property {ConversationEventTyping} [typing] - Typing event.
 * @property {ConversationEventPresence} [presence] - Presence event.
 * @property {ConversationEventVideo} [video] - Video event.
 */
 
/**
 * @typedef {object} CrossPlatformCallMediaPolicy
 * @property {CrossPlatformPolicyActions} [actions] - Actions applied when specified conditions are met
 * @property {CallMediaPolicyConditions} [conditions] - Conditions for when actions should be applied
 */
 
/**
 * @typedef {object} CrossPlatformChatMediaPolicy
 * @property {CrossPlatformPolicyActions} [actions] - Actions applied when specified conditions are met
 * @property {ChatMediaPolicyConditions} [conditions] - Conditions for when actions should be applied
 */
 
/**
 * @typedef {object} CrossPlatformEmailMediaPolicy
 * @property {CrossPlatformPolicyActions} [actions] - Actions applied when specified conditions are met
 * @property {EmailMediaPolicyConditions} [conditions] - Conditions for when actions should be applied
 */
 
/**
 * @typedef {object} CrossPlatformMediaPolicies
 * @property {CrossPlatformCallMediaPolicy} [callPolicy] - Conditions and actions for calls
 * @property {CrossPlatformChatMediaPolicy} [chatPolicy] - Conditions and actions for chats
 * @property {CrossPlatformEmailMediaPolicy} [emailPolicy] - Conditions and actions for emails
 * @property {CrossPlatformMessageMediaPolicy} [messagePolicy] - Conditions and actions for messages
 */
 
/**
 * @typedef {object} CrossPlatformMessageMediaPolicy
 * @property {CrossPlatformPolicyActions} [actions] - Actions applied when specified conditions are met
 * @property {MessageMediaPolicyConditions} [conditions] - Conditions for when actions should be applied
 */
 
/**
 * @typedef {object} CrossPlatformPolicy
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [modifiedDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [createdDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {number} [order]
 * @property {string} [description]
 * @property {boolean} [enabled]
 * @property {CrossPlatformMediaPolicies} [mediaPolicies] - Conditions and actions per media type
 * @property {PolicyConditions} [conditions] - Conditions
 * @property {CrossPlatformPolicyActions} [actions] - Actions
 * @property {PolicyErrors} [policyErrors]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} CrossPlatformPolicyActions
 * @property {boolean} [retainRecording] - true to retain the recording associated with the conversation. Default = true
 * @property {boolean} [deleteRecording] - true to delete the recording associated with the conversation. If retainRecording = true, this will be ignored. Default = false
 * @property {boolean} [alwaysDelete] - true to delete the recording associated with the conversation regardless of the values of retainRecording or deleteRecording. Default = false
 * @property {EvaluationAssignment[]} [assignEvaluations]
 * @property {MeteredEvaluationAssignment[]} [assignMeteredEvaluations]
 * @property {MeteredAssignmentByAgent[]} [assignMeteredAssignmentByAgent]
 * @property {CalibrationAssignment[]} [assignCalibrations]
 * @property {RetentionDuration} [retentionDuration]
 * @property {MediaTranscription[]} [mediaTranscriptions]
 * @property {IntegrationExport} [integrationExport] - Policy action for exporting recordings using an integration to 3rd party s3.
 */
 
/**
 * @typedef {object} CrossPlatformPolicyCreate
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The policy name.
 * @property {string} [modifiedDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [createdDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {number} [order]
 * @property {string} [description]
 * @property {boolean} [enabled]
 * @property {CrossPlatformMediaPolicies} [mediaPolicies] - Conditions and actions per media type
 * @property {PolicyConditions} [conditions] - Conditions
 * @property {CrossPlatformPolicyActions} [actions] - Actions
 * @property {PolicyErrors} [policyErrors]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} CrossPlatformPolicyUpdate
 * @property {boolean} [enabled]
 */
 
/**
 * @typedef {object} DataSchema
 * @property {string} [id] - The globally unique identifier for the schema.  Only required if a schema is used for custom fields during external entity creation or updates.
 * @property {string} [name]
 * @property {number} version - The schema's version, a positive integer. Required for updates.
 * @property {string[]} [appliesTo] - Indicates the built-in entity type to which this schema applies.
 * @property {boolean} [enabled] - The schema's enabled/disabled status. A disabled schema cannot be assigned to any other entities, but the data on those entities from the schema still exists.
 * @property {DomainEntityRef} [createdBy] - The URI of the user that created this schema.
 * @property {string} [dateCreated] - The date and time this schema was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {JsonSchemaDocument} jsonSchema - A JSON schema defining the extension to the built-in entity type.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} DeleteRetention
 * @property {number} [days]
 */
 
/**
 * @typedef {object} Detail
 * @property {string} [errorCode]
 * @property {string} [fieldName]
 * @property {string} [entityId]
 * @property {string} [entityName]
 */
 
/**
 * @typedef {object} DirectRouting
 * @property {DirectRoutingMediaSettings} [callMediaSettings] - Direct Routing Settings specific to Call media.
 * @property {DirectRoutingMediaSettings} [emailMediaSettings] - Direct Routing Settings specific to Email media.
 * @property {DirectRoutingMediaSettings} [messageMediaSettings] - Direct Routing Settings specific to Message media.
 * @property {string} [backupQueueId] - ID of another queue to be used as the default backup if an agent does not have their Backup Settings configured. If not set, the current queue will be used as backup, but with Direct Routing criteria removed from the conversation.
 * @property {boolean} [waitForAgent] - Flag indicating if Direct Routing interactions should wait for Direct Routing agent or go immediately to selected backup.
 * @property {number} [agentWaitSeconds] - Time (in seconds) that a Direct Routing interaction will wait for Direct Routing agent before going to selected backup. Valid range [60, 864000].
 */
 
/**
 * @typedef {object} DirectRoutingMediaSettings
 * @property {boolean} [useAgentAddressOutbound] - Toggle that enables using an agent's Direct Routing address outbound on behalf of queue for this media type.
 */
 
/**
 * @typedef {object} Division
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} DomainEntityListingEvaluationForm
 * @property {EvaluationForm[]} [entities]
 * @property {number} [pageSize]
 * @property {number} [pageNumber]
 * @property {number} [total]
 * @property {string} [firstUri]
 * @property {string} [lastUri]
 * @property {string} [selfUri]
 * @property {string} [nextUri]
 * @property {string} [previousUri]
 * @property {number} [pageCount]
 */
 
/**
 * @typedef {object} DomainEntityRef
 * @property {string} [id]
 * @property {string} [name]
 * @property {string} [selfUri]
 */
 
/**
 * @typedef {object} DomainRole
 * @property {string} [id] - The ID of the role
 * @property {string} [name] - The name of the role
 */
 
/**
 * @typedef {object} DurationCondition
 * @property {string} [durationTarget]
 * @property {string} [durationOperator]
 * @property {string} [durationRange]
 * @property {string} [durationMode]
 */
 
/**
 * @typedef {object} Education
 * @property {string} [school]
 * @property {string} [fieldOfStudy]
 * @property {string} [notes] - Notes about education has a 2000 character limit
 * @property {string} [dateStart] - Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd
 * @property {string} [dateEnd] - Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd
 */
 
/**
 * @typedef {object} EmailAddress
 * @property {string} [email]
 * @property {string} [name]
 */
 
/**
 * @typedef {object} EmailAttachment
 * @property {string} [name]
 * @property {string} [contentPath]
 * @property {string} [contentType]
 * @property {string} [attachmentId]
 * @property {number} [contentLength]
 */
 
/**
 * @typedef {object} EmailMediaPolicy
 * @property {PolicyActions} [actions] - Actions applied when specified conditions are met
 * @property {EmailMediaPolicyConditions} [conditions] - Conditions for when actions should be applied
 */
 
/**
 * @typedef {object} EmailMediaPolicyConditions
 * @property {User[]} [forUsers]
 * @property {string[]} [dateRanges]
 * @property {Queue[]} [forQueues]
 * @property {WrapupCode[]} [wrapupCodes]
 * @property {Language[]} [languages]
 * @property {TimeAllowed} [timeAllowed]
 * @property {Team[]} [teams] - Teams to match conversations against
 * @property {string} [customerParticipation]
 */
 
/**
 * @typedef {object} EmailMediaSettings
 * @property {boolean} [enableAutoAnswer] - Indicates if auto-answer is enabled for the given media type or subtype (default is false).  Subtype settings take precedence over media type settings.
 * @property {number} [alertingTimeoutSeconds] - The alerting timeout for the media type, in seconds
 * @property {ServiceLevel} [serviceLevel] - The targeted service level for the media type
 * @property {number} [autoAnswerAlertToneSeconds] - How long to play the alerting tone for an auto-answer interaction
 * @property {number} [manualAnswerAlertToneSeconds] - How long to play the alerting tone for a manual-answer interaction
 * @property {object} [subTypeSettings] - Map of media subtype to media subtype specific settings.
 */
 
/**
 * @typedef {object} EmployerInfo
 * @property {string} [officialName]
 * @property {string} [employeeId]
 * @property {string} [employeeType]
 * @property {string} [dateHire]
 */
 
/**
 * @typedef {object} ErrorBody
 * @property {string} [message]
 * @property {string} [code]
 * @property {number} [status]
 * @property {string} [entityId]
 * @property {string} [entityName]
 * @property {string} [messageWithParams]
 * @property {object} [messageParams]
 * @property {string} [contextId]
 * @property {Detail[]} [details]
 * @property {ErrorBody[]} [errors]
 * @property {Limit} [limit]
 */
 
/**
 * @typedef {object} EvaluationAssignment
 * @property {EvaluationForm} [evaluationForm]
 * @property {User} [user]
 */
 
/**
 * @typedef {object} EvaluationDetailQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {EvaluationDetailQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} EvaluationDetailQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {EvaluationDetailQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {EvaluationDetailQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} EvaluationDetailQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [metric] - Left hand side for metric predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension or metric predicates
 * @property {NumericRange} [range] - Right hand side for dimension or metric predicates
 */
 
/**
 * @typedef {object} EvaluationForm
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The evaluation form name
 * @property {string} [modifiedDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {boolean} [published]
 * @property {string} [contextId]
 * @property {EvaluationQuestionGroup[]} questionGroups - A list of question groups
 * @property {DomainEntityListingEvaluationForm} [publishedVersions] - A list of the published versions of this form. Not populated by default, its availability depends on the endpoint. Use the 'expand=publishHistory' query parameter to retrieve this data where applicable (refer to the endpoint description to see if it is applicable).
 * @property {EvaluationSettings} [evaluationSettings] - Settings for evaluations associated with this form
 * @property {AiScoringSettings} [aiScoring] - AI scoring settings for the evaluation form.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} EvaluationQuestion
 * @property {string} [id]
 * @property {string} [contextId] - An identifier for this question that stays the same across versions of the form.
 * @property {string} [text]
 * @property {string} [helpText]
 * @property {string} [type]
 * @property {boolean} [naEnabled]
 * @property {boolean} [commentsRequired]
 * @property {VisibilityCondition} [visibilityCondition]
 * @property {AnswerOption[]} [answerOptions] - Options from which to choose an answer for this question. Only used by Multiple Choice type questions.
 * @property {boolean} [isKill]
 * @property {boolean} [isCritical]
 */
 
/**
 * @typedef {object} EvaluationQuestionGroup
 * @property {string} [id]
 * @property {string} [contextId] - An identifier for this question group that stays the same across versions of the form.
 * @property {string} [name]
 * @property {string} [type]
 * @property {boolean} [defaultAnswersToHighest]
 * @property {boolean} [defaultAnswersToNA]
 * @property {boolean} [naEnabled]
 * @property {number} [weight]
 * @property {boolean} [manualWeight]
 * @property {EvaluationQuestion[]} [questions]
 * @property {VisibilityCondition} [visibilityCondition]
 */
 
/**
 * @typedef {object} EvaluationSettings
 * @property {boolean} [revisionsEnabled] - Whether revisions are allowed for evaluations. When enabled, rescoring creates a new version of the evaluation and retracts the existing evaluation version. Does not apply for calibration evaluations.
 * @property {boolean} [disputesEnabled] - Whether disputes are allowed for evaluations. Does not apply for calibration evaluations.
 * @property {number} [disputesAllowedPerEvaluation] - The maximum number of disputes allowed for an evaluation.
 * @property {EvaluationSettingsAssignee[]} [disputesAssignees] - A list of assignees responsible for handling each dispute. This list size needs to be equal to disputesAllowedPerEvaluation.
 */
 
/**
 * @typedef {object} EvaluationSettingsAssignee
 * @property {UserReferenceWithName} [user] - The user the dispute should be assigned to
 * @property {string} [type] - The assignee type. Valid values: Original, Individual, None
 */
 
/**
 * @typedef {object} ExecuteRecordingJobsQuery
 * @property {string} state - The desired state for the job to be set to.
 */
 
/**
 * @typedef {object} ExpansionCriterium
 * @property {string} [type]
 * @property {number} [threshold]
 */
 
/**
 * @typedef {object} ExternalContact
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {WritableStarrableDivision} [division] - The division to which this entity belongs.
 * @property {string} [firstName] - The first name of the contact.
 * @property {string} [middleName]
 * @property {string} [lastName] - The last name of the contact.
 * @property {string} [salutation]
 * @property {string} [title]
 * @property {PhoneNumber} [workPhone]
 * @property {PhoneNumber} [cellPhone]
 * @property {PhoneNumber} [homePhone]
 * @property {PhoneNumber} [otherPhone]
 * @property {string} [workEmail]
 * @property {string} [personalEmail]
 * @property {string} [otherEmail]
 * @property {ContactAddress} [address]
 * @property {TwitterId} [twitterId]
 * @property {LineId} [lineId]
 * @property {WhatsAppId} [whatsAppId]
 * @property {FacebookId} [facebookId]
 * @property {ExternalId[]} [externalIds] - A list of external identifiers that identify this contact in an external system
 * @property {ContactIdentifier[]} [identifiers] - Identifiers claimed by this contact
 * @property {string} [modifyDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [createDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {ExternalOrganization} [externalOrganization]
 * @property {boolean} [surveyOptOut]
 * @property {string} [externalSystemUrl] - A string that identifies an external system-of-record resource that may have more detailed information on the contact. It should be a valid URL (including the http/https protocol, port, and path [if any]). The value is automatically trimmed of any leading and trailing whitespace.
 * @property {DataSchema} [schema] - The schema defining custom fields for this contact
 * @property {object} [customFields] - Custom fields defined in the schema referenced by schemaId and schemaVersion.
 * @property {ExternalDataSource[]} [externalDataSources] - Links to the sources of data (e.g. one source might be a CRM) that contributed data to this record.  Read-only, and only populated when requested via expand param.
 * @property {string} [type] - The type of contact
 * @property {ContactAddressableEntityRef} [canonicalContact] - The contact at the head of the merge tree. If null, this contact is not a part of any merge.
 * @property {ContactAddressableEntityRef[]} [mergeSet] - The set of all contacts that are a part of the merge tree. If null, this contact is not a part of any merge.
 * @property {MergeOperation} [mergeOperation] - Information about the merge history of this contact. If null, this contact is not a part of any merge.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * Describes a link to a record in an external system that contributed data to a Relate record
 * @typedef {object} ExternalDataSource
 * @property {string} [platform] - The platform that was the source of the data.  Example: a CRM like SALESFORCE.
 * @property {string} [url] - An URL that links to the source record that contributed data to the associated entity.
 */
 
/**
 * @typedef {object} ExternalId
 * @property {ExternalSource} [externalSource]
 * @property {string} [value]
 */
 
/**
 * @typedef {object} ExternalOrganization
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The name of the company.
 * @property {WritableStarrableDivision} [division] - The division to which this entity belongs.
 * @property {string} [companyType]
 * @property {string} [industry]
 * @property {ContactAddress} [address]
 * @property {PhoneNumber} [phoneNumber]
 * @property {PhoneNumber} [faxNumber]
 * @property {number} [employeeCount]
 * @property {number} [revenue]
 * @property {string[]} [tags]
 * @property {string[]} [websites]
 * @property {Ticker[]} [tickers]
 * @property {TwitterId} [twitterId]
 * @property {string} [externalSystemUrl] - A string that identifies an external system-of-record resource that may have more detailed information on the organization. It should be a valid URL (including the http/https protocol, port, and path [if any]). The value is automatically trimmed of any leading and trailing whitespace.
 * @property {string} [modifyDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [createDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {Trustor} [trustor]
 * @property {DataSchema} [schema] - The schema defining custom fields for this contact
 * @property {object} [customFields] - Custom fields defined in the schema referenced by schemaId and schemaVersion.
 * @property {ExternalDataSource[]} [externalDataSources] - Links to the sources of data (e.g. one source might be a CRM) that contributed data to this record.  Read-only, and only populated when requested via expand param.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} ExternalSource
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The name of the external source.
 * @property {boolean} [active]
 * @property {LinkConfiguration} [linkConfiguration]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * User information for a Facebook user interacting with a page or app
 * @typedef {object} FacebookId
 * @property {FacebookScopedId[]} [ids] - The set of scopedIds that this person has. Each scopedId is specific to a page or app that the user interacts with.
 * @property {string} [displayName] - The displayName of this person's Facebook account. Roughly translates to user.first_name + ' ' + user.last_name in the Facebook API.
 */
 
/**
 * Scoped ID for a Facebook user interacting with a page or app
 * @typedef {object} FacebookScopedId
 * @property {string} [scopedId] - The unique page/app-specific scopedId for the user
 */
 
/**
 * @typedef {object} Geolocation
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [type] - A string used to describe the type of client the geolocation is being updated from e.g. ios, android, web, etc.
 * @property {boolean} [primary] - A boolean used to tell whether or not to set this geolocation client as the primary on a PATCH
 * @property {number} [latitude]
 * @property {number} [longitude]
 * @property {string} [country]
 * @property {string} [region]
 * @property {string} [city]
 * @property {LocationDefinition[]} [locations]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} Group
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The group name.
 * @property {string} [description]
 * @property {string} [dateModified] - Last modified date/time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {number} [memberCount] - Number of members.
 * @property {string} [state] - Active, inactive, or deleted state.
 * @property {number} [version] - Current version for this resource.
 * @property {string} type - Type of group.
 * @property {Image[]} [images]
 * @property {GroupContact[]} [addresses]
 * @property {boolean} rulesVisible - Are membership rules visible to the person requesting to view the group
 * @property {string} visibility - Who can view this group
 * @property {boolean} [rolesEnabled] - Allow roles to be assigned to this group
 * @property {boolean} [includeOwners] - Allow owners to be included as members of the group
 * @property {boolean} [callsEnabled] - Allow calls to be placed to this group.
 * @property {User[]} [owners] - Owners of the group
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} GroupContact
 * @property {string} address - Phone number for this contact type
 * @property {string} [extension] - Extension is set if the number is e164 valid
 * @property {string} [display] - Formatted version of the address property
 * @property {string} type - Contact type of the address
 * @property {string} mediaType - Media type of the address
 */
 
/**
 * @typedef {object} Image
 * @property {string} [resolution] - Height and/or width of image. ex: 640x480 or x128
 * @property {string} [imageUri]
 */
 
/**
 * @typedef {object} InboundRoute
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} pattern - The search pattern that the mailbox name should match.
 * @property {DomainEntityRef} [queue] - The queue to route the emails to.
 * @property {number} [priority] - The priority to use for routing.
 * @property {DomainEntityRef[]} [skills] - The skills to use for routing.
 * @property {DomainEntityRef} [language] - The language to use for routing.
 * @property {string} fromName - The sender name to use for outgoing replies.
 * @property {string} [fromEmail] - The sender email to use for outgoing replies.
 * @property {DomainEntityRef} [flow] - The flow to use for processing the email.
 * @property {QueueEmailAddress} [replyEmailAddress] - The route to use for email replies.
 * @property {EmailAddress[]} [autoBcc] - The recipients that should be automatically blind copied on outbound emails associated with this InboundRoute.
 * @property {DomainEntityRef} [spamFlow] - The flow to use for processing inbound emails that have been marked as spam.
 * @property {Signature} [signature] - The configuration for the canned response signature that will be appended to outbound emails sent via this route
 * @property {string} [historyInclusion] - The configuration to indicate how the history of a conversation has to be included in a draft
 * @property {boolean} [allowMultipleActions] - Control if multiple actions are allowed on this route. When true the disconnect has to be done manually. When false a conversation will be disconnected by the system after every action
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} InitiateScreenRecording
 * @property {boolean} [recordACW]
 * @property {ArchiveRetention} [archiveRetention]
 * @property {DeleteRetention} [deleteRetention]
 */
 
/**
 * @typedef {object} IntegrationExport
 * @property {DomainEntityRef} integration - The aws-s3-recording-bulk-actions-integration that the policy uses for exports.
 * @property {boolean} [shouldExportScreenRecordings] - True if the policy should export screen recordings in addition to the other conversation media. Default = true
 */
 
/**
 * A JSON Schema document.
 * @typedef {object} JsonSchemaDocument
 * @property {string} [id]
 * @property {string} [$schema]
 * @property {string} [title]
 * @property {string} [description]
 * @property {string} [type]
 * @property {string[]} [required]
 * @property {object} [properties]
 * @property {object} [additionalProperties]
 */
 
/**
 * @typedef {object} KeyRotationSchedule
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} period - Value to set schedule to
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} Language
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The language name.
 * @property {string} [dateModified] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [state]
 * @property {string} [version]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} Limit
 * @property {string} [key]
 * @property {string} [namespace]
 * @property {number} [value]
 */
 
/**
 * User information for a Line account
 * @typedef {object} LineId
 * @property {LineUserId[]} [ids] - The set of Line userIds that this person has. Each userId is specific to the Line channel that the user interacts with.
 * @property {string} [displayName] - The displayName of this person's account in Line
 */
 
/**
 * Channel-specific User ID for Line accounts
 * @typedef {object} LineUserId
 * @property {string} [userId] - The unique channel-specific userId for the user
 */
 
/**
 * @typedef {object} LinkConfiguration
 * @property {string} [uriTemplate]
 */
 
/**
 * @typedef {object} LocalEncryptionKeyRequest
 * @property {string} configId - The local configuration id that contains metadata on private local service
 * @property {string} publicKey - Base 64 encoded public key, generated by the local service.
 * @property {string} keypairId - The key pair id from the local service.
 */
 
/**
 * @typedef {object} Location
 * @property {string} [id] - Unique identifier for the location
 * @property {string} [floorplanId] - Unique identifier for the location floorplan image
 * @property {object} [coordinates] - Users coordinates on the floorplan. Only used when floorplanImage is set
 * @property {string} [notes] - Optional description on the users location
 * @property {LocationDefinition} [locationDefinition]
 */
 
/**
 * @typedef {object} LocationAddress
 * @property {string} [city]
 * @property {string} [country]
 * @property {string} [countryName]
 * @property {string} [state]
 * @property {string} [street1]
 * @property {string} [street2]
 * @property {string} [zipcode]
 */
 
/**
 * @typedef {object} LocationAddressVerificationDetails
 * @property {string} [status] - Status of address verification process
 * @property {string} [dateFinished] - Finished time of address verification process. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateStarted] - Time started of address verification process. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [service] - Third party service used for address verification
 */
 
/**
 * @typedef {object} LocationDefinition
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {AddressableEntityRef} [contactUser] - Site contact for the location entity
 * @property {LocationEmergencyNumber} [emergencyNumber] - Emergency number for the location entity
 * @property {LocationAddress} [address]
 * @property {string} [state] - Current state of the location entity
 * @property {string} [notes] - Notes for the location entity
 * @property {number} [version] - Current version of the location entity, value to be supplied should be retrieved by a GET or on create/update response
 * @property {string[]} [path] - A list of ancestor IDs in order
 * @property {LocationImage[]} [profileImage] - Profile image of the location entity, retrieved with ?expand=images query parameter
 * @property {LocationImage[]} [floorplanImage] - Floorplan images of the location entity, retrieved with ?expand=images query parameter
 * @property {LocationAddressVerificationDetails} [addressVerificationDetails] - Address verification information, retrieve dwith the ?expand=addressVerificationDetails query parameter
 * @property {boolean} [addressVerified] - Boolean field which states if the address has been verified as an actual address
 * @property {boolean} [addressStored] - Boolean field which states if the address has been stored for E911
 * @property {string} [images]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} LocationEmergencyNumber
 * @property {string} [e164]
 * @property {string} [number]
 * @property {string} [type] - The type of emergency number.
 */
 
/**
 * @typedef {object} LocationImage
 * @property {string} [resolution] - Height and/or width of image. ex: 640x480 or x128
 * @property {string} [imageUri]
 */
 
/**
 * @typedef {object} MediaPolicies
 * @property {CallMediaPolicy} [callPolicy] - Conditions and actions for calls
 * @property {ChatMediaPolicy} [chatPolicy] - Conditions and actions for chats
 * @property {EmailMediaPolicy} [emailPolicy] - Conditions and actions for emails
 * @property {MessageMediaPolicy} [messagePolicy] - Conditions and actions for messages
 */
 
/**
 * @typedef {object} MediaSettings
 * @property {boolean} [enableAutoAnswer] - Indicates if auto-answer is enabled for the given media type or subtype (default is false).  Subtype settings take precedence over media type settings.
 * @property {number} [alertingTimeoutSeconds] - The alerting timeout for the media type, in seconds
 * @property {ServiceLevel} [serviceLevel] - The targeted service level for the media type
 * @property {number} [autoAnswerAlertToneSeconds] - How long to play the alerting tone for an auto-answer interaction
 * @property {number} [manualAnswerAlertToneSeconds] - How long to play the alerting tone for a manual-answer interaction
 * @property {object} [subTypeSettings] - Map of media subtype to media subtype specific settings.
 */
 
/**
 * @typedef {object} MediaSummary
 * @property {MediaSummaryDetail} [contactCenter]
 * @property {MediaSummaryDetail} [enterprise]
 */
 
/**
 * @typedef {object} MediaSummaryDetail
 * @property {number} [active]
 * @property {number} [acw]
 */
 
/**
 * @typedef {object} MediaTranscription
 * @property {string} [displayName]
 * @property {string} [transcriptionProvider]
 * @property {string} [integrationId]
 */
 
/**
 * @typedef {object} MemberGroup
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {WritableDivision} [division] - The division to which this entity belongs.
 * @property {string} [type] - The group type
 * @property {number} [memberCount] - The number of members in this group
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} MergeOperation
 * @property {AddressableEntityRef} [sourceContact] - The source contact for the merge operation
 * @property {AddressableEntityRef} [targetContact] - The target contact for the merge operation
 * @property {AddressableEntityRef} [resultingContact] - The contact created as a result of the merge operation
 */
 
/**
 * @typedef {object} MessageMediaAttachment
 * @property {string} [url] - The location of the media, useful for retrieving it
 * @property {string} [mediaType] - The optional internet media type of the the media object.If null then the media type should be dictated by the url.
 * @property {number} [contentLength] - The optional content length of the the media object, in bytes.
 * @property {string} [name] - The name of the media object.
 * @property {string} [id] - A globally unique identifier for the media object.
 */
 
/**
 * @typedef {object} MessageMediaPolicy
 * @property {PolicyActions} [actions] - Actions applied when specified conditions are met
 * @property {MessageMediaPolicyConditions} [conditions] - Conditions for when actions should be applied
 */
 
/**
 * @typedef {object} MessageMediaPolicyConditions
 * @property {User[]} [forUsers]
 * @property {string[]} [dateRanges]
 * @property {Queue[]} [forQueues]
 * @property {WrapupCode[]} [wrapupCodes]
 * @property {Language[]} [languages]
 * @property {TimeAllowed} [timeAllowed]
 * @property {Team[]} [teams] - Teams to match conversations against
 * @property {string} [customerParticipation]
 */
 
/**
 * @typedef {object} MessageMediaSettings
 * @property {boolean} [enableAutoAnswer] - Indicates if auto-answer is enabled for the given media type or subtype (default is false).  Subtype settings take precedence over media type settings.
 * @property {number} [alertingTimeoutSeconds] - The alerting timeout for the media type, in seconds
 * @property {ServiceLevel} [serviceLevel] - The targeted service level for the media type
 * @property {number} [autoAnswerAlertToneSeconds] - How long to play the alerting tone for an auto-answer interaction
 * @property {number} [manualAnswerAlertToneSeconds] - How long to play the alerting tone for a manual-answer interaction
 * @property {object} [subTypeSettings] - Map of media subtype to media subtype specific settings.
 */
 
/**
 * @typedef {object} MessageStickerAttachment
 * @property {string} [url] - The location of the media, useful for retrieving it
 * @property {string} [id] - A globally unique identifier for the media object.
 */
 
/**
 * @typedef {object} MeteredAssignmentByAgent
 * @property {string} [evaluationContextId]
 * @property {User[]} [evaluators]
 * @property {number} [maxNumberEvaluations]
 * @property {EvaluationForm} [evaluationForm]
 * @property {TimeInterval} [timeInterval]
 * @property {string} [timeZone]
 */
 
/**
 * @typedef {object} MeteredEvaluationAssignment
 * @property {string} [evaluationContextId]
 * @property {User[]} [evaluators]
 * @property {number} [maxNumberEvaluations]
 * @property {EvaluationForm} [evaluationForm]
 * @property {boolean} [assignToActiveUser]
 * @property {TimeInterval} [timeInterval]
 */
 
/**
 * @typedef {object} NumericRange
 * @property {number} [gt] - Greater than
 * @property {number} [gte] - Greater than or equal to
 * @property {number} [lt] - Less than
 * @property {number} [lte] - Less than or equal to
 */
 
/**
 * @typedef {object} OAuthLastTokenIssued
 * @property {string} [dateIssued] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 */
 
/**
 * @typedef {object} Organization
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [defaultLanguage] - The default language for this organization. Example: 'en'
 * @property {string} [defaultCountryCode] - The default country code for this organization. Example: 'US'
 * @property {string} [thirdPartyOrgName] - The short name for the organization. This field is globally unique and cannot be changed.
 * @property {string} [thirdPartyURI]
 * @property {string} [domain]
 * @property {number} version - The current version of the organization.
 * @property {string} [state] - The current state. Examples are active, inactive, deleted.
 * @property {string} [defaultSiteId]
 * @property {string} [supportURI] - Email address where support tickets are sent to.
 * @property {boolean} [voicemailEnabled]
 * @property {string} [productPlatform] - Organizations Originating Platform.
 * @property {string} [selfUri] - The URI for this object
 * @property {object} [features] - The state of features available for the organization.
 */
 
/**
 * @typedef {object} OrgUser
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {Division} [division] - The division to which this entity belongs.
 * @property {Chat} [chat]
 * @property {string} [department]
 * @property {string} [email]
 * @property {Contact[]} [primaryContactInfo] - Auto populated from addresses.
 * @property {Contact[]} [addresses] - Email addresses and phone numbers for this user
 * @property {string} [state] - The current state for this user.
 * @property {string} [title]
 * @property {string} [username]
 * @property {User} [manager]
 * @property {Image[]} [images]
 * @property {number} version - Required when updating a user, this value should be the current version of the user.  The current version can be obtained with a GET on the user before doing a PATCH.
 * @property {string[]} [certifications]
 * @property {Biography} [biography]
 * @property {EmployerInfo} [employerInfo]
 * @property {string} [preferredName] - Preferred full name of the agent
 * @property {RoutingStatus} [routingStatus] - ACD routing status
 * @property {UserPresence} [presence] - Active presence
 * @property {UserPresence} [integrationPresence] - Integration presence
 * @property {UserConversationSummary} [conversationSummary] - Summary of conversion statistics for conversation types.
 * @property {OutOfOffice} [outOfOffice] - Determine if out of office is enabled
 * @property {Geolocation} [geolocation] - Current geolocation position
 * @property {UserStations} [station] - Effective, default, and last station information
 * @property {UserAuthorization} [authorization] - Roles and permissions assigned to the user
 * @property {string[]} [profileSkills] - Profile skills possessed by the user
 * @property {Location[]} [locations] - The user placement at each site location.
 * @property {Group[]} [groups] - The groups the user is a member of
 * @property {Team} [team] - The team the user is a member of
 * @property {WorkPlanBidRanks} [workPlanBidRanks] - The WFM work plan bid rank settings for the user
 * @property {UserRoutingSkill[]} [skills] - Routing (ACD) skills possessed by the user
 * @property {UserRoutingLanguage[]} [languages] - Routing (ACD) languages possessed by the user
 * @property {boolean} [acdAutoAnswer] - acd auto answer
 * @property {string} [languagePreference] - preferred language by the user
 * @property {OAuthLastTokenIssued} [lastTokenIssued]
 * @property {string} [dateLastLogin] - The last time the user logged in using username and password. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateWelcomeSent] - The date & time the user was sent their welcome email. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {Organization} [organization]
 */
 
/**
 * @typedef {object} OrphanUpdateRequest
 * @property {string} [archiveDate] - The orphan recording's archive date. Must be greater than 1 day from now if set. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [deleteDate] - The orphan recording's delete date. Must be greater than archiveDate and exportDate if set, otherwise one day from now. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [exportDate] - The orphan recording's export date. Must be greater than 1 day from now if set. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [integrationId] - IntegrationId to access AWS S3 bucket for export. This field is required if exportDate is set.
 * @property {string} [conversationId] - A conversation Id that this orphan's recording is to be attached to. If not present, the conversationId will be deduced from the recording media.
 */
 
/**
 * @typedef {object} OutOfOffice
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {User} [user]
 * @property {string} [startDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [endDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {boolean} [active]
 * @property {boolean} [indefinite]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} PhoneNumber
 * @property {string} [display] - The displayed form of the phone number string. Users should input the phone number in this field, but it will be altered by the API on write. If the phone number can be read as E164, the value will be replaced with international formatted-version of the number. If the number cannot be read as E164, the value will be preserved as-is. In both cases, the provided input string will be copied to the userInput field.
 * @property {number} [extension] - An optional extension for the provided phone number.
 * @property {boolean} [acceptsSMS] - Whether this phone number can accept SMS messages.
 * @property {string} [normalizationCountryCode] - The country code that will be used for E164 conversion of a provided phone number. If the country code is omitted from the provided phone number, the country code provided in this field will be used during the E164 conversion attempt. If this field is left empty, the default country code for any provided phone number that does not explicitly include a country code is assumed to be +1 (North America).
 * @property {string} [userInput] - The user-inputted phone number string that was provided to the display field on write. This field is not user-writeable and will always be set by the system.
 * @property {string} [e164] - The E164-formatted form of the provided phone number. This field is not user-writeable and will only be set when the provided phone number could be read as E164.
 * @property {string} [countryCode] - The detected country code from the provided phone number. This field is not user-writeable and will only be set when the provided phone number could be read as E164.
 */
 
/**
 * @typedef {object} Policy
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [modifiedDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [createdDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {number} [order]
 * @property {string} [description]
 * @property {boolean} [enabled]
 * @property {MediaPolicies} [mediaPolicies] - Conditions and actions per media type
 * @property {PolicyConditions} [conditions] - Conditions
 * @property {PolicyActions} [actions] - Actions
 * @property {PolicyErrors} [policyErrors]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} PolicyActions
 * @property {boolean} [retainRecording] - true to retain the recording associated with the conversation. Default = true
 * @property {boolean} [deleteRecording] - true to delete the recording associated with the conversation. If retainRecording = true, this will be ignored. Default = false
 * @property {boolean} [alwaysDelete] - true to delete the recording associated with the conversation regardless of the values of retainRecording or deleteRecording. Default = false
 * @property {EvaluationAssignment[]} [assignEvaluations]
 * @property {MeteredEvaluationAssignment[]} [assignMeteredEvaluations]
 * @property {MeteredAssignmentByAgent[]} [assignMeteredAssignmentByAgent]
 * @property {CalibrationAssignment[]} [assignCalibrations]
 * @property {SurveyAssignment[]} [assignSurveys]
 * @property {RetentionDuration} [retentionDuration]
 * @property {InitiateScreenRecording} [initiateScreenRecording]
 * @property {MediaTranscription[]} [mediaTranscriptions]
 * @property {IntegrationExport} [integrationExport] - Policy action for exporting recordings using an integration to 3rd party s3.
 */
 
/**
 * @typedef {object} PolicyConditions
 * @property {User[]} [forUsers]
 * @property {string[]} [directions]
 * @property {string[]} [dateRanges]
 * @property {string[]} [mediaTypes]
 * @property {Queue[]} [forQueues]
 * @property {DurationCondition} [duration]
 * @property {WrapupCode[]} [wrapupCodes]
 * @property {TimeAllowed} [timeAllowed]
 * @property {Team[]} [teams] - Teams to match conversations against
 * @property {string} [customerParticipation] - This condition is to filter out conversation with and without customer participation.
 */
 
/**
 * @typedef {object} PolicyCreate
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The policy name.
 * @property {string} [modifiedDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [createdDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {number} [order]
 * @property {string} [description]
 * @property {boolean} [enabled]
 * @property {MediaPolicies} [mediaPolicies] - Conditions and actions per media type
 * @property {PolicyConditions} [conditions] - Conditions
 * @property {PolicyActions} [actions] - Actions
 * @property {PolicyErrors} [policyErrors]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} PolicyErrorMessage
 * @property {number} [statusCode]
 * @property {object} [userMessage]
 * @property {string} [userParamsMessage]
 * @property {string} [errorCode]
 * @property {string} [correlationId]
 * @property {UserParam[]} [userParams]
 * @property {string} [insertDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 */
 
/**
 * @typedef {object} PolicyErrors
 * @property {PolicyErrorMessage[]} [policyErrorMessages]
 */
 
/**
 * @typedef {object} PolicyUpdate
 * @property {boolean} [enabled]
 */
 
/**
 * @typedef {object} PresenceDefinition
 * @property {string} [id] - description
 * @property {string} [systemPresence]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} PublishedSurveyFormReference
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [contextId] - The context id of this form.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} QuestionGroupSettings
 * @property {string} [questionGroupContextId] - The context id of the question group in the form.
 * @property {QuestionSettings[]} [questionSettings]
 */
 
/**
 * @typedef {object} QuestionSettings
 * @property {string} [questionContextId] - The context id of the question in the group
 * @property {AiScoringSetting} [settings]
 */
 
/**
 * @typedef {object} Queue
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {Division} [division] - The division to which this entity belongs.
 * @property {string} [description] - The queue description.
 * @property {string} [dateCreated] - The date the queue was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateModified] - The date of the last modification to the queue. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [modifiedBy] - The ID of the user that last modified the queue.
 * @property {string} [createdBy] - The ID of the user that created the queue.
 * @property {number} [memberCount] - The total number of members in the queue.
 * @property {number} [userMemberCount] - The number of user members (i.e., non-group members) in the queue.
 * @property {number} [joinedMemberCount] - The number of joined members in the queue.
 * @property {QueueMediaSettings} [mediaSettings] - The media settings for the queue.
 * @property {RoutingRule[]} [routingRules] - The routing rules for the queue, used for Preferred Agent Routing.
 * @property {ConditionalGroupRouting} [conditionalGroupRouting] - The Conditional Group Routing settings for the queue.
 * @property {Bullseye} [bullseye] - The bullseye settings for the queue.
 * @property {string} [scoringMethod] - The Scoring Method for the queue.
 * @property {string} [lastAgentRoutingMode] - The Last Agent Routing Mode for the queue.
 * @property {AcwSettings} [acwSettings] - The ACW settings for the queue.
 * @property {string} [skillEvaluationMethod] - The skill evaluation method to use when routing conversations.
 * @property {MemberGroup[]} [memberGroups] - The groups of agents associated with the queue, if any.  Queue membership will update to match group membership changes.
 * @property {DomainEntityRef} [queueFlow] - The in-queue flow to use for call conversations waiting in queue.
 * @property {DomainEntityRef} [emailInQueueFlow] - The in-queue flow to use for email conversations waiting in queue.
 * @property {DomainEntityRef} [messageInQueueFlow] - The in-queue flow to use for message conversations waiting in queue.
 * @property {DomainEntityRef} [whisperPrompt] - The prompt used for whisper on the queue, if configured.
 * @property {DomainEntityRef} [onHoldPrompt] - The audio to be played when calls on this queue are on hold. If not configured, the default on-hold music will play.
 * @property {boolean} [autoAnswerOnly] - Specifies whether the configured whisper should play for all ACD calls, or only for those which are auto-answered.
 * @property {CannedResponseLibraries} [cannedResponseLibraries] - Canned response library IDs and mode with which they are associated with the queue
 * @property {boolean} [enableTranscription] - Indicates whether voice transcription is enabled for this queue.
 * @property {boolean} [enableAudioMonitoring] - Indicates whether audio monitoring is enabled for this queue.
 * @property {boolean} [enableManualAssignment] - Indicates whether manual assignment is enabled for this queue.
 * @property {AgentOwnedRouting} [agentOwnedRouting] - The Agent Owned Routing settings for the queue
 * @property {DirectRouting} [directRouting] - The Direct Routing settings for the queue
 * @property {string} [callingPartyName] - The name to use for caller identification for outbound calls from this queue.
 * @property {string} [callingPartyNumber] - The phone number to use for caller identification for outbound calls from this queue.
 * @property {object} [defaultScripts] - The default script Ids for the communication types.
 * @property {QueueMessagingAddresses} [outboundMessagingAddresses] - The messaging addresses for the queue.
 * @property {QueueEmailAddress} [outboundEmailAddress] - The default email address to use for outbound email from this queue.
 * @property {string} [peerId] - The ID of an associated external queue.
 * @property {boolean} [suppressInQueueCallRecording] - Indicates whether recording in-queue calls is suppressed for this queue.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} QueueEmailAddress
 * @property {DomainEntityRef} [domain]
 * @property {InboundRoute} [route]
 */
 
/**
 * @typedef {object} QueueMediaSettings
 * @property {MediaSettings} [call] - The queue media settings for call interactions.
 * @property {CallbackMediaSettings} [callback] - The queue media settings for callback interactions.
 * @property {MediaSettings} [chat] - The queue media settings for chat interactions.
 * @property {EmailMediaSettings} [email] - The queue media settings for email interactions.
 * @property {MessageMediaSettings} [message] - The queue media settings for message interactions.
 */
 
/**
 * @typedef {object} QueueMessagingAddresses
 * @property {DomainEntityRef} [smsAddress]
 * @property {DomainEntityRef} [openMessagingRecipient]
 * @property {DomainEntityRef} [whatsAppRecipient]
 */
 
/**
 * @typedef {object} QuickReply
 * @property {string} [text] - Text to show inside the quick reply. This is also used as the response text after clicking on the quick reply.
 * @property {string} [payload] - Content of the textback payload after clicking a quick reply
 * @property {string} [url] - The location of the image file associated with quick reply
 * @property {string} [action] - Specifies the type of action that is triggered upon clicking the quick reply. Currently, the only supported action is "Message" which sends a message using the quick reply text.
 * @property {boolean} [isSelected] - Indicates if the quick reply option is selected by end customer
 */
 
/**
 * @typedef {object} Recording
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [conversationId]
 * @property {string} [path]
 * @property {string} [startTime] - The start time of the recording. Null when there is no playable media.
 * @property {string} [endTime] - The end time of the recording. Null when there is no playable media.
 * @property {string} [media] - The media type of the recording. This could be audio, chat, messaging, email, or screen.
 * @property {string} [mediaSubtype] - The media subtype of the recording.
 * @property {string} [mediaSubject] - The media subject of the recording.
 * @property {Annotation[]} [annotations] - Annotations that belong to the recording.
 * @property {ChatMessage[]} [transcript] - Represents a chat transcript
 * @property {RecordingEmailMessage[]} [emailTranscript] - Represents an email transcript
 * @property {RecordingMessagingMessage[]} [messagingTranscript] - Represents a messaging transcript
 * @property {string} [fileState] - Represents the current file state for a recording. Examples: Uploading, Archived, etc
 * @property {string} [restoreExpirationTime] - The amount of time a restored recording will remain restored before being archived again. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {object} [mediaUris] - The different mediaUris for the recording. Null when there is no playable media.
 * @property {number} [estimatedTranscodeTimeMs]
 * @property {number} [actualTranscodeTimeMs]
 * @property {string} [archiveDate] - The date the recording will be archived. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [archiveMedium] - The type of archive medium used. Example: CloudArchive
 * @property {string} [deleteDate] - The date the recording will be deleted. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [exportDate] - The date the recording will be exported. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [exportedDate] - The date the recording was exported. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {number} [outputDurationMs] - Duration of transcoded media in milliseconds
 * @property {number} [outputSizeInBytes] - Size of transcoded media in bytes. 0 if there is no transcoded media.
 * @property {number} [maxAllowedRestorationsForOrg] - How many archive restorations the organization is allowed to have.
 * @property {number} [remainingRestorationsAllowedForOrg] - The remaining archive restorations the organization has.
 * @property {string} [sessionId] - The session id represents an external resource id, such as email, call, chat, etc
 * @property {User[]} [users] - The users participating in the conversation
 * @property {string} [recordingFileRole] - Role of the file recording. It can be either customer_experience or adhoc.
 * @property {string} [recordingErrorStatus] - Status of a recording that cannot be returned because of an error
 * @property {string} [originalRecordingStartTime] - The start time of the full recording, before any segment access restrictions are applied. Null when there is no playable media. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [creationTime] - The creation time of the recording. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} RecordingAttachment
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [mediaType] - The type of attachment this instance represents.
 * @property {string} [url] - URL of the attachment.
 * @property {string} [mime] - Attachment mime type.
 * @property {string} [text] - Text associated with attachment such as an image caption.
 * @property {string} [fileName] - Suggested file name for attachment.
 */
 
/**
 * Story object.
 * @typedef {object} RecordingContentStory
 * @property {string} [type] - Type of ephemeral story attachment.
 * @property {string} [url] - URL to the ephemeral story.
 * @property {string} [replyToId] - ID of the ephemeral story being replied to.
 */
 
/**
 * @typedef {object} RecordingEmailMessage
 * @property {string} [htmlBody]
 * @property {string} [textBody]
 * @property {string} [id]
 * @property {EmailAddress[]} [to]
 * @property {EmailAddress[]} [cc]
 * @property {EmailAddress[]} [bcc]
 * @property {EmailAddress} [from]
 * @property {string} [subject]
 * @property {EmailAttachment[]} [attachments]
 * @property {string} [time] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 */
 
/**
 * @typedef {object} RecordingEncryptionConfiguration
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} url - When keyConfigurationType is LocalKeyManager, this should be the url for decryption and must specify the path to where GenesysCloud can requests decryption. When keyConfigurationType is KmsSymmetric, this should be the arn to the key alias for the master key
 * @property {string} [apiId] - The api id for Hawk Authentication. Null if keyConfigurationType is KmsSymmetric
 * @property {string} [apiKey] - The api shared symmetric key used for hawk authentication. Null if keyConfigurationType is KmsSymmetric
 * @property {string} keyConfigurationType - Type should be LocalKeyManager or KmsSymmetric when create or update Key configurations; 'Native' for disabling configuration.
 * @property {ErrorBody} [lastError] - The error message related to the configuration
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} RecordingJobsQuery
 * @property {string} action - Operation to perform bulk task. If the operation will cause the delete date of a recording to be older than the export date, the export date will be adjusted to the delete date.
 * @property {string} [actionDate] - The date when the action will be performed. If screenRecordingActionDate is also provided, this value is only used for non-screen recordings. Otherwise this value is used for all recordings. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {number} [actionAge] - The number of days after each recording's creation date when the action will be performed. If screenRecordingActionAge is also provided, this value is only used for non-screen recordings. Otherwise this value is used for all recordings.
 * @property {string} [screenRecordingActionDate] - The date when the action will be performed for screen recordings. If this is provided then includeScreenRecordings must be true. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {number} [screenRecordingActionAge] - The number of days after each screen recording's creation date when the action will be performed. If this is provided then includeScreenRecordings must be true.
 * @property {string} [integrationId] - IntegrationId to Access AWS S3 bucket for bulk recording exports. This field is required and used only for EXPORT action.
 * @property {boolean} [includeRecordingsWithSensitiveData] - Whether to include recordings with PCI DSS and/or PII data, default value = false 
 * @property {boolean} [includeScreenRecordings] - Whether to include Screen recordings for the action, default value = true 
 * @property {boolean} [clearExport] - For DELETE action, setting this to true will clear any pending exports for recordings. This field is only used for DELETE action. Default value = false
 * @property {AsyncConversationQuery} [conversationQuery] - Conversation Query. Note: After the recording is created, it might take up to 48 hours for the recording to be included in the submitted job query.  This result depends on the analytics data lake job completion. See also: https://developer.genesys.cloud/analyticsdatamanagement/analytics/jobs/conversation-details-job#data-availability.This is supported only when querying for conversations up to and including 5 years old.
 * @property {string} [agedConversationInterval] - As an alternative to conversationQuery, specify the date and time range of conversations that are older than 5 years to query.Results will include all conversations that had activity during the interval. This is supported only when querying for conversations older than 5 years;conversationQuery must not be provided when this is provided. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss.Interval duration must not exceed 6 months. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 */
 
/**
 * @typedef {object} RecordingMessagingMessage
 * @property {string} [from] - The message sender session id.
 * @property {User} [fromUser] - The user who sent this message.
 * @property {ExternalContact} [fromExternalContact] - The PureCloud external contact sender details.
 * @property {string} [to] - The message recipient.
 * @property {string} [timestamp] - The time when the message was sent. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [id] - A globally unique identifier for this communication.
 * @property {string} [purpose] - A well known string that specifies the purpose or type of the participant on this communication.
 * @property {string} [participantId] - A globally unique identifier for the participant on this communication.
 * @property {AddressableEntityRef} [queue] - A globally unique identifier for the queue involved in this communication.
 * @property {AddressableEntityRef} [workflow] - A globally unique identifier for the workflow involved in this communication.
 * @property {string} [messageText] - The content of this message.
 * @property {MessageMediaAttachment[]} [messageMediaAttachments] - List of media objects attached  with this message.
 * @property {MessageStickerAttachment[]} [messageStickerAttachments] - List of message stickers attached with this message.
 * @property {QuickReply[]} [quickReplies] - List of quick reply options offered with this message.
 * @property {ButtonResponse} [buttonResponse] - Button Response selected by user for this message.
 * @property {RecordingContentStory} [story] - Ephemeral story content.
 * @property {Card[]} [cards] - List of cards offered for this message
 * @property {RecordingNotificationTemplate} [notificationTemplate] - Template notification content.
 * @property {string} [contentType] - Indicates the content type for this message
 * @property {ConversationMessageEvent[]} [events] - List of event elements
 */
 
/**
 * @typedef {object} RecordingNotificationTemplate
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [language] - Template language.
 * @property {RecordingTemplateHeader} [header] - The template header.
 * @property {RecordingTemplateBody} [body] - The template body.
 * @property {RecordingTemplateButton[]} [buttons] - Template buttons
 * @property {RecordingTemplateFooter} [footer] - The template footer.
 */
 
/**
 * @typedef {object} RecordingSettings
 * @property {number} [maxSimultaneousStreams] - Maximum number of simultaneous screen recording streams
 * @property {number} [maxConfigurableScreenRecordingStreams] - Upper limit that maxSimultaneousStreams can be configured
 * @property {boolean} [regionalRecordingStorageEnabled] - Store call recordings in the region where they are intended to be recorded, otherwise in the organization's home region
 * @property {number} [recordingPlaybackUrlTtl] - The duration in minutes for which the generated URL for recording playback remains valid.The default duration is set to 60 minutes, with a minimum allowable duration of 2 minutes and a maximum of 60 minutes.
 * @property {number} [recordingBatchDownloadUrlTtl] - The duration in minutes for which the generated URL for recording batch download remains valid.The default duration is set to 60 minutes, with a minimum allowable duration of 2 minutes and a maximum of 60 minutes.
 */
 
/**
 * @typedef {object} RecordingTemplateBody
 * @property {string} [text] - Template parameters for placeholders in template.
 */
 
/**
 * @typedef {object} RecordingTemplateButton
 * @property {string} [type] - Specifies the type of the button.
 * @property {string} [text] - Button text message.
 * @property {number} [index] - Index of the button in the list.
 * @property {string} [phoneNumber] - Button phone number.
 * @property {string} [url] - Button URL link.
 * @property {boolean} [isSelected] - Indicates if the button is selected by end customer.
 */
 
/**
 * @typedef {object} RecordingTemplateFooter
 * @property {string} [text] - Footer text.
 */
 
/**
 * @typedef {object} RecordingTemplateHeader
 * @property {string} [type] - Template header type.
 * @property {string} [text] - Header text.
 * @property {RecordingAttachment} [media] - Media template header image.
 */
 
/**
 * @typedef {object} RecordingUploadReportRequest
 * @property {string} dateSince - Report will include uploads since this date. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [uploadStatus] - Report will include uploads with this status
 */
 
/**
 * @typedef {object} ResolutionDetailQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {ResolutionDetailQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ResolutionDetailQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {ResolutionDetailQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {ResolutionDetailQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ResolutionDetailQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [metric] - Left hand side for metric predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for metric predicates
 * @property {NumericRange} [range] - Right hand side for metric predicates
 */
 
/**
 * @typedef {object} ResourceConditionNode
 * @property {string} [variableName]
 * @property {string} [conjunction]
 * @property {string} [operator]
 * @property {ResourceConditionValue[]} [operands]
 * @property {ResourceConditionNode[]} [terms]
 */
 
/**
 * @typedef {object} ResourceConditionValue
 * @property {string} [type]
 * @property {string} [value]
 */
 
/**
 * @typedef {object} ResourcePermissionPolicy
 * @property {string} [id]
 * @property {string} [domain]
 * @property {string} [entityName]
 * @property {string} [policyName]
 * @property {string} [policyDescription]
 * @property {string} [actionSetKey]
 * @property {boolean} [allowConditions]
 * @property {ResourceConditionNode} [resourceConditionNode]
 * @property {string[]} [namedResources]
 * @property {string} [resourceCondition]
 * @property {string[]} [actionSet]
 */
 
/**
 * @typedef {object} RetentionDuration
 * @property {ArchiveRetention} [archiveRetention]
 * @property {DeleteRetention} [deleteRetention]
 */
 
/**
 * @typedef {object} Ring
 * @property {ExpansionCriterium[]} [expansionCriteria] - The conditions that will trigger conversations to move to the next bullseye ring.
 * @property {Actions} [actions] - The actions that will be performed just before moving conversations to the next bullseye ring.
 * @property {MemberGroup[]} [memberGroups] - The groups of agents associated with the ring, if any.  Ring membership will update to match group membership changes.
 */
 
/**
 * @typedef {object} RoutingRule
 * @property {string} [operator] - matching operator.  MEETS_THRESHOLD matches any agent with a score at or above the rule's threshold.  ANY matches all specified agents, regardless of score.
 * @property {number} [threshold] - threshold required for routing attempt (generally an agent score).  may be null for operator ANY.
 * @property {number} [waitSeconds] - seconds to wait in this rule before moving to the next
 */
 
/**
 * @typedef {object} RoutingStatus
 * @property {string} [userId] - The userId of the agent
 * @property {string} [status] - Indicates the Routing State of the agent.  A value of OFF_QUEUE will be returned if the specified user does not exist.
 * @property {string} [startTime] - The timestamp when the agent went into this state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 */
 
/**
 * @typedef {object} ScreenRecordingMetaData
 * @property {string} [trackId]
 * @property {string} [mediaId]
 * @property {string} [screenId]
 * @property {number} [originX]
 * @property {number} [originY]
 * @property {boolean} [primary]
 * @property {boolean} [main]
 */
 
/**
 * @typedef {object} ScreenRecordingMetaDataRequest
 * @property {string} [participantJid]
 * @property {string} [roomId]
 * @property {ScreenRecordingMetaData[]} [metaData]
 */
 
/**
 * @typedef {object} SegmentDetailQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {SegmentDetailQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} SegmentDetailQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {SegmentDetailQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {SegmentDetailQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} SegmentDetailQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [propertyType] - Left hand side for property predicates
 * @property {string} [property] - Left hand side for property predicates
 * @property {string} [metric] - Left hand side for metric predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension, metric, or property predicates
 * @property {NumericRange} [range] - Right hand side for dimension, metric, or property predicates
 */
 
/**
 * @typedef {object} ServiceLevel
 * @property {number} [percentage] - The desired Service Level. A value between 0 and 1.
 * @property {number} [durationMs] - Service Level target in milliseconds.
 */
 
/**
 * @typedef {object} Signature
 * @property {boolean} [enabled] - A toggle to enable the signature on email send.
 * @property {string} [cannedResponseId] - The identifier referring to an email signature canned response.
 * @property {boolean} [alwaysIncluded] - A toggle that defines if a signature is always included or only set on the first email in an email chain.
 * @property {string} [inclusionType] - The configuration to indicate when the signature of a conversation has to be included
 */
 
/**
 * @typedef {object} SkillsToRemove
 * @property {string} [name]
 * @property {string} [id]
 * @property {string} [selfUri]
 */
 
/**
 * @typedef {object} StarrableDivision
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} SurveyAssignment
 * @property {PublishedSurveyFormReference} [surveyForm] - The survey form used for this survey.
 * @property {DomainEntityRef} [flow] - The URI reference to the flow associated with this survey.
 * @property {string} [inviteTimeInterval] - An ISO 8601 repeated interval consisting of the number of repetitions, the start datetime, and the interval (e.g. R2/2018-03-01T13:00:00Z/P1M10DT2H30M). Total duration must not exceed 90 days.
 * @property {string} [sendingUser] - User together with sendingDomain used to send email, null to use no-reply
 * @property {string} sendingDomain - Validated email domain, required
 */
 
/**
 * @typedef {object} SurveyDetailQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {SurveyDetailQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} SurveyDetailQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {SurveyDetailQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {SurveyDetailQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} SurveyDetailQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [metric] - Left hand side for metric predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension or metric predicates
 * @property {NumericRange} [range] - Right hand side for dimension or metric predicates
 */
 
/**
 * @typedef {object} Team
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The team name
 * @property {WritableDivision} [division] - The division to which this entity belongs.
 * @property {string} [description] - Team information.
 * @property {string} [dateCreated] - Last modified datetime. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateModified] - Last modified datetime. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {number} [memberCount] - Number of members in a team
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} Ticker
 * @property {string} symbol - The ticker symbol for this organization. Example: ININ, AAPL, MSFT, etc.
 * @property {string} exchange - The exchange for this ticker symbol. Examples: NYSE, FTSE, NASDAQ, etc.
 */
 
/**
 * @typedef {object} TimeAllowed
 * @property {TimeSlot[]} [timeSlots]
 * @property {string} [timeZoneId]
 * @property {boolean} [empty]
 */
 
/**
 * @typedef {object} TimeInterval
 * @property {number} [months]
 * @property {number} [weeks]
 * @property {number} [days]
 * @property {number} [hours]
 */
 
/**
 * @typedef {object} TimeSlot
 * @property {string} [startTime] - start time in xx:xx:xx.xxx format
 * @property {string} [stopTime] - stop time in xx:xx:xx.xxx format
 * @property {number} [day] - Day for this time slot, Monday = 1 ... Sunday = 7
 */
 
/**
 * @typedef {object} TrusteeAuthorization
 * @property {string[]} [permissions] - Permissions that the trustee user has in the trustor organization
 */
 
/**
 * @typedef {object} Trustor
 * @property {string} [id] - Organization Id for this trust.
 * @property {boolean} enabled - If disabled no trustee user will have access, even if they were previously added.
 * @property {string} [dateCreated] - Date Trust was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {OrgUser} [createdBy] - User that created trust.
 * @property {Organization} [organization] - Organization associated with this trust.
 * @property {TrusteeAuthorization} [authorization] - Authorization for the trustee user has in this trustor organization
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * User information for a twitter account
 * @typedef {object} TwitterId
 * @property {string} [id] - twitter user.id_str
 * @property {string} [name] - twitter user.name
 * @property {string} [screenName] - twitter user.screen_name
 * @property {boolean} [verified] - whether this data has been verified using the twitter API
 * @property {string} [profileUrl] - url of user's twitter profile
 */
 
/**
 * @typedef {object} User
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {Division} [division] - The division to which this entity belongs.
 * @property {Chat} [chat]
 * @property {string} [department]
 * @property {string} [email]
 * @property {Contact[]} [primaryContactInfo] - Auto populated from addresses.
 * @property {Contact[]} [addresses] - Email addresses and phone numbers for this user
 * @property {string} [state] - The current state for this user.
 * @property {string} [title]
 * @property {string} [username]
 * @property {User} [manager]
 * @property {Image[]} [images]
 * @property {number} version - Required when updating a user, this value should be the current version of the user.  The current version can be obtained with a GET on the user before doing a PATCH.
 * @property {string[]} [certifications]
 * @property {Biography} [biography]
 * @property {EmployerInfo} [employerInfo]
 * @property {string} [preferredName] - Preferred full name of the agent
 * @property {RoutingStatus} [routingStatus] - ACD routing status
 * @property {UserPresence} [presence] - Active presence
 * @property {UserPresence} [integrationPresence] - Integration presence
 * @property {UserConversationSummary} [conversationSummary] - Summary of conversion statistics for conversation types.
 * @property {OutOfOffice} [outOfOffice] - Determine if out of office is enabled
 * @property {Geolocation} [geolocation] - Current geolocation position
 * @property {UserStations} [station] - Effective, default, and last station information
 * @property {UserAuthorization} [authorization] - Roles and permissions assigned to the user
 * @property {string[]} [profileSkills] - Profile skills possessed by the user
 * @property {Location[]} [locations] - The user placement at each site location.
 * @property {Group[]} [groups] - The groups the user is a member of
 * @property {Team} [team] - The team the user is a member of
 * @property {WorkPlanBidRanks} [workPlanBidRanks] - The WFM work plan bid rank settings for the user
 * @property {UserRoutingSkill[]} [skills] - Routing (ACD) skills possessed by the user
 * @property {UserRoutingLanguage[]} [languages] - Routing (ACD) languages possessed by the user
 * @property {boolean} [acdAutoAnswer] - acd auto answer
 * @property {string} [languagePreference] - preferred language by the user
 * @property {OAuthLastTokenIssued} [lastTokenIssued]
 * @property {string} [dateLastLogin] - The last time the user logged in using username and password. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateWelcomeSent] - The date & time the user was sent their welcome email. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} UserAuthorization
 * @property {DomainRole[]} [roles]
 * @property {DomainRole[]} [unusedRoles] - A collection of the roles the user is not using
 * @property {string[]} [permissions] - A collection of the permissions granted by all assigned roles
 * @property {ResourcePermissionPolicy[]} [permissionPolicies] - The policies configured for assigned permissions.
 */
 
/**
 * @typedef {object} UserConversationSummary
 * @property {string} [userId]
 * @property {MediaSummary} [call]
 * @property {MediaSummary} [callback]
 * @property {MediaSummary} [email]
 * @property {MediaSummary} [message]
 * @property {MediaSummary} [chat]
 * @property {MediaSummary} [socialExpression]
 * @property {MediaSummary} [video]
 */
 
/**
 * @typedef {object} UserParam
 * @property {string} [key]
 * @property {string} [value]
 */
 
/**
 * @typedef {object} UserPresence
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [source] - Deprecated - The sourceID field should be used as a replacement.
 * @property {string} [sourceId] - Represents the ID of a registered source
 * @property {boolean} [primary] - A boolean used to tell whether or not to set this presence source as the primary on a PATCH
 * @property {PresenceDefinition} [presenceDefinition]
 * @property {string} [message]
 * @property {string} [modifiedDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} UserReferenceWithName
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * Represents an organization language assigned to a user. When assigning to a user specify the organization language id as the id.
 * @typedef {object} UserRoutingLanguage
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {number} [proficiency] - A rating from 0.0 to 5.0 that indicates how fluent an agent is in a particular language. ACD interactions are routed to agents with higher proficiency ratings.
 * @property {string} [state] - Activate or deactivate this routing language.
 * @property {string} [languageUri] - URI to the organization language used by this user language.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * Represents an organization skill assigned to a user. When assigning to a user specify the organization skill id as the id.
 * @typedef {object} UserRoutingSkill
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {number} [proficiency] - A rating from 0.0 to 5.0 that indicates how adept an agent is at a particular skill. When "Best available skills" is enabled for a queue in Genesys Cloud, ACD interactions in that queue are routed to agents with higher proficiency ratings.
 * @property {string} [state] - Activate or deactivate this routing skill.
 * @property {string} [skillUri] - URI to the organization skill used by this user skill.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} UserStation
 * @property {string} [id] - A globally unique identifier for this station
 * @property {string} [name]
 * @property {string} [type]
 * @property {User} [associatedUser]
 * @property {string} [associatedDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {User} [defaultUser]
 * @property {object} [providerInfo] - Provider-specific info for this station, e.g. { "edgeGroupId": "ffe7b15c-a9cc-4f4c-88f5-781327819a49" }
 * @property {number} [webRtcCallAppearances] - The number of call appearances on the station.
 */
 
/**
 * @typedef {object} UserStations
 * @property {UserStation} [associatedStation] - Current associated station for this user.
 * @property {UserStation} [effectiveStation] - The station where the user can be reached based on their default and associated station.
 * @property {UserStation} [defaultStation] - Default station to be used if not associated with a station.
 * @property {UserStation} [lastAssociatedStation] - Last associated station for this user.
 */
 
/**
 * @typedef {object} VisibilityCondition
 * @property {string} [combiningOperation]
 * @property {object[]} [predicates] - A list of strings, each representing the location in the form of the Answer Option to depend on. In the format of "/form/questionGroup/{questionGroupIndex}/question/{questionIndex}/answer/{answerIndex}" or, to assume the current question group, "../question/{questionIndex}/answer/{answerIndex}". Note: Indexes are zero-based
 */
 
/**
 * User information for a WhatsApp account
 * @typedef {object} WhatsAppId
 * @property {PhoneNumber} [phoneNumber] - The phone number associated with this WhatsApp account
 * @property {string} [displayName] - The displayName of this person's account in WhatsApp
 */
 
/**
 * @typedef {object} WorkPlanBidRanks
 * @property {string} [id] - The globally unique identifier for the user.
 * @property {number} [workPlanBiddingPerformance] - Work plan bidding agent performance ranking. The range of values is between 0 and 9999.
 * @property {string} [biddingTieBreaker] - Custom agent ranking metric that some customers can use.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} WrapupCode
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The wrap-up code name.
 * @property {StarrableDivision} [division] - The division to which this entity belongs.
 * @property {string} [description] - The wrap-up code description.
 * @property {string} [dateCreated] - Date when the wrap-up code was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateModified] - Date when the wrap-up code was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [createdBy] - The ID of the user that created the wrap-up code.
 * @property {string} [modifiedBy] - The ID of the user that modified the wrap-up code.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} WritableDivision
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} WritableStarrableDivision
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [selfUri] - The URI for this object
 */
 

/**
 * Recording - Recordings, policies, annotations, orphans
 * @class Recording
 */
class RecordingAPI {
	// Private instance properties
	#gcPlatformAPIClient = null;

	/**
	 * Constructor for the Recording class
	 * @constructor
	 * @param {GCPlatformAPIClient} gcPlatformAPIClient - The Genesys Cloud Platform API client instance.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_INSTANCE_TYPE_INVALID} If the Genesys Cloud Platform API client instance argument is not an object.
	 */
	constructor(gcPlatformAPIClient) {
		// Check the Genesys Cloud Platform API client instance argument
		if (typeof gcPlatformAPIClient !== "object" || symbols.GCPlatformAPIClient in gcPlatformAPIClient === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_INSTANCE_TYPE_INVALID();
		}

		// Initialize the instance properties
		this.#gcPlatformAPIClient = gcPlatformAPIClient;
	}

	/**
	 * Gets media retention policy list with query options to filter on name and enabled.
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  The total page size requested
	 * @param {number} [query.pageNumber] -  The page number requested
	 * @param {string} [query.sortBy] -  variable name requested to sort by
	 * @param {string[]} [query.expand] -  variable name requested by expand list
	 * @param {string} [query.nextPage] -  next page token
	 * @param {string} [query.previousPage] -  Previous page token
	 * @param {string} [query.name] -  the policy name - used for filtering results in searches.
	 * @param {boolean} [query.enabled] -  checks to see if policy is enabled - use enabled = true or enabled = false
	 * @param {boolean} [query.summary] -  provides a less verbose response of policy lists.
	 * @param {boolean} [query.hasErrors] -  provides a way to fetch all policies with errors or policies that do not have errors
	 * @param {number} [query.deleteDaysThreshold] -  provides a way to fetch all policies with any actions having deleteDays exceeding the provided value
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/crossplatform/mediaretentionpolicies" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRecordingCrossplatformMediaretentionpolicies(query) {
		const endpointPath = "/api/v2/recording/crossplatform/mediaretentionpolicies";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("sortBy" in query && this.#checkJSONSchemaType(query["sortBy"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortBy", "string");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "array");
			}
			if ("nextPage" in query && this.#checkJSONSchemaType(query["nextPage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "nextPage", "string");
			}
			if ("previousPage" in query && this.#checkJSONSchemaType(query["previousPage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "previousPage", "string");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
			if ("enabled" in query && this.#checkJSONSchemaType(query["enabled"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "enabled", "boolean");
			}
			if ("summary" in query && this.#checkJSONSchemaType(query["summary"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "summary", "boolean");
			}
			if ("hasErrors" in query && this.#checkJSONSchemaType(query["hasErrors"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "hasErrors", "boolean");
			}
			if ("deleteDaysThreshold" in query && this.#checkJSONSchemaType(query["deleteDaysThreshold"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "deleteDaysThreshold", "integer");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create media retention policy
	 * @async
	 * @param {CrossPlatformPolicyCreate} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/crossplatform/mediaretentionpolicies" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRecordingCrossplatformMediaretentionpolicies(body) {
		const endpointPath = "/api/v2/recording/crossplatform/mediaretentionpolicies";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete media retention policies
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} query.ids -  
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/crossplatform/mediaretentionpolicies" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING} If a required query string parameter is missing.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	deleteRecordingCrossplatformMediaretentionpolicies(query) {
		const endpointPath = "/api/v2/recording/crossplatform/mediaretentionpolicies";
		const endpointMethod = "DELETE";

		// Check the query string parameters
		if (typeof query !== "object" || query === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, true);
		}

		if ("ids" in query === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING(endpointPath, endpointMethod, "ids");
		}

		if (this.#checkJSONSchemaType(query["ids"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "ids", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a media retention policy
	 * @async
	 * @param {string} policyId - Policy ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/crossplatform/mediaretentionpolicies/{policyId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRecordingCrossplatformMediaretentionpolicy(policyId) {
		const endpointPath = "/api/v2/recording/crossplatform/mediaretentionpolicies/{policyId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(policyId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "policyId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.policyId = policyId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a media retention policy
	 * @async
	 * @param {string} policyId - Policy ID
	 * @param {CrossPlatformPolicy} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/crossplatform/mediaretentionpolicies/{policyId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putRecordingCrossplatformMediaretentionpolicy(policyId, body) {
		const endpointPath = "/api/v2/recording/crossplatform/mediaretentionpolicies/{policyId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(policyId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "policyId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.policyId = policyId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a media retention policy
	 * @async
	 * @param {string} policyId - Policy ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/crossplatform/mediaretentionpolicies/{policyId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteRecordingCrossplatformMediaretentionpolicy(policyId) {
		const endpointPath = "/api/v2/recording/crossplatform/mediaretentionpolicies/{policyId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(policyId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "policyId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.policyId = policyId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Patch a media retention policy
	 * @async
	 * @param {string} policyId - Policy ID
	 * @param {CrossPlatformPolicyUpdate} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/crossplatform/mediaretentionpolicies/{policyId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchRecordingCrossplatformMediaretentionpolicy(policyId, body) {
		const endpointPath = "/api/v2/recording/crossplatform/mediaretentionpolicies/{policyId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(policyId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "policyId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.policyId = policyId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Gets media retention policy list with query options to filter on name and enabled.
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  The total page size requested
	 * @param {number} [query.pageNumber] -  The page number requested
	 * @param {string} [query.sortBy] -  variable name requested to sort by
	 * @param {string[]} [query.expand] -  variable name requested by expand list
	 * @param {string} [query.nextPage] -  next page token
	 * @param {string} [query.previousPage] -  Previous page token
	 * @param {string} [query.name] -  the policy name - used for filtering results in searches.
	 * @param {boolean} [query.enabled] -  checks to see if policy is enabled - use enabled = true or enabled = false
	 * @param {boolean} [query.summary] -  provides a less verbose response of policy lists.
	 * @param {boolean} [query.hasErrors] -  provides a way to fetch all policies with errors or policies that do not have errors
	 * @param {number} [query.deleteDaysThreshold] -  provides a way to fetch all policies with any actions having deleteDays exceeding the provided value
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/mediaretentionpolicies" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRecordingMediaretentionpolicies(query) {
		const endpointPath = "/api/v2/recording/mediaretentionpolicies";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("sortBy" in query && this.#checkJSONSchemaType(query["sortBy"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortBy", "string");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "array");
			}
			if ("nextPage" in query && this.#checkJSONSchemaType(query["nextPage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "nextPage", "string");
			}
			if ("previousPage" in query && this.#checkJSONSchemaType(query["previousPage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "previousPage", "string");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
			if ("enabled" in query && this.#checkJSONSchemaType(query["enabled"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "enabled", "boolean");
			}
			if ("summary" in query && this.#checkJSONSchemaType(query["summary"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "summary", "boolean");
			}
			if ("hasErrors" in query && this.#checkJSONSchemaType(query["hasErrors"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "hasErrors", "boolean");
			}
			if ("deleteDaysThreshold" in query && this.#checkJSONSchemaType(query["deleteDaysThreshold"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "deleteDaysThreshold", "integer");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create media retention policy
	 * @async
	 * @param {PolicyCreate} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/mediaretentionpolicies" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRecordingMediaretentionpolicies(body) {
		const endpointPath = "/api/v2/recording/mediaretentionpolicies";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete media retention policies
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} query.ids -  
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/mediaretentionpolicies" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING} If a required query string parameter is missing.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	deleteRecordingMediaretentionpolicies(query) {
		const endpointPath = "/api/v2/recording/mediaretentionpolicies";
		const endpointMethod = "DELETE";

		// Check the query string parameters
		if (typeof query !== "object" || query === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, true);
		}

		if ("ids" in query === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING(endpointPath, endpointMethod, "ids");
		}

		if (this.#checkJSONSchemaType(query["ids"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "ids", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a media retention policy
	 * @async
	 * @param {string} policyId - Policy ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/mediaretentionpolicies/{policyId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRecordingMediaretentionpolicy(policyId) {
		const endpointPath = "/api/v2/recording/mediaretentionpolicies/{policyId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(policyId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "policyId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.policyId = policyId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a media retention policy
	 * @async
	 * @param {string} policyId - Policy ID
	 * @param {Policy} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/mediaretentionpolicies/{policyId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putRecordingMediaretentionpolicy(policyId, body) {
		const endpointPath = "/api/v2/recording/mediaretentionpolicies/{policyId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(policyId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "policyId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.policyId = policyId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a media retention policy
	 * @async
	 * @param {string} policyId - Policy ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/mediaretentionpolicies/{policyId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteRecordingMediaretentionpolicy(policyId) {
		const endpointPath = "/api/v2/recording/mediaretentionpolicies/{policyId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(policyId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "policyId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.policyId = policyId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Patch a media retention policy
	 * @async
	 * @param {string} policyId - Policy ID
	 * @param {PolicyUpdate} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/mediaretentionpolicies/{policyId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchRecordingMediaretentionpolicy(policyId, body) {
		const endpointPath = "/api/v2/recording/mediaretentionpolicies/{policyId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(policyId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "policyId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.policyId = policyId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get encryption key list
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/recordingkeys" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRecordingRecordingkeys(query) {
		const endpointPath = "/api/v2/recording/recordingkeys";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create encryption key
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/recordingkeys" endpoint.
	 */
	postRecordingRecordingkeys() {
		const endpointPath = "/api/v2/recording/recordingkeys";
		const endpointMethod = "POST";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get key rotation schedule
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/recordingkeys/rotationschedule" endpoint.
	 */
	getRecordingRecordingkeysRotationschedule() {
		const endpointPath = "/api/v2/recording/recordingkeys/rotationschedule";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update key rotation schedule
	 * @async
	 * @param {KeyRotationSchedule} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/recordingkeys/rotationschedule" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putRecordingRecordingkeysRotationschedule(body) {
		const endpointPath = "/api/v2/recording/recordingkeys/rotationschedule";
		const endpointMethod = "PUT";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * create a local key management recording key
	 * @async
	 * @param {LocalEncryptionKeyRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/localkeys" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRecordingLocalkeys(body) {
		const endpointPath = "/api/v2/recording/localkeys";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the encryption key configurations
	 * @async
	 * @param {string} keyConfigurationId - Key Configurations Id
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/keyconfigurations/{keyConfigurationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRecordingKeyconfiguration(keyConfigurationId) {
		const endpointPath = "/api/v2/recording/keyconfigurations/{keyConfigurationId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(keyConfigurationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "keyConfigurationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.keyConfigurationId = keyConfigurationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update the encryption key configurations
	 * @async
	 * @param {string} keyConfigurationId - Key Configurations Id
	 * @param {RecordingEncryptionConfiguration} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/keyconfigurations/{keyConfigurationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putRecordingKeyconfiguration(keyConfigurationId, body) {
		const endpointPath = "/api/v2/recording/keyconfigurations/{keyConfigurationId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(keyConfigurationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "keyConfigurationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.keyConfigurationId = keyConfigurationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a list of key configurations data
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/keyconfigurations" endpoint.
	 */
	getRecordingKeyconfigurations() {
		const endpointPath = "/api/v2/recording/keyconfigurations";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Setup configurations for encryption key creation
	 * @async
	 * @param {RecordingEncryptionConfiguration} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/keyconfigurations" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRecordingKeyconfigurations(body) {
		const endpointPath = "/api/v2/recording/keyconfigurations";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Validate encryption key configurations without saving it
	 * @async
	 * @param {RecordingEncryptionConfiguration} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/keyconfigurations/validate" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRecordingKeyconfigurationsValidate(body) {
		const endpointPath = "/api/v2/recording/keyconfigurations/validate";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the status and results for a batch request job, only the user that submitted the job may retrieve results. Each result may contain either a URL to a recording or an error; additionally, a recording could be associated with multiple results.
	 * @async
	 * @param {string} jobId - jobId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/batchrequests/{jobId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRecordingBatchrequest(jobId) {
		const endpointPath = "/api/v2/recording/batchrequests/{jobId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(jobId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "jobId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.jobId = jobId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Submit a batch download request for recordings. Recordings in response will be in their original format/codec - configured in the Trunk configuration.
	 * @async
	 * @param {BatchDownloadJobSubmission} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/batchrequests" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRecordingBatchrequests(body) {
		const endpointPath = "/api/v2/recording/batchrequests";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a list of conversations with protected recordings
	 * @async
	 * @param {ConversationDeletionProtectionQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recordings/deletionprotection" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRecordingsDeletionprotection(body) {
		const endpointPath = "/api/v2/recordings/deletionprotection";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Apply or revoke recording protection for conversations
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.protect] -  Check for apply, uncheck for revoke (each action requires the respective permission)
	 * @param {ConversationDeletionProtectionQuery} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recordings/deletionprotection" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putRecordingsDeletionprotection(query, body) {
		const endpointPath = "/api/v2/recordings/deletionprotection";
		const endpointMethod = "PUT";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("protect" in query && this.#checkJSONSchemaType(query["protect"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "protect", "boolean");
			}
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Gets the media of a single orphan recording
	 * @async
	 * @param {string} orphanId - Orphan ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.formatId] -  The desired media format.
	 * @param {string} [query.emailFormatId] -  The desired media format when downloading an email recording.
	 * @param {string} [query.chatFormatId] -  The desired media format when downloading a chat recording.
	 * @param {string} [query.messageFormatId] -  The desired media format when downloading a message recording.
	 * @param {boolean} [query.download] -  requesting a download format of the recording
	 * @param {string} [query.fileName] -  the name of the downloaded fileName
	 * @param {string} [query.locale] -  The locale for the requested file when downloading, as an ISO 639-1 code
	 * @param {string[]} [query.mediaFormats] -  All acceptable media formats. Overrides formatId. Valid values:WAV,WEBM,WAV_ULAW,OGG_VORBIS,OGG_OPUS,MP3
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/orphanrecordings/{orphanId}/media" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getOrphanrecordingMedia(orphanId, query) {
		const endpointPath = "/api/v2/orphanrecordings/{orphanId}/media";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(orphanId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "orphanId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("formatId" in query && this.#checkJSONSchemaType(query["formatId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "formatId", "string");
			}
			if ("emailFormatId" in query && this.#checkJSONSchemaType(query["emailFormatId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "emailFormatId", "string");
			}
			if ("chatFormatId" in query && this.#checkJSONSchemaType(query["chatFormatId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "chatFormatId", "string");
			}
			if ("messageFormatId" in query && this.#checkJSONSchemaType(query["messageFormatId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "messageFormatId", "string");
			}
			if ("download" in query && this.#checkJSONSchemaType(query["download"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "download", "boolean");
			}
			if ("fileName" in query && this.#checkJSONSchemaType(query["fileName"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "fileName", "string");
			}
			if ("locale" in query && this.#checkJSONSchemaType(query["locale"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "locale", "string");
			}
			if ("mediaFormats" in query && this.#checkJSONSchemaType(query["mediaFormats"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "mediaFormats", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.orphanId = orphanId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Gets a single orphan recording
	 * @async
	 * @param {string} orphanId - Orphan ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/orphanrecordings/{orphanId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getOrphanrecording(orphanId) {
		const endpointPath = "/api/v2/orphanrecordings/{orphanId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(orphanId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "orphanId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.orphanId = orphanId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Updates an orphan recording to a regular recording with retention values
	 * @async
	 * @param {string} orphanId - Orphan ID
	 * @param {OrphanUpdateRequest} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/orphanrecordings/{orphanId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putOrphanrecording(orphanId, body) {
		const endpointPath = "/api/v2/orphanrecordings/{orphanId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(orphanId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "orphanId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.orphanId = orphanId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Deletes a single orphan recording
	 * @async
	 * @param {string} orphanId - Orphan ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/orphanrecordings/{orphanId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteOrphanrecording(orphanId) {
		const endpointPath = "/api/v2/orphanrecordings/{orphanId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(orphanId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "orphanId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.orphanId = orphanId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Gets all orphan recordings
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  The total page size requested
	 * @param {number} [query.pageNumber] -  The page number requested
	 * @param {string} [query.sortBy] -  variable name requested to sort by
	 * @param {string[]} [query.expand] -  variable name requested by expand list
	 * @param {string} [query.nextPage] -  next page token
	 * @param {string} [query.previousPage] -  Previous page token
	 * @param {boolean} [query.hasConversation] -  Filter resulting orphans by whether the conversation is known. False returns all orphans for the organization.
	 * @param {string} [query.media] -  Filter resulting orphans based on their media type
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/orphanrecordings" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getOrphanrecordings(query) {
		const endpointPath = "/api/v2/orphanrecordings";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("sortBy" in query && this.#checkJSONSchemaType(query["sortBy"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortBy", "string");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "array");
			}
			if ("nextPage" in query && this.#checkJSONSchemaType(query["nextPage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "nextPage", "string");
			}
			if ("previousPage" in query && this.#checkJSONSchemaType(query["previousPage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "previousPage", "string");
			}
			if ("hasConversation" in query && this.#checkJSONSchemaType(query["hasConversation"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "hasConversation", "boolean");
			}
			if ("media" in query && this.#checkJSONSchemaType(query["media"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "media", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get metadata for a specific recording. Does not return playable media.
	 * @async
	 * @param {string} conversationId - Conversation ID
	 * @param {string} recordingId - Recording ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/recordingmetadata/{recordingId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationRecordingmetadataRecordingId(conversationId, recordingId) {
		const endpointPath = "/api/v2/conversations/{conversationId}/recordingmetadata/{recordingId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(recordingId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "recordingId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.recordingId = recordingId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Gets a specific recording.
	 * @async
	 * @param {string} conversationId - Conversation ID
	 * @param {string} recordingId - Recording ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.formatId] -  The desired media format. Valid values:WAV,WEBM,WAV_ULAW,OGG_VORBIS,OGG_OPUS,MP3,NONE
	 * @param {string} [query.emailFormatId] -  The desired media format when downloading an email recording. Valid values:EML,NONE
	 * @param {string} [query.chatFormatId] -  The desired media format when downloading a chat recording. Valid values:ZIP,NONE 
	 * @param {string} [query.messageFormatId] -  The desired media format when downloading a message recording. Valid values:ZIP,NONE
	 * @param {boolean} [query.download] -  requesting a download format of the recording. Valid values:true,false
	 * @param {string} [query.fileName] -  the name of the downloaded fileName
	 * @param {string} [query.locale] -  The locale for the requested file when downloading or for redacting sensitive information in requested files, as an ISO 639-1 code
	 * @param {string[]} [query.mediaFormats] -  All acceptable media formats. Overrides formatId. Valid values:WAV,WEBM,WAV_ULAW,OGG_VORBIS,OGG_OPUS,MP3
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/recordings/{recordingId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationRecording(conversationId, recordingId, query) {
		const endpointPath = "/api/v2/conversations/{conversationId}/recordings/{recordingId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(recordingId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "recordingId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("formatId" in query && this.#checkJSONSchemaType(query["formatId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "formatId", "string");
			}
			if ("emailFormatId" in query && this.#checkJSONSchemaType(query["emailFormatId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "emailFormatId", "string");
			}
			if ("chatFormatId" in query && this.#checkJSONSchemaType(query["chatFormatId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "chatFormatId", "string");
			}
			if ("messageFormatId" in query && this.#checkJSONSchemaType(query["messageFormatId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "messageFormatId", "string");
			}
			if ("download" in query && this.#checkJSONSchemaType(query["download"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "download", "boolean");
			}
			if ("fileName" in query && this.#checkJSONSchemaType(query["fileName"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "fileName", "string");
			}
			if ("locale" in query && this.#checkJSONSchemaType(query["locale"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "locale", "string");
			}
			if ("mediaFormats" in query && this.#checkJSONSchemaType(query["mediaFormats"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "mediaFormats", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.recordingId = recordingId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Updates the retention records on a recording.
	 * @async
	 * @param {string} conversationId - Conversation ID
	 * @param {string} recordingId - Recording ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.clearExport] -  Whether to clear the pending export for the recording
	 * @param {Recording} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/recordings/{recordingId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putConversationRecording(conversationId, recordingId, query, body) {
		const endpointPath = "/api/v2/conversations/{conversationId}/recordings/{recordingId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(recordingId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "recordingId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("clearExport" in query && this.#checkJSONSchemaType(query["clearExport"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "clearExport", "boolean");
			}
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.recordingId = recordingId;
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get recording metadata for a conversation. Does not return playable media nor system annotations. Bookmark annotations will be excluded if either recording:recording:view or recording:annotation:view permission is missing.
	 * @async
	 * @param {string} conversationId - Conversation ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/recordingmetadata" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationRecordingmetadata(conversationId) {
		const endpointPath = "/api/v2/conversations/{conversationId}/recordingmetadata";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get all of a Conversation's Recordings.
	 * @async
	 * @param {string} conversationId - Conversation ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.maxWaitMs] -  The maximum number of milliseconds to wait for the recording to be ready. Must be a positive value.
	 * @param {string} [query.formatId] -  The desired media format. Valid values:WAV,WEBM,WAV_ULAW,OGG_VORBIS,OGG_OPUS,MP3,NONE.
	 * @param {string[]} [query.mediaFormats] -  All acceptable media formats. Overrides formatId. Valid values:WAV,WEBM,WAV_ULAW,OGG_VORBIS,OGG_OPUS,MP3.
	 * @param {string} [query.locale] -  The locale used for redacting sensitive information in requested files, as an ISO 639-1 code
	 * @param {boolean} [query.includePauseAnnotationsForScreenRecordings] -  Include applicable Secure Pause annotations from all audio recordings to all screen recordings
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/recordings" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationRecordings(conversationId, query) {
		const endpointPath = "/api/v2/conversations/{conversationId}/recordings";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("maxWaitMs" in query && this.#checkJSONSchemaType(query["maxWaitMs"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "maxWaitMs", "integer");
			}
			if ("formatId" in query && this.#checkJSONSchemaType(query["formatId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "formatId", "string");
			}
			if ("mediaFormats" in query && this.#checkJSONSchemaType(query["mediaFormats"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "mediaFormats", "array");
			}
			if ("locale" in query && this.#checkJSONSchemaType(query["locale"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "locale", "string");
			}
			if ("includePauseAnnotationsForScreenRecordings" in query && this.#checkJSONSchemaType(query["includePauseAnnotationsForScreenRecordings"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "includePauseAnnotationsForScreenRecordings", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for recording retention data
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} query.retentionThresholdDays -  Fetch retention data for recordings retained for more days than the provided value.
	 * @param {string} [query.cursor] -  Indicates where to resume query results (not required for first page)
	 * @param {number} [query.pageSize] -  Page size. Maximum is 500.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recordings/retention/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING} If a required query string parameter is missing.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRecordingsRetentionQuery(query) {
		const endpointPath = "/api/v2/recordings/retention/query";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object" || query === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, true);
		}

		if ("retentionThresholdDays" in query === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING(endpointPath, endpointMethod, "retentionThresholdDays");
		}

		if (this.#checkJSONSchemaType(query["retentionThresholdDays"], "integer") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "retentionThresholdDays", "integer");
		}

		if ("cursor" in query && this.#checkJSONSchemaType(query["cursor"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "cursor", "string");
		}

		if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get annotation
	 * @async
	 * @param {string} conversationId - Conversation ID
	 * @param {string} recordingId - Recording ID
	 * @param {string} annotationId - Annotation ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/recordings/{recordingId}/annotations/{annotationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationRecordingAnnotation(conversationId, recordingId, annotationId) {
		const endpointPath = "/api/v2/conversations/{conversationId}/recordings/{recordingId}/annotations/{annotationId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(recordingId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "recordingId", "string");
		}

		if (this.#checkJSONSchemaType(annotationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "annotationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.recordingId = recordingId;
		apiCallOptions.pathParameters.annotationId = annotationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update annotation
	 * @async
	 * @param {string} conversationId - Conversation ID
	 * @param {string} recordingId - Recording ID
	 * @param {string} annotationId - Annotation ID
	 * @param {Annotation} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/recordings/{recordingId}/annotations/{annotationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putConversationRecordingAnnotation(conversationId, recordingId, annotationId, body) {
		const endpointPath = "/api/v2/conversations/{conversationId}/recordings/{recordingId}/annotations/{annotationId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(recordingId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "recordingId", "string");
		}

		if (this.#checkJSONSchemaType(annotationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "annotationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.recordingId = recordingId;
		apiCallOptions.pathParameters.annotationId = annotationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete annotation
	 * @async
	 * @param {string} conversationId - Conversation ID
	 * @param {string} recordingId - Recording ID
	 * @param {string} annotationId - Annotation ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/recordings/{recordingId}/annotations/{annotationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteConversationRecordingAnnotation(conversationId, recordingId, annotationId) {
		const endpointPath = "/api/v2/conversations/{conversationId}/recordings/{recordingId}/annotations/{annotationId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(recordingId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "recordingId", "string");
		}

		if (this.#checkJSONSchemaType(annotationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "annotationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.recordingId = recordingId;
		apiCallOptions.pathParameters.annotationId = annotationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get annotations for recording
	 * @async
	 * @param {string} conversationId - Conversation ID
	 * @param {string} recordingId - Recording ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/recordings/{recordingId}/annotations" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationRecordingAnnotations(conversationId, recordingId) {
		const endpointPath = "/api/v2/conversations/{conversationId}/recordings/{recordingId}/annotations";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(recordingId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "recordingId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.recordingId = recordingId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create annotation
	 * @async
	 * @param {string} conversationId - Conversation ID
	 * @param {string} recordingId - Recording ID
	 * @param {Annotation} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/recordings/{recordingId}/annotations" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationRecordingAnnotations(conversationId, recordingId, body) {
		const endpointPath = "/api/v2/conversations/{conversationId}/recordings/{recordingId}/annotations";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(recordingId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "recordingId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.recordingId = recordingId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get IDs of recordings that the bulk job failed for
	 * @async
	 * @param {string} jobId - jobId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size. Maximum is 100.
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {boolean} [query.includeTotal] -  If false, cursor will be used to locate the page instead of pageNumber.
	 * @param {string} [query.cursor] -  Indicates where to resume query results (not required for first page)
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/jobs/{jobId}/failedrecordings" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRecordingJobFailedrecordings(jobId, query) {
		const endpointPath = "/api/v2/recording/jobs/{jobId}/failedrecordings";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(jobId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "jobId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("includeTotal" in query && this.#checkJSONSchemaType(query["includeTotal"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "includeTotal", "boolean");
			}
			if ("cursor" in query && this.#checkJSONSchemaType(query["cursor"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "cursor", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.jobId = jobId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the status of the job associated with the job id.
	 * @async
	 * @param {string} jobId - jobId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/jobs/{jobId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRecordingJob(jobId) {
		const endpointPath = "/api/v2/recording/jobs/{jobId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(jobId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "jobId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.jobId = jobId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Execute the recording bulk job.
	 * @async
	 * @param {string} jobId - jobId
	 * @param {ExecuteRecordingJobsQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/jobs/{jobId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putRecordingJob(jobId, body) {
		const endpointPath = "/api/v2/recording/jobs/{jobId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(jobId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "jobId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.jobId = jobId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete the recording bulk job
	 * @async
	 * @param {string} jobId - jobId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/jobs/{jobId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteRecordingJob(jobId) {
		const endpointPath = "/api/v2/recording/jobs/{jobId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(jobId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "jobId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.jobId = jobId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the status of all jobs within the user's organization
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.sortBy] -  Sort by
	 * @param {string} [query.state] -  Filter by state
	 * @param {boolean} [query.showOnlyMyJobs] -  Show only my jobs
	 * @param {string} [query.jobType] -  Job Type (Can be left empty for both)
	 * @param {boolean} [query.includeTotal] -  If false, cursor will be used to locate the page instead of pageNumber.
	 * @param {string} [query.cursor] -  Indicates where to resume query results (not required for first page)
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/jobs" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRecordingJobs(query) {
		const endpointPath = "/api/v2/recording/jobs";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("sortBy" in query && this.#checkJSONSchemaType(query["sortBy"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortBy", "string");
			}
			if ("state" in query && this.#checkJSONSchemaType(query["state"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "state", "string");
			}
			if ("showOnlyMyJobs" in query && this.#checkJSONSchemaType(query["showOnlyMyJobs"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "showOnlyMyJobs", "boolean");
			}
			if ("jobType" in query && this.#checkJSONSchemaType(query["jobType"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "jobType", "string");
			}
			if ("includeTotal" in query && this.#checkJSONSchemaType(query["includeTotal"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "includeTotal", "boolean");
			}
			if ("cursor" in query && this.#checkJSONSchemaType(query["cursor"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "cursor", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a recording bulk job.
	 * @async
	 * @param {RecordingJobsQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/jobs" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRecordingJobs(body) {
		const endpointPath = "/api/v2/recording/jobs";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the Recording Settings for the Organization
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.createDefault] -  If no settings are found, a new one is created with default values
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/settings" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getRecordingSettings(query) {
		const endpointPath = "/api/v2/recording/settings";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("createDefault" in query && this.#checkJSONSchemaType(query["createDefault"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "createDefault", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update the Recording Settings for the Organization
	 * @async
	 * @param {RecordingSettings} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/settings" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putRecordingSettings(body) {
		const endpointPath = "/api/v2/recording/settings";
		const endpointMethod = "PUT";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the status of a recording upload status report
	 * @async
	 * @param {string} reportId - reportId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/uploads/reports/{reportId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getRecordingUploadsReport(reportId) {
		const endpointPath = "/api/v2/recording/uploads/reports/{reportId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(reportId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "reportId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.reportId = reportId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Creates a recording upload status report
	 * @async
	 * @param {RecordingUploadReportRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recording/uploads/reports" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRecordingUploadsReports(body) {
		const endpointPath = "/api/v2/recording/uploads/reports";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Provide meta-data a screen recording.
	 * @async
	 * @param {ScreenRecordingMetaDataRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recordings/screensessions/metadata" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRecordingsScreensessionsMetadata(body) {
		const endpointPath = "/api/v2/recordings/screensessions/metadata";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Acknowledge a screen recording.
	 * @async
	 * @param {AcknowledgeScreenRecordingRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recordings/screensessions/acknowledge" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postRecordingsScreensessionsAcknowledge(body) {
		const endpointPath = "/api/v2/recordings/screensessions/acknowledge";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Retrieves an object containing the total number of concurrent active screen recordings
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/recordings/screensessions/details" endpoint.
	 */
	getRecordingsScreensessionsDetails() {
		const endpointPath = "/api/v2/recordings/screensessions/details";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * @description Checks that a value is of the proper JSON schema type
	 * @param {*} value - The value to check
	 * @param {string} jsonSchemaType - The JSON schema type to check against
	 * @returns {boolean} Returns true if the value is of the proper JSON schema type, false otherwise
	 */
	#checkJSONSchemaType(value, jsonSchemaType) {
		const PASSTHROUGH_JSON_SCHEMA_TYPES = ["boolean", "number", "string", "object"];

		// Check if the type is a passthrough type
		if (PASSTHROUGH_JSON_SCHEMA_TYPES.includes(jsonSchemaType)) {
			return typeof value === jsonSchemaType;
		}

		// Check if the type is an integer
		if (jsonSchemaType === "integer") {
			return Number.isInteger(value);
		}

		// Check if the type is an array
		if (jsonSchemaType === "array") {
			return Array.isArray(value);
		}

		// Check if the type is null
		if (jsonSchemaType === "null") {
			return value === null;
		}

		// Otherwise, return false
		return false;
	}
}

export { RecordingAPI };