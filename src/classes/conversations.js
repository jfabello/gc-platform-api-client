/**
 * @module gc-platform-api-conversations
 * @documentation https://developer.genesys.cloud/routing/conversations/conversations-apis
 * @license MIT
 */

// This file was automatically generated by the Generate Genesys Cloud Platform API classes utility on 2025-04-24T15:04:25.204Z

// TODO: Implement JSON schema verification for input and output objects
// TODO: Implement HTTP response typedefs

// Set strict mode
"use strict";

// Errors
import { errors } from "../gc-platform-api-client-errors.js";

// Symbols
import { symbols } from "../gc-platform-api-client-symbols.js";

/** @typedef {import("../gc-platform-api-client-class.js").GCPlatformAPIClient} GCPlatformAPIClient */
/** @typedef {import("@jfabello/http-client").HTTPResponse} HTTPResponse */

/**
 * @typedef {object} Actions
 * @property {SkillsToRemove[]} [skillsToRemove]
 */
 
/**
 * @typedef {object} AcwSettings
 * @property {string} [wrapupPrompt] - This field controls how the UI prompts the agent for a wrapup.
 * @property {number} [timeoutMs] - The amount of time the agent can stay in ACW (Min: 1 sec, Max: 60 min).  Can only be used when ACW is AGENT_REQUESTED, MANDATORY_TIMEOUT or MANDATORY_FORCED_TIMEOUT.
 */
 
/**
 * @typedef {object} AdditionalMessage
 * @property {string} textBody - The body of the text message.  Maximum character counts are: SMS - 765 characters, other channels - 2000 characters.
 * @property {string[]} [mediaIds] - The media ids associated with the text message. See https://developer.genesys.cloud/api/rest/v2/conversations/messaging-media-upload for example usage.
 * @property {string[]} [stickerIds] - The sticker ids associated with the text message.
 * @property {SendMessagingTemplateRequest} [messagingTemplate] - The messaging template use to send a predefined canned response with the message
 */
 
/**
 * @typedef {object} Address
 * @property {string} [name] - This will be nameRaw if present, or a locality lookup of the address field otherwise.
 * @property {string} [nameRaw] - The name as close to the bits on the wire as possible.
 * @property {string} [addressNormalized] - The normalized address. This field is acquired from the Address Normalization Table.  The addressRaw could have gone through some transformations, such as only using the numeric portion, before being run through the Address Normalization Table.
 * @property {string} [addressRaw] - The address as close to the bits on the wire as possible.
 * @property {string} [addressDisplayable] - The displayable address. This field is acquired from the Address Normalization Table.  The addressRaw could have gone through some transformations, such as only using the numeric portion, before being run through the Address Normalization Table.
 */
 
/**
 * @typedef {object} AddressableEntityRef
 * @property {string} [id]
 * @property {string} [selfUri]
 */
 
/**
 * @typedef {object} AdjustableLiveSpeakerDetection
 * @property {string} [mode] - Modes to tune between speed to live speaker detection vs accuracy.
 * @property {string} [preconnectDuration] - ISO 8601 formatted relative duration (e.g., PT30.8427419S for 30.8 seconds), calculated on line connect.
 * @property {string} [eventName] - The name of the event that triggered the ALSD evaluation (e.g., line.connect, speech.generic).
 * @property {boolean} [isPersonLikely] - The output of the ALSD detector, evaluating whether there is likely a person on the call based on the above inputs, and if so, a person is detected early (person disposition name and speech.person analyzer result) and the associated action taken (e.g., speech.person postconnect entry in the disposition table has the action to transfer to a queue).
 * @property {number} [totalRingbacks] - Number of tone.ring.* analyzer events detected during the call (expected mostly during pre-connect but the last ringback tone detection could potentially complete after line connect, which will increment totalRingbacks still).
 * @property {boolean} [lineConnected] - Protocol line connect received (answered by a person, machine, busy, fax).
 */
 
/**
 * @typedef {object} AfterCallWork
 * @property {string} [startTime] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [endTime] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [state]
 */
 
/**
 * @typedef {object} AfterCallWorkUpdate
 * @property {boolean} afterCallWorkRequired - Indicates whether or not after-call work must be completed for the communication. Can only be updated for connected communications.
 */
 
/**
 * @typedef {object} AgentlessEmailSendRequestDto
 * @property {string} senderType - The direction of the message.
 * @property {string} [conversationId] - The identifier of the conversation. This must be an email interaction.
 * @property {EmailAddress} fromAddress - The sender of the message.
 * @property {EmailAddress[]} toAddresses - The recipient of the message. We currently support one recipient only.
 * @property {EmailAddress} [replyToAddress] - The address to use for reply.
 * @property {string} [subject] - The subject of the message.
 * @property {string} [textBody] - The Content of the message, in plain text.
 * @property {string} [htmlBody] - The Content of the message, in HTML. Links, images and styles are allowed
 */
 
/**
 * @typedef {object} AgentOwnedRouting
 * @property {boolean} [enableAgentOwnedCallbacks] - Indicates if Agent Owned Callbacks are enabled for the queue
 * @property {number} [maxOwnedCallbackHours] - The max amount of time a callback can be owned (in hours); Allowable range 1 - 168 hour(s) (inclusive)
 * @property {number} [maxOwnedCallbackDelayHours] - The max amount of time a callback can be scheduled out into the future (in hours); Allowable range 1 - 720 hour(s) (inclusive)
 */
 
/**
 * @typedef {object} AggregationRange
 * @property {number} [gte] - Greater than or equal to
 * @property {number} [lt] - Less than
 */
 
/**
 * @typedef {object} AiAnswer
 * @property {string} [answerId] - The unique identifier of the suggested AI answer.
 * @property {string} [explanation] - An explanation providing the reasoning behind the suggested answer.
 * @property {string} [failureType] - Describes the type of error associated with the AI answer.
 */
 
/**
 * @typedef {object} AiScoring
 * @property {string} [failureType] - The type of error that occurred while processing AI scores. It is null where there is no error.
 * @property {boolean} [pending] - Indicates whether AI scoring is currently processing the evaluation.
 * @property {string} [dateLastChanged] - The date when the AI scores were last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 */
 
/**
 * @typedef {object} AiScoringSetting
 * @property {boolean} [enabled] - True if AI Scoring feature is configured.
 */
 
/**
 * @typedef {object} AiScoringSettings
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {QuestionGroupSettings[]} [questionGroupSettings]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} AnalyticsProperty
 * @property {string} [property] - User-defined rather than intrinsic system-observed values. These are tagged onto segments by other components within PureCloud or by API users directly.  This is the name of the user-defined property.
 * @property {string} [propertyType] - Indicates what the data type is (e.g. integer vs string) and therefore how to evaluate what would constitute a match
 * @property {string} [value] - What property value to match against
 */
 
/**
 * @typedef {object} AnalyticsQueryAggregation
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - For use with termFrequency aggregations
 * @property {string} [metric] - For use with numericRange aggregations
 * @property {number} [size] - For use with termFrequency aggregations
 * @property {AggregationRange[]} [ranges] - For use with numericRange aggregations
 */
 
/**
 * @typedef {object} AnswerOption
 * @property {string} [id]
 * @property {string} [text]
 * @property {number} [value]
 * @property {AssistanceCondition[]} [assistanceConditions] - List of assistance conditions which are combined together with a logical AND operator. Eg ( assistanceCondtion1 && assistanceCondition2 ) wherein assistanceCondition could be ( EXISTS topic1 || topic2 || ... ) or (NOTEXISTS topic3 || topic4 || ...).
 */
 
/**
 * @typedef {object} AssistanceCondition
 * @property {string} [operator] - The operator for the assistance condition. The operator defines whether the listed topicIds should EXIST or NOTEXIST for the condition to be evaluated as true.
 * @property {string[]} [topicIds] - List of topicIds within the assistance condition which would be combined together using logical OR operator. Eg ( topicId_1 || topicId_2 ) .
 */
 
/**
 * @typedef {object} AsyncConversationQuery
 * @property {ConversationDetailQueryFilter[]} [conversationFilters] - Filters that target conversation-level data
 * @property {SegmentDetailQueryFilter[]} [segmentFilters] - Filters that target individual segments within a conversation
 * @property {EvaluationDetailQueryFilter[]} [evaluationFilters] - Filters that target evaluations
 * @property {SurveyDetailQueryFilter[]} [surveyFilters] - Filters that target surveys
 * @property {ResolutionDetailQueryFilter[]} [resolutionFilters] - Filters that target resolutions
 * @property {string} [order] - Sort the result set in ascending/descending order. Default is ascending
 * @property {string} [orderBy] - Specify which data element within the result set to use for sorting. The options  to use as a basis for sorting the results: conversationStart, segmentStart, and segmentEnd. If not specified, the default is conversationStart
 * @property {string} interval - Specifies the date and time range of data being queried. Results will include all conversations that had activity during the interval. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {number} [limit] - Specify number of results to be returned
 * @property {boolean} [startOfDayIntervalMatching] - Add a filter to only include conversations that started after the beginning of the interval start date (UTC)
 */
 
/**
 * @typedef {object} Attachment
 * @property {string} [attachmentId] - The unique identifier for the attachment.
 * @property {string} [name] - The name of the attachment.
 * @property {string} [contentUri] - The content uri of the attachment. If set, this is commonly a public api download location.
 * @property {string} [contentType] - The type of file the attachment is.
 * @property {number} [contentLength] - The length of the attachment file.
 * @property {boolean} [inlineImage] - Whether or not the attachment was attached inline.,
 */
 
/**
 * @typedef {object} Biography
 * @property {string} [biography] - Personal detailed description
 * @property {string[]} [interests]
 * @property {string[]} [hobbies]
 * @property {string} [spouse]
 * @property {Education[]} [education] - User education details
 */
 
/**
 * @typedef {object} BulkCallbackDisconnectRequest
 * @property {CallbackDisconnectIdentifier[]} callbackDisconnectIdentifiers - The list of requests to disconnect callbacks in bulk
 */
 
/**
 * @typedef {object} BulkCallbackPatchRequest
 * @property {PatchCallbackRequest[]} patchCallbackRequests - The list of requests to update callbacks in bulk
 */
 
/**
 * @typedef {object} Bullseye
 * @property {Ring[]} [rings] - The bullseye rings configured for this queue.
 */
 
/**
 * @typedef {object} Calibration
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {User} [calibrator]
 * @property {User} [agent]
 * @property {ConversationReference} [conversation]
 * @property {EvaluationForm} [evaluationForm]
 * @property {string} [contextId]
 * @property {number} [averageScore]
 * @property {number} [highScore]
 * @property {number} [lowScore]
 * @property {string} [createdDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {Evaluation[]} [evaluations]
 * @property {User[]} [evaluators]
 * @property {Evaluation} [scoringIndex]
 * @property {User} [expertEvaluator]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} Call
 * @property {string} [state] - The connection state of this communication.
 * @property {string} [initialState] - The initial connection state of this communication.
 * @property {string} [id] - A globally unique identifier for this communication.
 * @property {string} [direction] - The direction of the call
 * @property {boolean} [recording] - True if this call is being recorded.
 * @property {string} [recordingState] - State of recording on this call.
 * @property {RecordersState} [recordersState] - Contains the states of different recorders.
 * @property {boolean} [muted] - True if this call is muted so that remote participants can't hear any audio from this end.
 * @property {boolean} [confined] - True if this call is held and the person on this side hears hold music.
 * @property {boolean} [held] - True if this call is held and the person on this side hears silence.
 * @property {boolean} [securePause] - True when the recording of this call is in secure pause status.
 * @property {string} [recordingId] - A globally unique identifier for the recording associated with this call.
 * @property {Segment[]} [segments] - The time line of the participant's call, divided into activity segments.
 * @property {ErrorInfo} [errorInfo]
 * @property {string} [disconnectType] - System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects.
 * @property {string} [startHoldTime] - The timestamp the call was placed on hold in the cloud clock if the call is currently on hold. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [documentId] - If call is an outbound fax of a document from content management, then this is the id in content management.
 * @property {string} [startAlertingTime] - The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [connectedTime] - The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [disconnectedTime] - The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {DisconnectReason[]} [disconnectReasons] - List of reasons that this call was disconnected. This will be set once the call disconnects.
 * @property {FaxStatus} [faxStatus] - Extra information on fax transmission.
 * @property {string} [provider] - The source provider for the call.
 * @property {string} [scriptId] - The UUID of the script to use.
 * @property {string} [peerId] - The id of the peer communication corresponding to a matching leg for this communication.
 * @property {string} [uuiData] - User to User Information (UUI) data managed by SIP session application.
 * @property {Address} [self] - Address and name data for a call endpoint.
 * @property {Address} [other] - Address and name data for a call endpoint.
 * @property {Wrapup} [wrapup] - Call wrap up or disposition data.
 * @property {AfterCallWork} [afterCallWork] - After-call work for the communication.
 * @property {boolean} [afterCallWorkRequired] - Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested.
 * @property {string} [agentAssistantId] - UUID of virtual agent assistant that provide suggestions to the agent participant during the conversation.
 * @property {ConversationQueueMediaSettings} [queueMediaSettings] - Represents the queue settings for this media type.
 * @property {Disposition} [disposition] - Call resolution data for Dialer bulk make calls commands.
 */
 
/**
 * @typedef {object} Callback
 * @property {string} [state] - The connection state of this communication.
 * @property {string} [initialState] - The initial connection state of this communication.
 * @property {string} [id] - A globally unique identifier for this communication.
 * @property {Segment[]} [segments] - The time line of the participant's callback, divided into activity segments.
 * @property {string} [direction] - The direction of the call
 * @property {boolean} [held] - True if this call is held and the person on this side hears silence.
 * @property {string} [disconnectType] - System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects.
 * @property {string} [startHoldTime] - The timestamp the callback was placed on hold in the cloud clock if the callback is currently on hold. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {DialerPreview} [dialerPreview] - The preview data to be used when this callback is a Preview.
 * @property {Voicemail} [voicemail] - The voicemail data to be used when this callback is an ACD voicemail.
 * @property {string[]} [callbackNumbers] - The phone number(s) to use to place the callback.
 * @property {string} [callbackUserName] - The name of the user requesting a callback.
 * @property {string} [scriptId] - The UUID of the script to use.
 * @property {boolean} [externalCampaign] - True if the call for the callback uses external dialing.
 * @property {boolean} [skipEnabled] - True if the ability to skip a callback should be enabled.
 * @property {number} [timeoutSeconds] - The number of seconds before the system automatically places a call for a callback.  0 means the automatic placement is disabled.
 * @property {string} [startAlertingTime] - The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [connectedTime] - The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [disconnectedTime] - The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [callbackScheduledTime] - The timestamp when this communication is scheduled in the provider clock. If this value is missing it indicates the callback will be placed immediately. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [automatedCallbackConfigId] - The id of the config for automatically placing the callback (and handling the disposition). If null, the callback will not be placed automatically but routed to an agent as per normal.
 * @property {string} [provider] - The source provider for the callback.
 * @property {string} [peerId] - The id of the peer communication corresponding to a matching leg for this communication.
 * @property {Wrapup} [wrapup] - Call wrap up or disposition data.
 * @property {AfterCallWork} [afterCallWork] - After-call work for the communication.
 * @property {boolean} [afterCallWorkRequired] - Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested.
 * @property {string} [callerId] - The phone number displayed to recipients of the phone call. The value should conform to the E164 format.
 * @property {string} [callerIdName] - The name displayed to recipients of the phone call.
 * @property {ConversationQueueMediaSettings} [queueMediaSettings] - Represents the queue settings for this media type.
 */
 
/**
 * @typedef {object} CallbackDisconnectIdentifier
 * @property {string} conversationId - The Conversation Id.
 * @property {string} callbackId - The callback id.
 */
 
/**
 * @typedef {object} CallbackMediaSettings
 * @property {boolean} [enableAutoAnswer] - Indicates if auto-answer is enabled for the given media type or subtype (default is false).  Subtype settings take precedence over media type settings.
 * @property {number} [alertingTimeoutSeconds] - The alerting timeout for the media type, in seconds
 * @property {ServiceLevel} [serviceLevel] - The targeted service level for the media type
 * @property {number} [autoAnswerAlertToneSeconds] - How long to play the alerting tone for an auto-answer interaction
 * @property {number} [manualAnswerAlertToneSeconds] - How long to play the alerting tone for a manual-answer interaction
 * @property {object} [subTypeSettings] - Map of media subtype to media subtype specific settings.
 * @property {string} [mode] - The mode callbacks will use on this queue.
 * @property {boolean} [enableAutoDialAndEnd] - Flag to enable Auto-Dial and Auto-End automation for callbacks on this queue.
 * @property {number} [autoDialDelaySeconds] - Time in seconds after agent connects to callback before outgoing call is auto-dialed. Allowable values in range 0 - 1200 seconds. Defaults to 300 seconds.
 * @property {number} [autoEndDelaySeconds] - Time in seconds after agent disconnects from the outgoing call before the encasing callback is auto-ended. Allowable values in range 0 - 1200 seconds. Defaults to 300 seconds.
 * @property {number} [pacingModifier] - Controls the maximum number of outbound calls at one time when mode is CustomerFirst.
 * @property {string} [liveVoiceReactionType] - The action to take if a live voice is detected during the outbound call of a customer first callback.
 * @property {DomainEntityRef} [liveVoiceFlow] - The inbound flow to transfer to if a live voice is detected during the outbound call of a customer first callback.
 * @property {string} [answeringMachineReactionType] - The action to take if an answering machine is detected during the outbound call of a customer first callback.
 * @property {DomainEntityRef} [answeringMachineFlow] - The inbound flow to transfer to if an answering machine is detected during the outbound call of a customer first callback when answeringMachineReactionType is set to TransferToFlow.
 */
 
/**
 * @typedef {object} CallCommand
 * @property {string} callNumber - The phone number to dial for this call.
 * @property {string} [phoneColumn] - For a dialer preview or scheduled callback, the phone column associated with the phone number
 */
 
/**
 * @typedef {object} CannedResponseLibraries
 * @property {string[]} [libraryIds] - Set of canned response library IDs associated with the queue only when mode is SelectedOnly.
 * @property {string} [mode] - The association mode of canned response libraries to queue
 */
 
/**
 * @typedef {object} Chat
 * @property {string} [jabberId]
 */
 
/**
 * @typedef {object} Cobrowsesession
 * @property {string} [state] - The connection state of this communication.
 * @property {string} [initialState] - The initial connection state of this communication.
 * @property {string} [id] - A globally unique identifier for this communication.
 * @property {string} [disconnectType] - System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects.
 * @property {Address} [self] - Address and name data for a call endpoint.
 * @property {string} [cobrowseSessionId] - The co-browse session ID.
 * @property {string} [cobrowseRole] - This value identifies the role of the co-browse client within the co-browse session (a client is a sharer or a viewer).
 * @property {string[]} [controlling] - ID of co-browse participants for which this client has been granted control (list is empty if this client cannot control any shared pages).
 * @property {string} [viewerUrl] - The URL that can be used to open co-browse session in web browser.
 * @property {string} [providerEventTime] - The time when the provider event which triggered this conversation update happened in the corrected provider clock (milliseconds since 1970-01-01 00:00:00 UTC). Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [startAlertingTime] - The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [connectedTime] - The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [disconnectedTime] - The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [provider] - The source provider for the co-browse session.
 * @property {string} [peerId] - The id of the peer communication corresponding to a matching leg for this communication.
 * @property {Segment[]} [segments] - The time line of the participant's call, divided into activity segments.
 * @property {Wrapup} [wrapup] - Call wrap up or disposition data.
 * @property {AfterCallWork} [afterCallWork] - After-call work for the communication.
 * @property {boolean} [afterCallWorkRequired] - Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested.
 */
 
/**
 * @typedef {object} ConditionalGroupRouting
 * @property {ConditionalGroupRoutingRule[]} [rules] - The set of rules to be executed for each conversation
 */
 
/**
 * @typedef {object} ConditionalGroupRoutingRule
 * @property {DomainEntityRef} [queue] - The queue being evaluated for this rule.  If null, the current queue will be used.
 * @property {string} [metric] - The queue metric being evaluated
 * @property {string} [operator] - The operator that compares the actual value against the condition value
 * @property {number} [conditionValue] - The limit value, beyond which a rule evaluates as true
 * @property {MemberGroup[]} [groups] - The group(s) to activate if the rule evaluates as true
 * @property {number} [waitSeconds] - The number of seconds to wait in this rule, if it evaluates as true, before evaluating the next rule.  For the final rule, this is ignored, so need not be specified.
 */
 
/**
 * @typedef {object} ConsultTransfer
 * @property {string} speakTo - Determines to whom the initiating participant is requesting to speak. Defaults to DESTINATION
 * @property {string} [consultingUserId] - The user ID of the person who wants to talk before completing the transfer. Could be the same of the context user ID
 * @property {Destination} destination - Destination. Specify one and only one parameter from the list below.
 */
 
/**
 * @typedef {object} ConsultTransferToAgent
 * @property {string} speakTo - Determines to whom the initiating participant is requesting to speak. Defaults to DESTINATION
 * @property {string} [consultingUserId] - The user ID of the person who wants to talk before completing the transfer. Could be the same of the context user ID
 * @property {string} [userId] - The id of the internal user.
 * @property {string} [userDisplayName] - The name of the internal user.
 */
 
/**
 * @typedef {object} ConsultTransferToExternal
 * @property {string} speakTo - Determines to whom the initiating participant is requesting to speak. Defaults to DESTINATION
 * @property {string} [consultingUserId] - The user ID of the person who wants to talk before completing the transfer. Could be the same of the context user ID
 * @property {string} [address] - The address (like phone number) of the external contact.
 */
 
/**
 * @typedef {object} ConsultTransferToQueue
 * @property {string} speakTo - Determines to whom the initiating participant is requesting to speak. Defaults to DESTINATION
 * @property {string} [consultingUserId] - The user ID of the person who wants to talk before completing the transfer. Could be the same of the context user ID
 * @property {string} [queueId] - The id of the queue.
 * @property {string} [queueName] - The name of the queue.
 */
 
/**
 * @typedef {object} ConsultTransferUpdate
 * @property {string} speakTo - Determines to whom the initiating participant is speaking.
 * @property {string} [consultingUserId] - The user ID of the person who wants to talk before completing the transfer. Could be the same of the context user ID
 */
 
/**
 * @typedef {object} Contact
 * @property {string} [address] - Email address or phone number for this contact type
 * @property {string} [display] - Formatted version of the address property
 * @property {string} [mediaType]
 * @property {string} [type]
 * @property {string} [extension] - Use internal extension instead of address. Mutually exclusive with the address field.
 * @property {string} [countryCode]
 * @property {string} [integration] - Integration tag value if this number is associated with an external integration.
 */
 
/**
 * @typedef {object} ContentSetting
 * @property {StorySetting} [story] - Settings relating to facebook and instagram stories feature
 */
 
/**
 * @typedef {object} Conversation
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [externalTag] - The external tag associated with the conversation.
 * @property {string} startTime - The time when the conversation started. This will be the time when the first participant joined the conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [endTime] - The time when the conversation ended. This will be the time when the last participant left the conversation, or null when the conversation is still active. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [address] - The address of the conversation as seen from an external participant. For phone calls this will be the DNIS for inbound calls and the ANI for outbound calls. For other media types this will be the address of the destination participant for inbound and the address of the initiating participant for outbound.
 * @property {Participant[]} participants - The list of all participants in the conversation.
 * @property {string[]} [conversationIds] - A list of conversations to merge into this conversation to create a conference. This field is null except when being used to create a conference.
 * @property {number} [maxParticipants] - If this is a conference conversation, then this field indicates the maximum number of participants allowed to participant in the conference.
 * @property {string} [recordingState] - On update, 'paused' initiates a secure pause, 'active' resumes any paused recordings; otherwise indicates state of conversation recording.
 * @property {string} [state] - The conversation's state
 * @property {ConversationDivisionMembership[]} [divisions] - Identifiers of divisions associated with this conversation
 * @property {TransferResponse[]} [recentTransfers] - The list of the most recent 20 transfer commands applied to this conversation.
 * @property {boolean} [securePause] - True when the recording of this conversation is in secure pause status.
 * @property {string} [utilizationLabelId] - An optional label that categorizes the conversation.  Max-utilization settings can be configured at a per-label level
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} ConversationActivityQuery
 * @property {ConversationActivityQueryMetric[]} metrics - List of requested metrics
 * @property {string[]} groupBy - Dimension(s) to group by
 * @property {ConversationActivityQueryFilter} [filter] - Filter to return a subset of observations. Expresses boolean logical predicates as well as dimensional filters
 * @property {string} [order] - Sort the result set in ascending/descending order. Default is ascending
 */
 
/**
 * @typedef {object} ConversationActivityQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {ConversationActivityQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ConversationActivityQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {ConversationActivityQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {ConversationActivityQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ConversationActivityQueryMetric
 * @property {string} metric - The requested metric
 * @property {boolean} [details] - Flag for including observation details for this metric in the response
 */
 
/**
 * @typedef {object} ConversationActivityQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} ConversationAggregateQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {ConversationAggregateQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ConversationAggregateQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {ConversationAggregateQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {ConversationAggregateQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ConversationAggregateQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} ConversationAggregationQuery
 * @property {string} interval - Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string} [granularity] - Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
 * @property {string} [timeZone] - Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 * @property {string[]} [groupBy] - Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group.
 * @property {ConversationAggregateQueryFilter} [filter] - Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {boolean} [flattenMultivaluedDimensions] - Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c')
 * @property {ConversationAggregationView[]} [views] - Custom derived metric views
 * @property {string} [alternateTimeDimension] - Dimension to use as the alternative timestamp for data in the aggregate.  Choosing "eventTime" uses the actual time of the data event.
 */
 
/**
 * @typedef {object} ConversationAggregationView
 * @property {string} target - Target metric name
 * @property {string} name - A unique name for this view. Must be distinct from other views and built-in metric names.
 * @property {string} function - Type of view you wish to create
 * @property {AggregationRange} [range] - Range of numbers for slicing up data
 */
 
/**
 * Information about the channel.
 * @typedef {object} ConversationChannelMetadata
 */
 
/**
 * @typedef {object} ConversationChat
 * @property {string} [state] - The connection state of this communication.
 * @property {string} [initialState] - The initial connection state of this communication.
 * @property {string} [id] - A globally unique identifier for this communication.
 * @property {string} [roomId] - The room id for the chat.
 * @property {string} [recordingId] - A globally unique identifier for the recording associated with this chat.
 * @property {Segment[]} [segments] - The time line of the participant's chat, divided into activity segments.
 * @property {boolean} [held] - True if this call is held and the person on this side hears silence.
 * @property {string} [direction] - The direction of the chat
 * @property {string} [disconnectType] - System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects.
 * @property {string} [startHoldTime] - The timestamp the chat was placed on hold in the cloud clock if the chat is currently on hold. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [startAlertingTime] - The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [connectedTime] - The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [disconnectedTime] - The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [provider] - The source provider for the email.
 * @property {string} [scriptId] - The UUID of the script to use.
 * @property {string} [peerId] - The id of the peer communication corresponding to a matching leg for this communication.
 * @property {string} [avatarImageUrl] - If available, the URI to the avatar image of this communication.
 * @property {JourneyContext} [journeyContext] - A subset of the Journey System's data relevant to a part of a conversation (for external linkage and internal usage/context).
 * @property {Wrapup} [wrapup] - Call wrap up or disposition data.
 * @property {AfterCallWork} [afterCallWork] - After-call work for the communication.
 * @property {boolean} [afterCallWorkRequired] - Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested.
 * @property {ConversationQueueMediaSettings} [queueMediaSettings] - Represents the queue settings for this media type.
 */
 
/**
 * Attachment object.
 * @typedef {object} ConversationContentAttachment
 * @property {string} [id] - Provider specific ID for attachment. For example, a LINE sticker ID.
 * @property {string} mediaType - The type of attachment this instance represents.
 * @property {string} [url] - URL of the attachment.
 * @property {string} [mime] - Attachment mime type (https://www.iana.org/assignments/media-types/media-types.xhtml).
 * @property {string} [text] - Text associated with attachment such as an image caption.
 * @property {string} [sha256] - Secure hash of the attachment content.
 * @property {string} [filename] - Suggested file name for attachment.
 * @property {number} [contentSizeBytes] - Size in bytes of the attachment content.
 */
 
/**
 * @typedef {object} ConversationDetailQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {ConversationDetailQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ConversationDetailQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {ConversationDetailQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {ConversationDetailQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ConversationDetailQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [metric] - Left hand side for metric predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension or metric predicates
 * @property {NumericRange} [range] - Right hand side for dimension or metric predicates
 */
 
/**
 * @typedef {object} ConversationDivisionMembership
 * @property {DomainEntityRef} [division] - A division the conversation belongs to.
 * @property {DivisionEntityRef[]} [entities] - The entities on the conversation within the division. These are the users, queues, work flows, etc. that can be on conversations and and be assigned to different divisions.
 */
 
/**
 * @typedef {object} ConversationEncryptionConfiguration
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} url - keyConfigurationType is always KmsSymmetric, and should be the arn to the key alias for the master key
 * @property {string} keyConfigurationType - Type should be 'KmsSymmetric' when create or update Key configurations, 'None' to disable configuration.
 * @property {ErrorBody} [lastError] - The error message related to the configuration
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * A Typing event.
 * @typedef {object} ConversationEventTyping
 * @property {string} type - Describes the type of Typing event.
 * @property {number} [duration] - The duration of the Typing event in milliseconds.
 */
 
/**
 * Metadata information about a message.
 * @typedef {object} ConversationMessageMetadata
 * @property {string} [type] - Message type.
 * @property {ConversationMessageMetadataEvent[]} [events] - List of events metadata
 * @property {ConversationMessageMetadataContent[]} [content] - List of message content
 */
 
/**
 * Metadata information about a message content.
 * @typedef {object} ConversationMessageMetadataContent
 * @property {string} [contentType] - Type of this content element.
 * @property {string} [subType] - Content subtype
 */
 
/**
 * Metadata information about a message event.
 * @typedef {object} ConversationMessageMetadataEvent
 * @property {string} [eventType] - Type of this event element
 * @property {string} [subType] - Event subtype
 */
 
/**
 * @typedef {object} ConversationParticipantSearchCriteria
 * @property {string} [endValue] - The end value of the range. This field is used for range search types.
 * @property {string[]} [values] - A list of values for the search to match against
 * @property {string} [startValue] - The start value of the range. This field is used for range search types.
 * @property {string} [value] - A value for the search to match against
 * @property {string} [operator] - How to apply this search criteria against other criteria
 * @property {ConversationParticipantSearchCriteria[]} [group] - Groups multiple conditions
 * @property {string} [dateFormat] - Set date format for criteria values when using date range search type.  Supports Java date format syntax, example yyyy-MM-dd'T'HH:mm:ss.SSSX.
 * @property {string} type - Search Type
 * @property {string[]} [fields] - Field names to search against
 */
 
/**
 * @typedef {object} ConversationParticipantSearchRequest
 * @property {string} [sortOrder] - The sort order for results
 * @property {string} [sortBy] - The field in the resource that you want to sort the results by
 * @property {SearchSort[]} [sort] - Multi-value sort order, list of multiple sort values
 * @property {string[]} [returnFields]
 * @property {ConversationParticipantSearchCriteria[]} [query]
 * @property {string} [cursor]
 */
 
/**
 * @typedef {object} ConversationQuery
 * @property {ConversationDetailQueryFilter[]} [conversationFilters] - Filters that target conversation-level data
 * @property {SegmentDetailQueryFilter[]} [segmentFilters] - Filters that target individual segments within a conversation
 * @property {EvaluationDetailQueryFilter[]} [evaluationFilters] - Filters that target evaluations
 * @property {SurveyDetailQueryFilter[]} [surveyFilters] - Filters that target surveys
 * @property {ResolutionDetailQueryFilter[]} [resolutionFilters] - Filters that target resolutions
 * @property {string} [order] - Sort the result set in ascending/descending order. Default is ascending
 * @property {string} [orderBy] - Specify which data element within the result set to use for sorting. The options  to use as a basis for sorting the results: conversationStart, segmentStart, and segmentEnd. If not specified, the default is conversationStart
 * @property {string} interval - Specifies the date and time range of data being queried. Results will only include conversations that started on a day touched by the interval. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {AnalyticsQueryAggregation[]} [aggregations] - Include faceted search and aggregate roll-ups describing your search results. This does not function as a filter, but rather, summary data about the data matching your filters
 * @property {PagingSpec} [paging] - Page size and number to control iterating through large result sets. Default page size is 25
 */
 
/**
 * @typedef {object} ConversationQueueMediaSettings
 * @property {number} [alertingTimeoutSeconds] - Specifies how long the agent has to answer an interaction before being marked as not responding.
 * @property {number} [autoAnswerAlertToneSeconds] - Specifies the duration of the alerting sound to be played for auto answered interactions.
 * @property {number} [manualAnswerAlertToneSeconds] - Specifies the duration of the alerting sound to be played for manually answered interactions.
 * @property {boolean} [enableAutoAnswer] - Flag to indicate if auto answer is enabled for the given media type or media subtype.
 */
 
/**
 * Reasons for a failed message receipt.
 * @typedef {object} ConversationReason
 * @property {string} [code] - The reason code for the failed message receipt.
 * @property {string} message - Description of the reason for the failed message receipt.
 */
 
/**
 * @typedef {object} ConversationReference
 * @property {string} [id]
 * @property {string} [selfUri]
 */
 
/**
 * @typedef {object} ConversationRoutingData
 * @property {AddressableEntityRef} [queue] - The queue to use for routing decisions
 * @property {AddressableEntityRef} [language] - The language to use for routing decisions
 * @property {number} [priority] - The priority of the conversation to use for routing decisions
 * @property {AddressableEntityRef[]} [skills] - The skills to use for routing decisions
 * @property {ScoredAgent[]} [scoredAgents] - A collection of agents and their assigned scores for this conversation (0 - 100, higher being better), for use in routing to preferred agents
 * @property {string} [label] - An optional label that categorizes the conversation.  Max-utilization settings can be configured at a per-label level
 */
 
/**
 * @typedef {object} ConversationSecureAttributes
 * @property {object} [attributes] - The map of attribute keys to values.
 * @property {number} [version] - The version used to detect conflicting updates when using PUT. Not used for PATCH.
 */
 
/**
 * @typedef {object} ConversationTagsUpdate
 * @property {string} externalTag - The external tag associated with the conversation.
 */
 
/**
 * @typedef {object} ConversationThreadingWindow
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {ConversationThreadingWindowSetting[]} settings - The conversation threading window timeout (Minutes) for each messaging type
 * @property {number} [defaultTimeoutMinutes] - The default conversation threading window timeout (Minutes)
 */
 
/**
 * @typedef {object} ConversationThreadingWindowSetting
 * @property {string} messengerType - The type of messenger
 * @property {number} timeoutInMinutes - The conversation threading window timeout (Minutes) of specified messenger type
 */
 
/**
 * @typedef {object} ConversationUser
 * @property {string} id - The globally unique identifier for this user.
 */
 
/**
 * @typedef {object} ConversationUtilizationLabelUpdate
 * @property {string} [utilizationLabelId] - The utilization label associated with the conversation.
 */
 
/**
 * @typedef {object} CopyAttachmentsRequest
 * @property {DomainEntityRef} sourceMessage - A reference to the email message within the current conversation that owns the attachments to be copied
 * @property {Attachment[]} attachments - A list of attachments that will be copied from the source message to the current draft
 */
 
/**
 * @typedef {object} CoverSheet
 * @property {string} [notes] - Text to be added to the coversheet
 * @property {string} [locale] - Locale, e.g. = en-US
 */
 
/**
 * @typedef {object} CreateCallbackCommand
 * @property {string} [scriptId] - The identifier of the script to be used for the callback
 * @property {string} [queueId] - The identifier of the queue to be used for the callback. Either queueId or routingData is required.
 * @property {RoutingData} [routingData] - The routing data to be used for the callback. Either queueId or routingData is required.
 * @property {string} [callbackUserName] - The name of the party to be called back.
 * @property {string[]} callbackNumbers - A list of phone numbers for the callback.
 * @property {string} [callbackScheduledTime] - The scheduled date-time for the callback as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss.SSSZ
 * @property {string} [countryCode] - The country code to be associated with the callback numbers.
 * @property {boolean} [validateCallbackNumbers] - Whether or not to validate the callback numbers for phone number format.
 * @property {object} [data] - A map of key-value pairs containing additional data that can be associated to the callback. These values will appear in the attributes property on the conversation participant. Example: { "notes": "ready to close the deal!", "customerPreferredName": "Doc" }
 * @property {string} [callerId] - The phone number displayed to recipients when a phone call is placed as part of the callback. Must conform to the E.164 format. May be overridden by other settings in the system such as external trunk settings. Telco support for "callerId" varies.
 * @property {string} [callerIdName] - The name displayed to recipients when a phone call is placed as part of the callback. May be overridden by other settings in the system such as external trunk settings. Telco support for "callerIdName" varies.
 */
 
/**
 * @typedef {object} CreateCallbackOnConversationCommand
 * @property {string} [scriptId] - The identifier of the script to be used for the callback
 * @property {string} [queueId] - The identifier of the queue to be used for the callback. Either queueId or routingData is required.
 * @property {RoutingData} [routingData] - The routing data to be used for the callback. Either queueId or routingData is required.
 * @property {string} [callbackUserName] - The name of the party to be called back.
 * @property {string[]} callbackNumbers - A list of phone numbers for the callback.
 * @property {string} [callbackScheduledTime] - The scheduled date-time for the callback as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss.SSSZ
 * @property {string} [countryCode] - The country code to be associated with the callback numbers.
 * @property {boolean} [validateCallbackNumbers] - Whether or not to validate the callback numbers for phone number format.
 * @property {object} [data] - A map of key-value pairs containing additional data that can be associated to the callback. These values will appear in the attributes property on the conversation participant. Example: { "notes": "ready to close the deal!", "customerPreferredName": "Doc" }
 * @property {string} [callerId] - The phone number displayed to recipients when a phone call is placed as part of the callback. Must conform to the E.164 format. May be overridden by other settings in the system such as external trunk settings. Telco support for "callerId" varies.
 * @property {string} [callerIdName] - The name displayed to recipients when a phone call is placed as part of the callback. May be overridden by other settings in the system such as external trunk settings. Telco support for "callerIdName" varies.
 */
 
/**
 * @typedef {object} CreateCallRequest
 * @property {string} [phoneNumber] - The phone number to dial.
 * @property {string} [callerId] - The caller id phone number for this outbound call.
 * @property {string} [callerIdName] - The caller id name for this outbound call.
 * @property {string} [callFromQueueId] - The queue ID to call on behalf of.
 * @property {string} [callQueueId] - The queue ID to call.
 * @property {string} [callUserId] - The user ID to call.
 * @property {number} [priority] - The priority to assign to this call (if calling a queue).
 * @property {object} [attributes] - The list of attributes to associate with the customer participant.
 * @property {string} [languageId] - The language skill ID to use for routing this call (if calling a queue).
 * @property {string[]} [routingSkillsIds] - The skill ID's to use for routing this call (if calling a queue).
 * @property {string[]} [conversationIds] - The list of existing call conversations to merge into a new ad-hoc conference.
 * @property {Destination[]} [participants] - The list of participants to call to create a new ad-hoc conference.
 * @property {string} [uuiData] - User to User Information (UUI) data managed by SIP session application.
 * @property {string} [externalContactId] - The external contact with which to associate the call.
 * @property {string} [label] - An optional label that categorizes the conversation.  Max-utilization settings can be configured at a per-label level
 */
 
/**
 * @typedef {object} CreateEmailRequest
 * @property {string} [queueId] - The ID of the queue to use for routing the email conversation. This field is mutually exclusive with flowId
 * @property {string} [flowId] - The ID of the flow to use for routing email conversation. This field is mutually exclusive with queueId
 * @property {string} provider - The name of the provider that is sourcing the emails. The Provider "PureCloud Email" is reserved for native emails.
 * @property {string[]} [skillIds] - The list of skill ID's to use for routing.
 * @property {string} [languageId] - The ID of the language to use for routing.
 * @property {number} [priority] - The priority to assign to the conversation for routing.
 * @property {object} [attributes] - The list of attributes to associate with the customer participant.
 * @property {string} [toAddress] - The email address of the recipient of the email.
 * @property {string} [toName] - The name of the recipient of the email.
 * @property {string} [fromAddress] - The email address of the sender of the email.
 * @property {string} [fromName] - The name of the sender of the email.
 * @property {string} [subject] - The subject of the email
 * @property {string} [direction] - Specify OUTBOUND to send an email on behalf of a queue, or INBOUND to create an external conversation. An external conversation is one where the provider is not PureCloud based.
 * @property {string} [htmlBody] - An HTML body content of the email.
 * @property {string} [textBody] - A text body content of the email.
 * @property {string} [externalContactId] - The external contact with which the email should be associated. This field is only valid for OUTBOUND email.
 * @property {string} [utilizationLabel] - Optional. The ID of the label to controls the number of agent interactions for INBOUND communications
 */
 
/**
 * @typedef {object} CreateOutboundMessagingConversationRequest
 * @property {string} queueId - The ID of the queue to be associated with the message. This will determine the fromAddress of the message, unless useUserFromAddress is true and the queue is configured to use the agent's Direct Routing address as the fromAddress.
 * @property {string} toAddress - The messaging address of the recipient of the message. For an SMS messenger type, the phone number address must be in E.164 format. E.g. +13175555555 or +34234234234.  For open messenger type, any string within the outbound.open.messaging.to.address.characters.max limit can be used. For whatsapp messenger type, use a Whatsapp ID of a phone number. E.g for a E.164 formatted phone number `+13175555555`, a Whatsapp ID would be 13175555555
 * @property {string} toAddressMessengerType - The messaging address messenger type.
 * @property {boolean} [useExistingConversation] - An override to use an existing conversation. 
If set to true, an existing conversation will be used if there is one within the conversation window. 
If set to false, create request fails if there is a conversation within the conversation window.
 * @property {string} [externalContactId] - The external contact with which the message will be associated.
 * @property {boolean} [useUserFromAddress] - An override to attempt to use the user's configured direct routing address as the fromAddress. 
If set to true, users configured address with 'directrouting' integration will be used as fromAddress. 
If set to false or not set, the queueId will be used for determining fromAddress.
 */
 
/**
 * @typedef {object} CreateSecureSession
 * @property {string} [sourceParticipantId] - requesting participant
 * @property {string} flowId - the flow id to execute in the secure session
 * @property {string} userData - user data for the secure session
 * @property {boolean} [disconnect] - if true, disconnect the agent after creating the session
 */
 
/**
 * @typedef {object} CreateWebChatMessageRequest
 * @property {string} body - The message body. Note that message bodies are limited to 4,000 characters.
 * @property {string} [bodyType] - The purpose of the message within the conversation, such as a standard text entry versus a greeting.
 */
 
/**
 * @typedef {object} CreateWebChatRequest
 * @property {string} queueId - The ID of the queue to use for routing the chat conversation.
 * @property {string} provider - The name of the provider that is sourcing the web chat.
 * @property {string[]} [skillIds] - The list of skill ID's to use for routing.
 * @property {string} [languageId] - The ID of the langauge to use for routing.
 * @property {number} [priority] - The priority to assign to the conversation for routing.
 * @property {object} [attributes] - The list of attributes to associate with the customer participant.
 * @property {string} [customerName] - The name of the customer participating in the web chat.
 */
 
/**
 * @typedef {object} Destination
 * @property {string} [address] - Address or phone number.
 * @property {string} [name] - The name of the internal user.
 * @property {string} [userId] - The user ID.
 * @property {string} [queueId] - The queue ID.
 */
 
/**
 * @typedef {object} Detail
 * @property {string} [errorCode]
 * @property {string} [fieldName]
 * @property {string} [entityId]
 * @property {string} [entityName]
 */
 
/**
 * @typedef {object} DialerPreview
 * @property {string} [id]
 * @property {string} [contactId] - The contact associated with this preview data pop
 * @property {string} [contactListId] - The contactList associated with this preview data pop.
 * @property {string} [campaignId] - The campaignId associated with this preview data pop.
 * @property {PhoneNumberColumn[]} [phoneNumberColumns] - The phone number columns associated with this campaign
 * @property {boolean} [callbackAutoAnswer] - Whether or not to auto answer the callback
 */
 
/**
 * @typedef {object} Digits
 * @property {string} [digits] - A string representing the digits pressed on phone.
 */
 
/**
 * @typedef {object} DirectRouting
 * @property {DirectRoutingMediaSettings} [callMediaSettings] - Direct Routing Settings specific to Call media.
 * @property {DirectRoutingMediaSettings} [emailMediaSettings] - Direct Routing Settings specific to Email media.
 * @property {DirectRoutingMediaSettings} [messageMediaSettings] - Direct Routing Settings specific to Message media.
 * @property {string} [backupQueueId] - ID of another queue to be used as the default backup if an agent does not have their Backup Settings configured. If not set, the current queue will be used as backup, but with Direct Routing criteria removed from the conversation.
 * @property {boolean} [waitForAgent] - Flag indicating if Direct Routing interactions should wait for Direct Routing agent or go immediately to selected backup.
 * @property {number} [agentWaitSeconds] - Time (in seconds) that a Direct Routing interaction will wait for Direct Routing agent before going to selected backup. Valid range [60, 864000].
 */
 
/**
 * @typedef {object} DirectRoutingMediaSettings
 * @property {boolean} [useAgentAddressOutbound] - Toggle that enables using an agent's Direct Routing address outbound on behalf of queue for this media type.
 */
 
/**
 * @typedef {object} DisconnectReason
 * @property {string} [type] - Disconnect reason protocol type.
 * @property {number} [code] - Protocol specific reason code. See the Q.850 and SIP specs.
 * @property {string} [phrase] - Human readable English description of the disconnect reason.
 */
 
/**
 * @typedef {object} Disposition
 * @property {string} name - Name of the disposition. Either a platform predefined value, or the name of the disposition in the disposition table..
 * @property {string} [analyzer] - The final media analyzer result that triggered the disposition result, if any.
 * @property {DispositionParameters} [dispositionParameters] - Contains various parameters related to call analysis.
 * @property {string} [detectedSpeechStart] - Absolute time when the speech started. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [detectedSpeechEnd] - Absolute time when the speech ended. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 */
 
/**
 * @typedef {object} DispositionParameters
 * @property {AdjustableLiveSpeakerDetection} [adjustableLiveSpeakerDetection] - ALSD evaluation inputs and output (isPersonalLikely) of the ALSD detector the last time it ran on the call (could be multiple times)
 */
 
/**
 * @typedef {object} Division
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} DivisionEntityRef
 * @property {string} [id]
 * @property {string} [name]
 * @property {string} [selfUri]
 * @property {string} [dateDivisionUpdated] - The time the entity division was last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 */
 
/**
 * @typedef {object} DomainEntityListingEvaluationForm
 * @property {EvaluationForm[]} [entities]
 * @property {number} [pageSize]
 * @property {number} [pageNumber]
 * @property {number} [total]
 * @property {string} [firstUri]
 * @property {string} [lastUri]
 * @property {string} [selfUri]
 * @property {string} [nextUri]
 * @property {string} [previousUri]
 * @property {number} [pageCount]
 */
 
/**
 * @typedef {object} DomainEntityRef
 * @property {string} [id]
 * @property {string} [name]
 * @property {string} [selfUri]
 */
 
/**
 * @typedef {object} DomainRole
 * @property {string} [id] - The ID of the role
 * @property {string} [name] - The name of the role
 */
 
/**
 * @typedef {object} DraftManipulationRequest
 * @property {HistoryHeadersTranslation} [translate] - A set of definitions to translate email attributes and correctly display date and time, for a given language
 * @property {string} [draftType] - The kind of draft that as to be treated. Used to prefix response subject or auto-include information
 */
 
/**
 * @typedef {object} Education
 * @property {string} [school]
 * @property {string} [fieldOfStudy]
 * @property {string} [notes] - Notes about education has a 2000 character limit
 * @property {string} [dateStart] - Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd
 * @property {string} [dateEnd] - Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd
 */
 
/**
 * @typedef {object} Email
 * @property {string} [state] - The connection state of this communication.
 * @property {string} [initialState] - The initial connection state of this communication.
 * @property {string} [id] - A globally unique identifier for this communication.
 * @property {boolean} [held] - True if this call is held and the person on this side hears silence.
 * @property {string} [subject] - The subject for the initial email that started this conversation.
 * @property {number} [messagesSent] - The number of email messages sent by this participant.
 * @property {Segment[]} [segments] - The time line of the participant's email, divided into activity segments.
 * @property {string} [direction] - The direction of the email
 * @property {string} [recordingId] - A globally unique identifier for the recording associated with this call.
 * @property {ErrorBody} [errorInfo]
 * @property {string} [disconnectType] - System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects.
 * @property {string} [startHoldTime] - The timestamp the email was placed on hold in the cloud clock if the email is currently on hold. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [startAlertingTime] - The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [connectedTime] - The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [disconnectedTime] - The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {boolean} [autoGenerated] - Indicates that the email was auto-generated like an Out of Office reply.
 * @property {string} [provider] - The source provider for the email.
 * @property {string} [scriptId] - The UUID of the script to use.
 * @property {string} [peerId] - The id of the peer communication corresponding to a matching leg for this communication.
 * @property {string} [messageId] - A globally unique identifier for the stored content of this communication.
 * @property {Attachment[]} [draftAttachments] - A list of uploaded attachments on the email draft.
 * @property {boolean} [spam] - Indicates if the inbound email was marked as spam.
 * @property {Wrapup} [wrapup] - Call wrap up or disposition data.
 * @property {AfterCallWork} [afterCallWork] - After-call work for the communication.
 * @property {boolean} [afterCallWorkRequired] - Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested.
 * @property {ConversationQueueMediaSettings} [queueMediaSettings] - Represents the queue settings for this media type.
 * @property {string} [parkTime] - Represents the time when an email was put into parked state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 */
 
/**
 * @typedef {object} EmailAddress
 * @property {string} [email]
 * @property {string} [name]
 */
 
/**
 * @typedef {object} EmailMediaSettings
 * @property {boolean} [enableAutoAnswer] - Indicates if auto-answer is enabled for the given media type or subtype (default is false).  Subtype settings take precedence over media type settings.
 * @property {number} [alertingTimeoutSeconds] - The alerting timeout for the media type, in seconds
 * @property {ServiceLevel} [serviceLevel] - The targeted service level for the media type
 * @property {number} [autoAnswerAlertToneSeconds] - How long to play the alerting tone for an auto-answer interaction
 * @property {number} [manualAnswerAlertToneSeconds] - How long to play the alerting tone for a manual-answer interaction
 * @property {object} [subTypeSettings] - Map of media subtype to media subtype specific settings.
 */
 
/**
 * @typedef {object} EmailMessage
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {EmailAddress[]} to - The recipients of the email message.
 * @property {EmailAddress[]} [cc] - The recipients that were copied on the email message.
 * @property {EmailAddress[]} [bcc] - The recipients that were blind copied on the email message.
 * @property {EmailAddress} from - The sender of the email message.
 * @property {EmailAddress} [replyTo] - The receiver of the reply email message.
 * @property {string} [subject] - The subject of the email message.
 * @property {Attachment[]} [attachments] - The attachments of the email message.
 * @property {string} textBody - The text body of the email message.
 * @property {string} [htmlBody] - The html body of the email message.
 * @property {string} [time] - The time when the message was received or sent. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {boolean} [historyIncluded] - Indicates whether the history of previous emails of the conversation is included within the email bodies of this message.
 * @property {string} [state] - The state of the current draft.
 * @property {string} [draftType] - The type of draft that need to be treated.
 * @property {number} [emailSizeBytes] - Indicates an estimation of the size of the current email as a whole, in its final, ready to be sent form.
 * @property {number} [maxEmailSizeBytes] - Indicates the maximum allowed size for an email to be send via SMTP server, based on the email domain configuration
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} EmployerInfo
 * @property {string} [officialName]
 * @property {string} [employeeId]
 * @property {string} [employeeType]
 * @property {string} [dateHire]
 */
 
/**
 * @typedef {object} ErrorBody
 * @property {string} [message]
 * @property {string} [code]
 * @property {number} [status]
 * @property {string} [entityId]
 * @property {string} [entityName]
 * @property {string} [messageWithParams]
 * @property {object} [messageParams]
 * @property {string} [contextId]
 * @property {Detail[]} [details]
 * @property {ErrorBody[]} [errors]
 * @property {Limit} [limit]
 */
 
/**
 * @typedef {object} ErrorInfo
 * @property {string} [message]
 * @property {string} [code]
 */
 
/**
 * @typedef {object} Evaluation
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {ConversationReference} [conversation]
 * @property {EvaluationForm} [evaluationForm] - Evaluation form used for evaluation.
 * @property {User} [evaluator]
 * @property {User} [agent]
 * @property {Calibration} [calibration]
 * @property {string} [status]
 * @property {EvaluationScoringSet} [answers]
 * @property {boolean} [agentHasRead]
 * @property {User} [assignee]
 * @property {boolean} [assigneeApplicable] - Indicates whether an assignee is applicable for the evaluation. Set to false when assignee is not applicable.
 * @property {string} [releaseDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [assignedDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [changedDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [revisionCreatedDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {Queue} [queue]
 * @property {string[]} [mediaType] - List of different communication types used in conversation.
 * @property {boolean} [rescore] - Is only true when evaluation is re-scored.
 * @property {string} [conversationDate] - Date of conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [conversationEndDate] - End date of conversation if it had completed before evaluation creation. Null if created before the conversation ended. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {boolean} [neverRelease] - Signifies if the evaluation is never to be released. This cannot be set true if release date is also set.
 * @property {boolean} [assigned] - Set to false to unassign the evaluation. This cannot be set to false when assignee is also set.
 * @property {string} [dateAssigneeChanged] - Date when the assignee was last changed. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [resourceId] - Only used for email evaluations. Will be null for all other evaluations.
 * @property {string} [resourceType] - The type of resource. Only used for email evaluations. Will be null for evaluations on all other resources.
 * @property {boolean} [redacted] - Is only true when the user making the request does not have sufficient permissions to see evaluation
 * @property {Team} [agentTeam] - Team of the evaluation agent
 * @property {boolean} [isScoringIndex]
 * @property {string[]} [authorizedActions] - List of user authorized actions on evaluation. Possible values: assign, edit, editScore, editAgentSignoff, delete, release, viewAudit
 * @property {boolean} [hasAssistanceFailed] - Is true when evaluation assistance didn't execute successfully
 * @property {EvaluationSource} [evaluationSource] - The source that created the evaluation.
 * @property {AiScoring} [aiScoring] - AI scoring details for the evaluation.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} EvaluationDetailQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {EvaluationDetailQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} EvaluationDetailQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {EvaluationDetailQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {EvaluationDetailQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} EvaluationDetailQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [metric] - Left hand side for metric predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension or metric predicates
 * @property {NumericRange} [range] - Right hand side for dimension or metric predicates
 */
 
/**
 * @typedef {object} EvaluationForm
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The evaluation form name
 * @property {string} [modifiedDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {boolean} [published]
 * @property {string} [contextId]
 * @property {EvaluationQuestionGroup[]} questionGroups - A list of question groups
 * @property {DomainEntityListingEvaluationForm} [publishedVersions] - A list of the published versions of this form. Not populated by default, its availability depends on the endpoint. Use the 'expand=publishHistory' query parameter to retrieve this data where applicable (refer to the endpoint description to see if it is applicable).
 * @property {EvaluationSettings} [evaluationSettings] - Settings for evaluations associated with this form
 * @property {AiScoringSettings} [aiScoring] - AI scoring settings for the evaluation form.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} EvaluationQuestion
 * @property {string} [id]
 * @property {string} [contextId] - An identifier for this question that stays the same across versions of the form.
 * @property {string} [text]
 * @property {string} [helpText]
 * @property {string} [type]
 * @property {boolean} [naEnabled]
 * @property {boolean} [commentsRequired]
 * @property {VisibilityCondition} [visibilityCondition]
 * @property {AnswerOption[]} [answerOptions] - Options from which to choose an answer for this question. Only used by Multiple Choice type questions.
 * @property {boolean} [isKill]
 * @property {boolean} [isCritical]
 */
 
/**
 * @typedef {object} EvaluationQuestionGroup
 * @property {string} [id]
 * @property {string} [contextId] - An identifier for this question group that stays the same across versions of the form.
 * @property {string} [name]
 * @property {string} [type]
 * @property {boolean} [defaultAnswersToHighest]
 * @property {boolean} [defaultAnswersToNA]
 * @property {boolean} [naEnabled]
 * @property {number} [weight]
 * @property {boolean} [manualWeight]
 * @property {EvaluationQuestion[]} [questions]
 * @property {VisibilityCondition} [visibilityCondition]
 */
 
/**
 * @typedef {object} EvaluationQuestionGroupScore
 * @property {string} [questionGroupId]
 * @property {number} [totalScore] - Score of all questions in the group
 * @property {number} [maxTotalScore] - Maximum possible score of all questions in the group
 * @property {boolean} [markedNA] - True when the evaluation is submitted with a question group that does not have any answers. Only allowed when naEnabled is true or if set by the system
 * @property {boolean} [systemMarkedNA] - If markedNA is true, systemMarkedNA indicates whether it was marked by a user or by the system due to visibility conditions. Always false if markedNA is false.
 * @property {number} [totalCriticalScore] - Score of only the critical questions in the group
 * @property {number} [maxTotalCriticalScore] - Maximum possible score of only the critical questions in the group
 * @property {number} [totalNonCriticalScore] - Score of only the non critical questions in the group
 * @property {number} [maxTotalNonCriticalScore] - Maximum possible score of only the non critical questions in the group
 * @property {number} [totalScoreUnweighted] - Unweighted score of all questions in the group
 * @property {number} [maxTotalScoreUnweighted] - Maximum possible unweighted score of all questions in the group
 * @property {number} [totalCriticalScoreUnweighted] - Unweighted score of only the critical questions in the group
 * @property {number} [maxTotalCriticalScoreUnweighted] - Maximum possible unweighted score of only the critical questions in the group
 * @property {number} [totalNonCriticalScoreUnweighted] - Unweighted score of only the non critical questions in the group
 * @property {number} [maxTotalNonCriticalScoreUnweighted] - Maximum possible unweighted score of only the non critical questions in the group
 * @property {EvaluationQuestionScore[]} [questionScores]
 */
 
/**
 * @typedef {object} EvaluationQuestionScore
 * @property {string} [questionId]
 * @property {string} [answerId]
 * @property {number} [score] - Unweighted score of the question
 * @property {boolean} [markedNA] - True when the evaluation is submitted with a question that does not have an answer. Only allowed when naEnabled is true or if set by the system
 * @property {boolean} [systemMarkedNA] - If markedNA is true, systemMarkedNA indicates whether it was marked by a user or by the system due to visibility conditions. Always false if markedNA is false.
 * @property {string} [assistedAnswerId] - AnswerId found with evaluation assistance conditions
 * @property {boolean} [failedKillQuestion] - Applicable only on fatal questions. Indicates that the answer selected was not the highest score available for the question
 * @property {string} [comments] - Comments from the evaluator specific to this question
 * @property {AiAnswer} [aiAnswer] - Suggested AI answer
 */
 
/**
 * @typedef {object} EvaluationScoringSet
 * @property {number} [totalScore] - Score of all questions
 * @property {number} [totalCriticalScore] - Score of only the critical questions
 * @property {number} [totalNonCriticalScore] - Score of only the non-critical questions
 * @property {EvaluationQuestionGroupScore[]} [questionGroupScores]
 * @property {boolean} [anyFailedKillQuestions] - Indicates that at least one fatal question was answered without having the highest score available for the question
 * @property {string} [comments] - Overall comments from the evaluator
 * @property {string} [privateComments] - Overall private comments from the evaluator
 * @property {string} [agentComments] - Comments from the agent while reviewing evaluation results
 * @property {TranscriptTopic[]} [transcriptTopics] - List of topics found within the conversation's transcripts
 */
 
/**
 * @typedef {object} EvaluationSettings
 * @property {boolean} [revisionsEnabled] - Whether revisions are allowed for evaluations. When enabled, rescoring creates a new version of the evaluation and retracts the existing evaluation version. Does not apply for calibration evaluations.
 * @property {boolean} [disputesEnabled] - Whether disputes are allowed for evaluations. Does not apply for calibration evaluations.
 * @property {number} [disputesAllowedPerEvaluation] - The maximum number of disputes allowed for an evaluation.
 * @property {EvaluationSettingsAssignee[]} [disputesAssignees] - A list of assignees responsible for handling each dispute. This list size needs to be equal to disputesAllowedPerEvaluation.
 */
 
/**
 * @typedef {object} EvaluationSettingsAssignee
 * @property {UserReferenceWithName} [user] - The user the dispute should be assigned to
 * @property {string} [type] - The assignee type. Valid values: Original, Individual, None
 */
 
/**
 * @typedef {object} EvaluationSource
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [type] - Type of the evaluation source.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} EventSetting
 * @property {TypingSetting} [typing] - Settings regarding typing events
 */
 
/**
 * @typedef {object} ExpansionCriterium
 * @property {string} [type]
 * @property {number} [threshold]
 */
 
/**
 * @typedef {object} FacebookIntegrationRequest
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The name of the Facebook Integration
 * @property {SupportedContentReference} [supportedContent] - Defines the SupportedContent profile configured for an integration
 * @property {MessagingSettingRequestReference} [messagingSetting] - Defines the message settings to be applied for this integration
 * @property {string} [pageAccessToken] - The long-lived Page Access Token of Facebook page. 
See https://developers.facebook.com/docs/facebook-login/access-tokens. 
When a pageAccessToken is provided, pageId and userAccessToken are not required.
 * @property {string} [userAccessToken] - The short-lived User Access Token of the Facebook user logged into the Facebook app. 
See https://developers.facebook.com/docs/facebook-login/access-tokens. 
When userAccessToken is provided, pageId is mandatory. 
When userAccessToken/pageId combination is provided, pageAccessToken is not required.
 * @property {string} [pageId] - The page Id of Facebook page. The pageId is required when userAccessToken is provided.
 * @property {string} [appId] - The app Id of Facebook app. The appId is required when a customer wants to use their own approved Facebook app.
 * @property {string} [appSecret] - The app Secret of Facebook app. The appSecret is required when appId is provided.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} FacebookIntegrationUpdateRequest
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name] - The name of the Facebook Integration
 * @property {SupportedContentReference} [supportedContent] - Defines the SupportedContent profile configured for an integration
 * @property {MessagingSettingRequestReference} [messagingSetting] - Defines the message settings to be applied for this integration
 * @property {string} [pageAccessToken] - The long-lived Page Access Token of Facebook page. 
See https://developers.facebook.com/docs/facebook-login/access-tokens. 
Either pageAccessToken or userAccessToken should be provided.
 * @property {string} [userAccessToken] - The short-lived User Access Token of the Facebook user logged into the Facebook app. 
See https://developers.facebook.com/docs/facebook-login/access-tokens. 
Either pageAccessToken or userAccessToken should be provided.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} FaxSendRequest
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string[]} addresses - A list of outbound fax dialing addresses. E.g. +13175555555 or 3175555555
 * @property {string} [documentId] - DocumentId of Content Management artifact. If Content Management document is not used for faxing, documentId should be null
 * @property {string} [contentType] - The content type that is going to be uploaded. If Content Management document is used for faxing, contentType will be ignored
 * @property {Workspace} [workspace] - Workspace in which the document should be stored. If Content Management document is used for faxing, workspace will be ignored
 * @property {CoverSheet} [coverSheet] - Data for coversheet generation.
 * @property {number} [timeZoneOffsetMinutes] - Time zone offset minutes from GMT
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} FaxStatus
 * @property {string} [direction] - The fax direction, either "send" or "receive".
 * @property {number} [expectedPages] - Total number of expected pages, if known.
 * @property {number} [activePage] - Active page of the transmission.
 * @property {number} [linesTransmitted] - Number of lines that have completed transmission.
 * @property {number} [bytesTransmitted] - Number of bytes that have competed transmission.
 * @property {number} [baudRate] - Current signaling rate of transmission, baud rate.
 * @property {number} [pageErrors] - Number of page errors.
 * @property {number} [lineErrors] - Number of line errors.
 */
 
/**
 * @typedef {object} Feedback
 * @property {string} suggestionId - Feedback suggestion id.
 * @property {boolean} [userProvided] - Indicates whether the answer/item was clicked by the human agent or not.
 * @property {string} relevance - Feedback relevance.
 */
 
/**
 * @typedef {object} FeedbackAddRequest
 * @property {string} [rating] - Agent’s rating for the system-generated summary.
 * @property {string} summary - Agent's summary for the conversation
 */
 
/**
 * @typedef {object} Geolocation
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [type] - A string used to describe the type of client the geolocation is being updated from e.g. ios, android, web, etc.
 * @property {boolean} [primary] - A boolean used to tell whether or not to set this geolocation client as the primary on a PATCH
 * @property {number} [latitude]
 * @property {number} [longitude]
 * @property {string} [country]
 * @property {string} [region]
 * @property {string} [city]
 * @property {LocationDefinition[]} [locations]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} Group
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The group name.
 * @property {string} [description]
 * @property {string} [dateModified] - Last modified date/time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {number} [memberCount] - Number of members.
 * @property {string} [state] - Active, inactive, or deleted state.
 * @property {number} [version] - Current version for this resource.
 * @property {string} type - Type of group.
 * @property {Image[]} [images]
 * @property {GroupContact[]} [addresses]
 * @property {boolean} rulesVisible - Are membership rules visible to the person requesting to view the group
 * @property {string} visibility - Who can view this group
 * @property {boolean} [rolesEnabled] - Allow roles to be assigned to this group
 * @property {boolean} [includeOwners] - Allow owners to be included as members of the group
 * @property {boolean} [callsEnabled] - Allow calls to be placed to this group.
 * @property {User[]} [owners] - Owners of the group
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} GroupContact
 * @property {string} address - Phone number for this contact type
 * @property {string} [extension] - Extension is set if the number is e164 valid
 * @property {string} [display] - Formatted version of the address property
 * @property {string} type - Contact type of the address
 * @property {string} mediaType - Media type of the address
 */
 
/**
 * @typedef {object} HistoryHeadersTranslation
 * @property {string} from - A translation for the word "from", for the expected language
 * @property {string} to - A translation for the word "to", for the expected language
 * @property {string} cc - A translation for the word "cc", for the expected language
 * @property {string} subject - A translation for the word "subject", for the expected language
 * @property {string} replyPrefix - A translation for the subject prefix "Reply", for the expected language
 * @property {string} forwardPrefix - A translation for the subject prefix "Forward", for the expected language
 * @property {string} sent - A translation for the word "sent", for the expected language
 * @property {string} language - The code of the expected language
 * @property {string} [timeZone] - Timezone used by the agent, used to format the sent email date and time. If not defined, will default to UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 */
 
/**
 * @typedef {object} Image
 * @property {string} [resolution] - Height and/or width of image. ex: 640x480 or x128
 * @property {string} [imageUri]
 */
 
/**
 * @typedef {object} InboundMessageRequest
 * @property {string} [queueId] - The ID of the queue to use for routing the email conversation. This field is mutually exclusive with flowId
 * @property {string} [flowId] - The ID of the flow to use for routing email conversation. This field is mutually exclusive with queueId
 * @property {string} provider - The name of the provider that is sourcing the email such as Oracle, Salesforce, etc.
 * @property {string[]} [skillIds] - The list of skill ID's to use for routing.
 * @property {string} [languageId] - The ID of the language to use for routing.
 * @property {number} [priority] - The priority to assign to the conversation for routing.
 * @property {object} [attributes] - The list of attributes to associate with the customer participant.
 * @property {string} [toAddress] - The email address of the recipient of the email.
 * @property {string} [toName] - The name of the recipient of the email.
 * @property {string} [fromAddress] - The email address of the sender of the email.
 * @property {string} [fromName] - The name of the sender of the email.
 * @property {string} [subject] - The subject of the email
 */
 
/**
 * @typedef {object} InboundOnlySetting
 * @property {string} [inbound]
 */
 
/**
 * @typedef {object} InboundRoute
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} pattern - The search pattern that the mailbox name should match.
 * @property {DomainEntityRef} [queue] - The queue to route the emails to.
 * @property {number} [priority] - The priority to use for routing.
 * @property {DomainEntityRef[]} [skills] - The skills to use for routing.
 * @property {DomainEntityRef} [language] - The language to use for routing.
 * @property {string} fromName - The sender name to use for outgoing replies.
 * @property {string} [fromEmail] - The sender email to use for outgoing replies.
 * @property {DomainEntityRef} [flow] - The flow to use for processing the email.
 * @property {QueueEmailAddress} [replyEmailAddress] - The route to use for email replies.
 * @property {EmailAddress[]} [autoBcc] - The recipients that should be automatically blind copied on outbound emails associated with this InboundRoute.
 * @property {DomainEntityRef} [spamFlow] - The flow to use for processing inbound emails that have been marked as spam.
 * @property {Signature} [signature] - The configuration for the canned response signature that will be appended to outbound emails sent via this route
 * @property {string} [historyInclusion] - The configuration to indicate how the history of a conversation has to be included in a draft
 * @property {boolean} [allowMultipleActions] - Control if multiple actions are allowed on this route. When true the disconnect has to be done manually. When false a conversation will be disconnected by the system after every action
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} InstagramIntegrationRequest
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The name of the Instagram Integration
 * @property {SupportedContentReference} [supportedContent] - Defines the SupportedContent profile configured for an integration
 * @property {MessagingSettingRequestReference} [messagingSetting] - Defines the message settings to be applied for this integration
 * @property {string} [pageAccessToken] - The long-lived Page Access Token of Instagram page. 
See https://developers.facebook.com/docs/facebook-login/access-tokens. 
When a pageAccessToken is provided, pageId and userAccessToken are not required.
 * @property {string} [userAccessToken] - The short-lived User Access Token of Instagram user logged into Facebook app. 
See https://developers.facebook.com/docs/facebook-login/access-tokens. 
When userAccessToken is provided, pageId is mandatory. 
When userAccessToken/pageId combination is provided, pageAccessToken is not required.
 * @property {string} [pageId] - The page ID of Instagram page. The pageId is required when userAccessToken is provided.
 * @property {string} [appId] - The app ID of Facebook app. The appId is required when a customer wants to use their own approved Facebook app.
 * @property {string} [appSecret] - The app Secret of Facebook app. The appSecret is required when appId is provided.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} InstagramIntegrationUpdateRequest
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name] - The name of the Instagram Integration
 * @property {SupportedContentReference} [supportedContent] - Defines the SupportedContent profile configured for an integration
 * @property {MessagingSettingRequestReference} [messagingSetting] - Defines the message settings to be applied for this integration
 * @property {string} [pageAccessToken] - The long-lived Page Access Token of Instagram page. 
See https://developers.facebook.com/docs/facebook-login/access-tokens. 
Either pageAccessToken or userAccessToken should be provided.
 * @property {string} [userAccessToken] - The short-lived User Access Token of the Instagram user logged into the Facebook app. 
See https://developers.facebook.com/docs/facebook-login/access-tokens. 
Either pageAccessToken or userAccessToken should be provided.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} InternalMessage
 * @property {string} [state] - The connection state of this communication.
 * @property {string} [initialState] - The initial connection state of this communication.
 * @property {string} [id] - A globally unique identifier for this communication.
 * @property {Segment[]} [segments] - The time line of the participant's internal message, divided into activity segments.
 * @property {string} [disconnectType] - System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects.
 * @property {string} [connectedTime] - The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [disconnectedTime] - The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [provider] - The source provider for the message.
 * @property {string} [peerId] - The id of the peer communication corresponding to a matching leg for this communication.
 * @property {string} [targetUserId] - The user ID for the participant on receiving side of the internal message conversation.
 * @property {string} [sourceUserId] - The user ID for the participant on sending side of the internal message conversation.
 * @property {Address} [toAddress] - Address for the participant on receiving side of the internal message communication.
 * @property {Address} [fromAddress] - Address for the participant on the sending side of the internal message communication.
 * @property {InternalMessageDetails[]} [messages] - The messages sent on this communication channel.
 */
 
/**
 * @typedef {object} InternalMessageDetails
 * @property {string} [messageId] - UUID identifying the internal message media.
 * @property {string} [messageTime] - The time when the message was sent or received. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 */
 
/**
 * @typedef {object} JourneyAction
 * @property {string} id - The ID of an action from the Journey System (an action is spawned from an actionMap)
 * @property {JourneyActionMap} actionMap - Details about the action map from the Journey System which triggered this action
 */
 
/**
 * @typedef {object} JourneyActionMap
 * @property {string} id - The ID of the actionMap in the Journey System which triggered this action
 * @property {number} version - The version number of the actionMap in the Journey System at the time this action was triggered
 */
 
/**
 * @typedef {object} JourneyContext
 * @property {JourneyCustomer} customer - A subset of the Journey System's customer data at a point-in-time (for external linkage and internal usage/context)
 * @property {JourneyCustomerSession} [customerSession] - A subset of the Journey System's tracked customer session data at a point-in-time (for external linkage and internal usage/context)
 * @property {JourneyAction} [triggeringAction] - A subset of the Journey System's action data relevant to a part of a conversation (for external linkage and internal usage/context)
 */
 
/**
 * @typedef {object} JourneyCustomer
 * @property {string} id - An ID of a customer within the Journey System at a point-in-time.  Note that a customer entity can have multiple customerIds based on the stitching process.  Depending on the context within the PureCloud conversation, this may or may not be mutable.
 * @property {string} idType - The type of the customerId within the Journey System (e.g. cookie).
 */
 
/**
 * @typedef {object} JourneyCustomerSession
 * @property {string} id - An ID of a Customer/User's session within the Journey System at a point-in-time
 * @property {string} type - The type of the Customer/User's session within the Journey System (e.g. web, app)
 */
 
/**
 * @typedef {object} Limit
 * @property {string} [key]
 * @property {string} [namespace]
 * @property {number} [value]
 */
 
/**
 * @typedef {object} Location
 * @property {string} [id] - Unique identifier for the location
 * @property {string} [floorplanId] - Unique identifier for the location floorplan image
 * @property {object} [coordinates] - Users coordinates on the floorplan. Only used when floorplanImage is set
 * @property {string} [notes] - Optional description on the users location
 * @property {LocationDefinition} [locationDefinition]
 */
 
/**
 * @typedef {object} LocationAddress
 * @property {string} [city]
 * @property {string} [country]
 * @property {string} [countryName]
 * @property {string} [state]
 * @property {string} [street1]
 * @property {string} [street2]
 * @property {string} [zipcode]
 */
 
/**
 * @typedef {object} LocationAddressVerificationDetails
 * @property {string} [status] - Status of address verification process
 * @property {string} [dateFinished] - Finished time of address verification process. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateStarted] - Time started of address verification process. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [service] - Third party service used for address verification
 */
 
/**
 * @typedef {object} LocationDefinition
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {AddressableEntityRef} [contactUser] - Site contact for the location entity
 * @property {LocationEmergencyNumber} [emergencyNumber] - Emergency number for the location entity
 * @property {LocationAddress} [address]
 * @property {string} [state] - Current state of the location entity
 * @property {string} [notes] - Notes for the location entity
 * @property {number} [version] - Current version of the location entity, value to be supplied should be retrieved by a GET or on create/update response
 * @property {string[]} [path] - A list of ancestor IDs in order
 * @property {LocationImage[]} [profileImage] - Profile image of the location entity, retrieved with ?expand=images query parameter
 * @property {LocationImage[]} [floorplanImage] - Floorplan images of the location entity, retrieved with ?expand=images query parameter
 * @property {LocationAddressVerificationDetails} [addressVerificationDetails] - Address verification information, retrieve dwith the ?expand=addressVerificationDetails query parameter
 * @property {boolean} [addressVerified] - Boolean field which states if the address has been verified as an actual address
 * @property {boolean} [addressStored] - Boolean field which states if the address has been stored for E911
 * @property {string} [images]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} LocationEmergencyNumber
 * @property {string} [e164]
 * @property {string} [number]
 * @property {string} [type] - The type of emergency number.
 */
 
/**
 * @typedef {object} LocationImage
 * @property {string} [resolution] - Height and/or width of image. ex: 640x480 or x128
 * @property {string} [imageUri]
 */
 
/**
 * @typedef {object} MediaParticipantRequest
 * @property {WrapupInput} [wrapup] - Wrap-up to assign to this participant.
 * @property {string} [state] - The state to update to set for this participant's communications.  Possible values are: 'connected' and 'disconnected'.
 * @property {boolean} [recording] - True to enable recording of this participant, otherwise false to disable recording.
 * @property {boolean} [muted] - True to mute this conversation participant.
 * @property {boolean} [confined] - True to confine this conversation participant.  Should only be used for ad-hoc conferences
 * @property {boolean} [held] - True to hold this conversation participant.
 * @property {boolean} [wrapupSkipped] - True to skip wrap-up for this participant.
 */
 
/**
 * @typedef {object} MediaSettings
 * @property {boolean} [enableAutoAnswer] - Indicates if auto-answer is enabled for the given media type or subtype (default is false).  Subtype settings take precedence over media type settings.
 * @property {number} [alertingTimeoutSeconds] - The alerting timeout for the media type, in seconds
 * @property {ServiceLevel} [serviceLevel] - The targeted service level for the media type
 * @property {number} [autoAnswerAlertToneSeconds] - How long to play the alerting tone for an auto-answer interaction
 * @property {number} [manualAnswerAlertToneSeconds] - How long to play the alerting tone for a manual-answer interaction
 * @property {object} [subTypeSettings] - Map of media subtype to media subtype specific settings.
 */
 
/**
 * @typedef {object} MediaSummary
 * @property {MediaSummaryDetail} [contactCenter]
 * @property {MediaSummaryDetail} [enterprise]
 */
 
/**
 * @typedef {object} MediaSummaryDetail
 * @property {number} [active]
 * @property {number} [acw]
 */
 
/**
 * Media type definition
 * @typedef {object} MediaType
 * @property {string} [type] - The media type string as defined by RFC 2046. You can define specific types such as 'image/jpeg', 'video/mpeg', or specify wild cards for a range of types, 'image/*', or all types '* /*'. See https://www.iana.org/assignments/media-types/media-types.xhtml for a list of registered media types.
 */
 
/**
 * Media type access definitions
 * @typedef {object} MediaTypeAccess
 * @property {MediaType[]} [inbound] - List of media types allowed for inbound messages from customers. If inbound messages from a customer contain media that is not in this list, the media will be dropped from the outbound message.
 * @property {MediaType[]} [outbound] - List of media types allowed for outbound messages to customers. If an outbound message is sent that contains media that is not in this list, the message will not be sent.
 */
 
/**
 * Media types
 * @typedef {object} MediaTypes
 * @property {MediaTypeAccess} [allow] - Specify allowed media types for inbound and outbound messages. If this field is empty, all inbound and outbound media will be blocked.
 */
 
/**
 * @typedef {object} MemberGroup
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {WritableDivision} [division] - The division to which this entity belongs.
 * @property {string} [type] - The group type
 * @property {number} [memberCount] - The number of members in this group
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} Message
 * @property {string} [state] - The connection state of this communication.
 * @property {string} [initialState] - The initial connection state of this communication.
 * @property {string} [id] - A globally unique identifier for this communication.
 * @property {boolean} [held] - True if this call is held and the person on this side hears silence.
 * @property {Segment[]} [segments] - The time line of the participant's message, divided into activity segments.
 * @property {string} [direction] - The direction of the message.
 * @property {string} [recordingId] - A globally unique identifier for the recording associated with this message.
 * @property {ErrorBody} [errorInfo]
 * @property {string} [disconnectType] - System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects.
 * @property {string} [startHoldTime] - The timestamp the message was placed on hold in the cloud clock if the message is currently on hold. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [startAlertingTime] - The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [connectedTime] - The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [disconnectedTime] - The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [provider] - The source provider for the message.
 * @property {boolean} [authenticated] - If true, the participant member is authenticated.
 * @property {string} [type] - Indicates the type of message platform from which the message originated.
 * @property {string} [recipientCountry] - Indicates the country where the recipient is associated in ISO 3166-1 alpha-2 format.
 * @property {string} [recipientType] - The type of the recipient. Eg: Provisioned phoneNumber is the recipient for sms message type.
 * @property {string} [scriptId] - The UUID of the script to use.
 * @property {string} [peerId] - The id of the peer communication corresponding to a matching leg for this communication.
 * @property {Address} [toAddress] - Address and name data for a call endpoint.
 * @property {Address} [fromAddress] - Address and name data for a call endpoint.
 * @property {MessageDetails[]} [messages] - The messages sent on this communication channel.
 * @property {JourneyContext} [journeyContext] - A subset of the Journey System's data relevant to a part of a conversation (for external linkage and internal usage/context).
 * @property {Wrapup} [wrapup] - Call wrap up or disposition data.
 * @property {AfterCallWork} [afterCallWork] - After-call work for the communication.
 * @property {boolean} [afterCallWorkRequired] - Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested.
 * @property {string} [agentAssistantId] - UUID of virtual agent assistant that provide suggestions to the agent participant during the conversation.
 * @property {string} [byoSmsIntegrationId] - The internal id representing the customer supplied sms integration message.
 * @property {ConversationQueueMediaSettings} [queueMediaSettings] - Represents the queue settings for this media type.
 */
 
/**
 * @typedef {object} MessageDetails
 * @property {string} [messageId] - UUID identifying the message media.
 * @property {string} [messageURI] - A URI for this message entity.
 * @property {string} [messageStatus] - Indicates the delivery status of the message.
 * @property {number} [messageSegmentCount] - The message segment count, greater than 1 if the message content was split into multiple parts for this message type, e.g. SMS character limits.
 * @property {string} [messageTime] - The time when the message was sent or received. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {MessageMedia[]} [media] - The media (images, files, etc) associated with this message, if any
 * @property {MessageSticker[]} [stickers] - One or more stickers associated with this message, if any
 * @property {ConversationMessageMetadata} [messageMetadata] - Information that describes the content of the message, if any
 * @property {string} [socialVisibility] - For social media messages, the visibility of the message in the originating social platform
 * @property {ErrorBody} [errorInfo] - Provider specific error information for a communication.
 */
 
/**
 * @typedef {object} MessageMedia
 * @property {string} [url] - The location of the media, useful for retrieving it
 * @property {string} [mediaType] - The optional internet media type of the the media object.  If null then the media type should be dictated by the url
 * @property {number} [contentLengthBytes] - The optional content length of the the media object, in bytes.
 * @property {string} [name] - The optional name of the the media object.
 * @property {string} [id] - The optional id of the the media object.
 */
 
/**
 * @typedef {object} MessageMediaSettings
 * @property {boolean} [enableAutoAnswer] - Indicates if auto-answer is enabled for the given media type or subtype (default is false).  Subtype settings take precedence over media type settings.
 * @property {number} [alertingTimeoutSeconds] - The alerting timeout for the media type, in seconds
 * @property {ServiceLevel} [serviceLevel] - The targeted service level for the media type
 * @property {number} [autoAnswerAlertToneSeconds] - How long to play the alerting tone for an auto-answer interaction
 * @property {number} [manualAnswerAlertToneSeconds] - How long to play the alerting tone for a manual-answer interaction
 * @property {object} [subTypeSettings] - Map of media subtype to media subtype specific settings.
 */
 
/**
 * @typedef {object} MessageSticker
 * @property {string} [url] - The location of the sticker, useful for retrieving it
 * @property {string} [id] - The unique id of the the sticker object.
 */
 
/**
 * @typedef {object} MessageTypingEventRequest
 * @property {ConversationEventTyping} typing - Typing event
 * @property {string} [dateSent] - The time when the message typing event was sent. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 */
 
/**
 * @typedef {object} MessagingSettingDefaultRequest
 * @property {string} settingId - Messaging Setting ID to be used as the default for this Organization.
 */
 
/**
 * Messaging setting for messaging platform integrations
 * @typedef {object} MessagingSettingPatchRequest
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name] - The messaging Setting profile name
 * @property {ContentSetting} [content] - Settings relating to message contents
 * @property {EventSetting} [event] - Settings relating to events which may occur
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * Messaging setting for messaging platform integrations
 * @typedef {object} MessagingSettingRequest
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The messaging Setting profile name
 * @property {ContentSetting} [content] - Settings relating to message contents
 * @property {EventSetting} [event] - Settings relating to events which may occur
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * Messaging Setting for messaging platform integrations
 * @typedef {object} MessagingSettingRequestReference
 * @property {string} id - The messaging Setting unique identifier associated with this integration
 */
 
/**
 * @typedef {object} NumericRange
 * @property {number} [gt] - Greater than
 * @property {number} [gte] - Greater than or equal to
 * @property {number} [lt] - Less than
 * @property {number} [lte] - Less than or equal to
 */
 
/**
 * @typedef {object} OAuthLastTokenIssued
 * @property {string} [dateIssued] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 */
 
/**
 * Attachment object.
 * @typedef {object} OpenContentAttachment
 * @property {string} [id] - Provider specific ID for attachment. For example, middleware media UUID.
 * @property {string} mediaType - The type of attachment this instance represents.
 * @property {string} url - URL of the attachment.
 * @property {string} mime - Attachment mime type (https://www.iana.org/assignments/media-types/media-types.xhtml).
 * @property {string} [text] - Text associated with attachment such as an image caption.
 * @property {string} [sha256] - Secure hash of the attachment content.
 * @property {string} [filename] - Suggested file name for attachment.
 */
 
/**
 * Message event element.
 * @typedef {object} OpenEvent
 * @property {string} eventType - Type of this event element
 */
 
/**
 * Message content element.
 * @typedef {object} OpenInboundMessageContent
 * @property {OpenContentAttachment} [attachment] - Attachment content.
 */
 
/**
 * Open Channel-specific information that describes the message and the message channel/provider, with additional message information
 * @typedef {object} OpenInboundMessageMessagingChannel
 * @property {OpenMessagingFromRecipient} from - Information about the recipient the message is received from.
 * @property {string} time - Original time of the event. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [messageId] - Unique provider ID of the message.
 * @property {ConversationChannelMetadata} [metadata] - Additional Custom Information about the channel.
 */
 
/**
 * Open Channel-specific information that describes the message and the message channel/provider.
 * @typedef {object} OpenInboundMessagingChannel
 * @property {OpenMessagingFromRecipient} from - Information about the recipient the message is received from.
 * @property {string} time - Original time of the event. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 */
 
/**
 * Open Channel-specific information that describes the message and the message channel/provider.
 * @typedef {object} OpenInboundMessagingReceiptChannel
 * @property {OpenMessagingToRecipient} to - Information about the recipient the message is intended for.
 * @property {string} time - Original time of the event. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 */
 
/**
 * Open Event Messaging rich media message structure
 * @typedef {object} OpenInboundNormalizedEvent
 * @property {OpenInboundMessagingChannel} channel - Channel-specific information that describes the message and the message channel/provider.
 * @property {OpenEvent[]} events - List of event elements.
 */
 
/**
 * Open Messaging rich media message structure
 * @typedef {object} OpenInboundNormalizedMessage
 * @property {OpenInboundMessageMessagingChannel} channel - Channel-specific information that describes the message and the message channel/provider.
 * @property {string} [text] - Message text.
 * @property {OpenInboundMessageContent[]} [content] - List of content elements.
 * @property {object} [metadata] - Additional metadata about this message to capture non-channel specific data.
 */
 
/**
 * Open Messaging rich media message structure
 * @typedef {object} OpenInboundNormalizedReceipt
 * @property {string} id - The original unique message Id generated by the messaging platform, that this receipt message is referencing.
 * @property {OpenInboundMessagingReceiptChannel} channel - Channel-specific information that describes the message and the message channel/provider.
 * @property {string} status - Message receipt status.
 * @property {ConversationReason[]} [reasons] - List of reasons for a message receipt that indicates the message has failed. Only used with Failed status.
 * @property {boolean} [isFinalReceipt] - Indicates if this is the last message receipt for this message, or if another message receipt can be expected.
 */
 
/**
 * @typedef {object} OpenIntegrationRequest
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The name of the Open messaging integration.
 * @property {SupportedContentReference} [supportedContent] - Defines the SupportedContent profile configured for an integration
 * @property {MessagingSettingRequestReference} [messagingSetting] - Defines the message settings to be applied for this integration
 * @property {string} outboundNotificationWebhookUrl - The outbound notification webhook URL for the Open messaging integration.
 * @property {string} outboundNotificationWebhookSignatureSecretToken - The outbound notification webhook signature secret token. This token must be longer than 15 characters.
 * @property {object} [webhookHeaders] - The user specified headers for the Open messaging integration.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} OpenIntegrationUpdateRequest
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The name of the Open messaging integration.
 * @property {SupportedContentReference} [supportedContent] - Defines the SupportedContent profile configured for an integration
 * @property {MessagingSettingRequestReference} [messagingSetting] - Defines the message settings to be applied for this integration
 * @property {string} [outboundNotificationWebhookUrl] - The outbound notification webhook URL for the Open messaging integration.
 * @property {string} [outboundNotificationWebhookSignatureSecretToken] - The outbound notification webhook signature secret token.
 * @property {object} [webhookHeaders] - The user specified headers for the Open messaging integration.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * Message content element.
 * @typedef {object} OpenMessageContent
 * @property {string} contentType - Type of this content element. If contentType = "Attachment" only one item is allowed.
 * @property {ConversationContentAttachment} [attachment] - Attachment content.
 */
 
/**
 * Channel-specific information that describes the message and the message channel/provider.
 * @typedef {object} OpenMessagingChannel
 * @property {string} [id] - The Messaging Platform integration ID.
 * @property {string} [platform] - The provider type.
 * @property {string} [type] - Specifies if this message is part of a private or public conversation.
 * @property {string} [messageId] - Unique provider ID of the message such as a Facebook message ID.
 * @property {OpenMessagingToRecipient} to - Information about the recipient the message is sent to.
 * @property {OpenMessagingFromRecipient} from - Information about the recipient the message is received from.
 * @property {string} time - Original time of the event. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {ConversationChannelMetadata} [metadata] - Information about the channel.
 */
 
/**
 * Information about the recipient the message is received from.
 * @typedef {object} OpenMessagingFromRecipient
 * @property {string} [nickname] - Nickname or display name of the recipient.
 * @property {string} id - The recipient ID specific to the provider.
 * @property {string} idType - The recipient ID type. This is used to indicate the format used for the ID.
 * @property {string} [firstName] - First name of the recipient.
 * @property {string} [lastName] - Last name of the recipient.
 * @property {string} [image] - URL of an image that represents the recipient.
 * @property {string} [email] - E-mail address of the recipient.
 */
 
/**
 * Information about the recipient the message is sent to.
 * @typedef {object} OpenMessagingToRecipient
 * @property {string} [nickname] - Nickname or display name of the recipient.
 * @property {string} id - The recipient ID specific to the provider.
 * @property {string} [idType] - The recipient ID type. This is used to indicate the format used for the ID.
 * @property {string} [firstName] - First name of the recipient.
 * @property {string} [lastName] - Last name of the recipient.
 * @property {string} [image] - URL of an image that represents the recipient.
 * @property {string} [email] - E-mail address of the recipient.
 */
 
/**
 * Open Messaging rich media message structure
 * @typedef {object} OpenNormalizedMessage
 * @property {string} [id] - Unique ID of the message. This ID is generated by Messaging Platform. Message receipts will have the same ID as the message they reference, as such should only be set when sending a message receipt.
 * @property {OpenMessagingChannel} channel - Channel-specific information that describes the message and the message channel/provider.
 * @property {string} type - Message type.
 * @property {string} [text] - Message text.
 * @property {OpenMessageContent[]} [content] - List of content elements.
 * @property {string} [status] - Message receipt status, only used with type Receipt.
 * @property {ConversationReason[]} [reasons] - List of reasons for a message receipt that indicates the message has failed. Only used with Failed status.
 * @property {boolean} [isFinalReceipt] - Indicates if this is the last message receipt for this message, or if another message receipt can be expected.
 * @property {string} [direction] - The direction of the message.
 * @property {object} [metadata] - Additional metadata about this message.
 */
 
/**
 * @typedef {object} OutOfOffice
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {User} [user]
 * @property {string} [startDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [endDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {boolean} [active]
 * @property {boolean} [indefinite]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} PagingSpec
 * @property {number} pageSize - How many results per page
 * @property {number} pageNumber - How many pages in
 */
 
/**
 * @typedef {object} ParkingStateRequest
 * @property {string} state - State to set the participant.
 */
 
/**
 * @typedef {object} Participant
 * @property {string} [id] - A globally unique identifier for this conversation.
 * @property {string} [startTime] - The timestamp when this participant joined the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [endTime] - The timestamp when this participant disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [connectedTime] - The timestamp when this participant was connected to the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [name] - A human readable name identifying the participant.
 * @property {string} [userUri] - If this participant represents a user, then this will be an URI that can be used to fetch the user.
 * @property {string} [userId] - If this participant represents a user, then this will be the globally unique identifier for the user.
 * @property {string} [externalContactId] - If this participant represents an external contact, then this will be the globally unique identifier for the external contact.
 * @property {string} [externalContactInitialDivisionId] - If this participant represents an external contact, then this will be the initial division for the external contact. This value will not be updated if the external contact is reassigned.
 * @property {string} [externalOrganizationId] - If this participant represents an external org, then this will be the globally unique identifier for the external org.
 * @property {string} [queueId] - If present, the queue id that the communication channel came in on.
 * @property {string} [groupId] - If present, group of users the participant represents.
 * @property {string} [teamId] - The team id that this participant is a member of when added to the conversation.
 * @property {string} [queueName] - If present, the queue name that the communication channel came in on.
 * @property {string} [purpose] - A well known string that specifies the purpose of this participant.
 * @property {string} [participantType] - A well known string that specifies the type of this participant.
 * @property {string} [consultParticipantId] - If this participant is part of a consult transfer, then this will be the participant id of the participant being transferred.
 * @property {string} [address] - The address for the this participant. For a phone call this will be the ANI.
 * @property {string} [ani] - The address for the this participant. For a phone call this will be the ANI.
 * @property {string} [aniName] - The ani-based name for this participant.
 * @property {string} [dnis] - The address for the this participant. For a phone call this will be the ANI.
 * @property {string} [locale] - An ISO 639 language code specifying the locale for this participant
 * @property {boolean} [wrapupRequired] - True iff this participant is required to enter wrapup for this conversation.
 * @property {string} [wrapupPrompt] - This field controls how the UI prompts the agent for a wrapup.
 * @property {number} [wrapupTimeoutMs] - Specifies how long a timed ACW session will last.
 * @property {boolean} [wrapupSkipped] - The UI sets this field when the agent chooses to skip entering a wrapup for this participant.
 * @property {Wrapup} [wrapup] - Call wrap up or disposition data.
 * @property {string[]} [mediaRoles] - List of roles this participant's media has had on the conversation, ie monitor, coach, etc.
 * @property {ConversationRoutingData} [conversationRoutingData] - Information on how a communication should be routed to an agent.
 * @property {number} [alertingTimeoutMs] - Specifies how long the agent has to answer an interaction before being marked as not responding.
 * @property {string} [monitoredParticipantId] - If this participant is a monitor, then this will be the id of the participant that is being monitored.
 * @property {string} [coachedParticipantId] - If this participant is a coach, then this will be the id of the participant that is being coached.
 * @property {object} [attributes] - Additional participant attributes
 * @property {Call[]} [calls]
 * @property {Callback[]} [callbacks]
 * @property {ConversationChat[]} [chats]
 * @property {Cobrowsesession[]} [cobrowsesessions]
 * @property {Email[]} [emails]
 * @property {Message[]} [messages]
 * @property {Screenshare[]} [screenshares]
 * @property {SocialExpression[]} [socialExpressions]
 * @property {Video[]} [videos]
 * @property {Evaluation[]} [evaluations]
 * @property {string} [screenRecordingState] - The current screen recording state for this participant.
 * @property {string} [flaggedReason] - The reason specifying why participant flagged the conversation.
 * @property {string} [startAcwTime] - The timestamp when this participant started after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [endAcwTime] - The timestamp when this participant ended after-call work. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {InternalMessage[]} [internalMessages]
 * @property {string} [bargedParticipantId] - If this participant barged in a participant's call, then this will be the id of the targeted participant.
 */
 
/**
 * @typedef {object} ParticipantAttributes
 * @property {object} [attributes] - The map of attribute keys to values.
 */
 
/**
 * @typedef {object} PatchCallbackRequest
 * @property {string} conversationId - The conversationId.
 * @property {string} [queueId] - The identifier of the queue to be used for the callback.
 * @property {string} agentId - The agentId.
 * @property {string} [callbackScheduledTime] - The scheduled date-time for the callback. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 */
 
/**
 * @typedef {object} PhoneNumberColumn
 * @property {string} [columnName]
 * @property {string} [type]
 */
 
/**
 * @typedef {object} PresenceDefinition
 * @property {string} [id] - description
 * @property {string} [systemPresence]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} PropertyIndexRequest
 * @property {string} sessionId - Attach properties to a segment in the indicated session
 * @property {string} targetDate - Attach properties to a segment covering a specific point in time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {AnalyticsProperty[]} properties - The list of properties to index
 */
 
/**
 * @typedef {object} QuestionGroupSettings
 * @property {string} [questionGroupContextId] - The context id of the question group in the form.
 * @property {QuestionSettings[]} [questionSettings]
 */
 
/**
 * @typedef {object} QuestionSettings
 * @property {string} [questionContextId] - The context id of the question in the group
 * @property {AiScoringSetting} [settings]
 */
 
/**
 * @typedef {object} Queue
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {Division} [division] - The division to which this entity belongs.
 * @property {string} [description] - The queue description.
 * @property {string} [dateCreated] - The date the queue was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateModified] - The date of the last modification to the queue. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [modifiedBy] - The ID of the user that last modified the queue.
 * @property {string} [createdBy] - The ID of the user that created the queue.
 * @property {number} [memberCount] - The total number of members in the queue.
 * @property {number} [userMemberCount] - The number of user members (i.e., non-group members) in the queue.
 * @property {number} [joinedMemberCount] - The number of joined members in the queue.
 * @property {QueueMediaSettings} [mediaSettings] - The media settings for the queue.
 * @property {RoutingRule[]} [routingRules] - The routing rules for the queue, used for Preferred Agent Routing.
 * @property {ConditionalGroupRouting} [conditionalGroupRouting] - The Conditional Group Routing settings for the queue.
 * @property {Bullseye} [bullseye] - The bullseye settings for the queue.
 * @property {string} [scoringMethod] - The Scoring Method for the queue.
 * @property {string} [lastAgentRoutingMode] - The Last Agent Routing Mode for the queue.
 * @property {AcwSettings} [acwSettings] - The ACW settings for the queue.
 * @property {string} [skillEvaluationMethod] - The skill evaluation method to use when routing conversations.
 * @property {MemberGroup[]} [memberGroups] - The groups of agents associated with the queue, if any.  Queue membership will update to match group membership changes.
 * @property {DomainEntityRef} [queueFlow] - The in-queue flow to use for call conversations waiting in queue.
 * @property {DomainEntityRef} [emailInQueueFlow] - The in-queue flow to use for email conversations waiting in queue.
 * @property {DomainEntityRef} [messageInQueueFlow] - The in-queue flow to use for message conversations waiting in queue.
 * @property {DomainEntityRef} [whisperPrompt] - The prompt used for whisper on the queue, if configured.
 * @property {DomainEntityRef} [onHoldPrompt] - The audio to be played when calls on this queue are on hold. If not configured, the default on-hold music will play.
 * @property {boolean} [autoAnswerOnly] - Specifies whether the configured whisper should play for all ACD calls, or only for those which are auto-answered.
 * @property {CannedResponseLibraries} [cannedResponseLibraries] - Canned response library IDs and mode with which they are associated with the queue
 * @property {boolean} [enableTranscription] - Indicates whether voice transcription is enabled for this queue.
 * @property {boolean} [enableAudioMonitoring] - Indicates whether audio monitoring is enabled for this queue.
 * @property {boolean} [enableManualAssignment] - Indicates whether manual assignment is enabled for this queue.
 * @property {AgentOwnedRouting} [agentOwnedRouting] - The Agent Owned Routing settings for the queue
 * @property {DirectRouting} [directRouting] - The Direct Routing settings for the queue
 * @property {string} [callingPartyName] - The name to use for caller identification for outbound calls from this queue.
 * @property {string} [callingPartyNumber] - The phone number to use for caller identification for outbound calls from this queue.
 * @property {object} [defaultScripts] - The default script Ids for the communication types.
 * @property {QueueMessagingAddresses} [outboundMessagingAddresses] - The messaging addresses for the queue.
 * @property {QueueEmailAddress} [outboundEmailAddress] - The default email address to use for outbound email from this queue.
 * @property {string} [peerId] - The ID of an associated external queue.
 * @property {boolean} [suppressInQueueCallRecording] - Indicates whether recording in-queue calls is suppressed for this queue.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} QueueEmailAddress
 * @property {DomainEntityRef} [domain]
 * @property {InboundRoute} [route]
 */
 
/**
 * @typedef {object} QueueMediaSettings
 * @property {MediaSettings} [call] - The queue media settings for call interactions.
 * @property {CallbackMediaSettings} [callback] - The queue media settings for callback interactions.
 * @property {MediaSettings} [chat] - The queue media settings for chat interactions.
 * @property {EmailMediaSettings} [email] - The queue media settings for email interactions.
 * @property {MessageMediaSettings} [message] - The queue media settings for message interactions.
 */
 
/**
 * @typedef {object} QueueMessagingAddresses
 * @property {DomainEntityRef} [smsAddress]
 * @property {DomainEntityRef} [openMessagingRecipient]
 * @property {DomainEntityRef} [whatsAppRecipient]
 */
 
/**
 * @typedef {object} RecordersState
 * @property {string} [adhocState] - Indicates the state of the adhoc recorder.
 * @property {string} [customerExperienceState] - Indicates the state of the customer experience recorder.
 * @property {string} [agentExperienceState] - Indicates the state of the agent experience recorder.
 */
 
/**
 * @typedef {object} ResolutionDetailQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {ResolutionDetailQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ResolutionDetailQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {ResolutionDetailQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {ResolutionDetailQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ResolutionDetailQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [metric] - Left hand side for metric predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for metric predicates
 * @property {NumericRange} [range] - Right hand side for metric predicates
 */
 
/**
 * @typedef {object} ResourceConditionNode
 * @property {string} [variableName]
 * @property {string} [conjunction]
 * @property {string} [operator]
 * @property {ResourceConditionValue[]} [operands]
 * @property {ResourceConditionNode[]} [terms]
 */
 
/**
 * @typedef {object} ResourceConditionValue
 * @property {string} [type]
 * @property {string} [value]
 */
 
/**
 * @typedef {object} ResourcePermissionPolicy
 * @property {string} [id]
 * @property {string} [domain]
 * @property {string} [entityName]
 * @property {string} [policyName]
 * @property {string} [policyDescription]
 * @property {string} [actionSetKey]
 * @property {boolean} [allowConditions]
 * @property {ResourceConditionNode} [resourceConditionNode]
 * @property {string[]} [namedResources]
 * @property {string} [resourceCondition]
 * @property {string[]} [actionSet]
 */
 
/**
 * @typedef {object} Ring
 * @property {ExpansionCriterium[]} [expansionCriteria] - The conditions that will trigger conversations to move to the next bullseye ring.
 * @property {Actions} [actions] - The actions that will be performed just before moving conversations to the next bullseye ring.
 * @property {MemberGroup[]} [memberGroups] - The groups of agents associated with the ring, if any.  Ring membership will update to match group membership changes.
 */
 
/**
 * @typedef {object} RoutingData
 * @property {string} queueId - The identifier of the routing queue
 * @property {string} [languageId] - The identifier of a language to be considered in routing
 * @property {string} [label] - An optional label that categorizes the conversation.  Max-utilization settings can be configured at a per-label level
 * @property {number} [priority] - The priority for routing
 * @property {string[]} [skillIds] - A list of skill identifiers to be considered in routing
 * @property {string[]} [preferredAgentIds] - A list of agents to be preferred in routing
 * @property {ScoredAgent[]} [scoredAgents] - A list of scored agents for routing decisions. For Agent Owned Callbacks use one scored agent with a score of 100.
 * @property {string[]} [routingFlags] - An array of flags indicating how the conversation should be routed. Use "AGENT_OWNED_CALLBACK" when creating an Agent Owned Callback.
 */
 
/**
 * @typedef {object} RoutingRule
 * @property {string} [operator] - matching operator.  MEETS_THRESHOLD matches any agent with a score at or above the rule's threshold.  ANY matches all specified agents, regardless of score.
 * @property {number} [threshold] - threshold required for routing attempt (generally an agent score).  may be null for operator ANY.
 * @property {number} [waitSeconds] - seconds to wait in this rule before moving to the next
 */
 
/**
 * @typedef {object} RoutingStatus
 * @property {string} [userId] - The userId of the agent
 * @property {string} [status] - Indicates the Routing State of the agent.  A value of OFF_QUEUE will be returned if the specified user does not exist.
 * @property {string} [startTime] - The timestamp when the agent went into this state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 */
 
/**
 * @typedef {object} ScoredAgent
 * @property {DomainEntityRef} [agent] - The agent
 * @property {number} [score] - Agent's score for the current conversation, from 0 - 100, higher being better
 */
 
/**
 * @typedef {object} Screenshare
 * @property {string} [state] - The connection state of this communication.
 * @property {string} [initialState] - The initial connection state of this communication.
 * @property {string} [id] - A globally unique identifier for this communication.
 * @property {string} [context] - The room id context (xmpp jid) for the conference session.
 * @property {boolean} [sharing] - Indicates whether this participant is sharing their screen.
 * @property {number} [peerCount] - The number of peer participants from the perspective of the participant in the conference.
 * @property {string} [disconnectType] - System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects.
 * @property {string} [startAlertingTime] - The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [connectedTime] - The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [disconnectedTime] - The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [provider] - The source provider for the screen share.
 * @property {string} [peerId] - The id of the peer communication corresponding to a matching leg for this communication.
 * @property {Segment[]} [segments] - The time line of the participant's call, divided into activity segments.
 * @property {Wrapup} [wrapup] - Call wrap up or disposition data.
 * @property {AfterCallWork} [afterCallWork] - After-call work for the communication.
 * @property {boolean} [afterCallWorkRequired] - Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested.
 */
 
/**
 * @typedef {object} SearchSort
 * @property {string} [sortOrder] - The sort order for results
 * @property {string} [sortBy] - The field in the resource that you want to sort the results by
 */
 
/**
 * @typedef {object} Segment
 * @property {string} startTime - The timestamp when this segment began. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} endTime - The timestamp when this segment ended. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [type] - The activity taking place for the participant in the segment.
 * @property {string} [howEnded] - A description of the event that ended the segment.
 * @property {string} [disconnectType] - A description of the event that disconnected the segment
 */
 
/**
 * @typedef {object} SegmentDetailQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {SegmentDetailQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} SegmentDetailQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {SegmentDetailQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {SegmentDetailQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} SegmentDetailQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [propertyType] - Left hand side for property predicates
 * @property {string} [property] - Left hand side for property predicates
 * @property {string} [metric] - Left hand side for metric predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension, metric, or property predicates
 * @property {NumericRange} [range] - Right hand side for dimension, metric, or property predicates
 */
 
/**
 * @typedef {object} SendAgentlessOutboundMessageRequest
 * @property {string} fromAddress - The messaging address of the sender of the message. For an SMS messenger type, this must be a currently provisioned SMS phone number. For a WhatsApp messenger type use the provisioned WhatsApp integration’s ID
 * @property {string} toAddress - The messaging address of the recipient of the message. For an SMS messenger type, the phone number address must be in E.164 format. E.g. +13175555555 or +34234234234. For WhatsApp messenger type, use a WhatsApp ID of a phone number. E.g for a E.164 formatted phone number `+13175555555`, a WhatsApp ID would be 13175555555
 * @property {string} toAddressMessengerType - The recipient messaging address messenger type.
 * @property {string} [textBody] - The text of the message to send. This field is required in the case of SMS messenger type. Maximum character counts are: SMS - 765 characters, other channels - 2000 characters.
 * @property {SendMessagingTemplateRequest} [messagingTemplate] - The messaging template to use in the case of WhatsApp messenger type. This field is required when using WhatsApp messenger type
 * @property {boolean} [useExistingActiveConversation] - Use an existing active conversation to send the agentless outbound message. Set this parameter to 'true' to use active conversation. Default value: false
 */
 
/**
 * @typedef {object} SendMessagingTemplateRequest
 * @property {string} [responseId] - A Response Management response identifier for a messaging template defined response
 * @property {TemplateParameter[]} [parameters] - A list of Response Management response substitutions for the response's messaging template. (Deprecated) use bodyParameters instead.
 * @property {TemplateParameter[]} [headerParameters] - A list of Response Management header parameter substitutions for the response's messaging template
 * @property {TemplateParameter[]} [bodyParameters] - A list of Response Management body parameter substitutions for the response's messaging template
 * @property {TemplateParameter[]} [buttonUrlParameters] - A list of Response Management button url parameter substitutions for the response's messaging template
 */
 
/**
 * @typedef {object} ServiceLevel
 * @property {number} [percentage] - The desired Service Level. A value between 0 and 1.
 * @property {number} [durationMs] - Service Level target in milliseconds.
 */
 
/**
 * @typedef {object} SetRecordingState
 * @property {string} [recordingState] - On update, 'paused' initiates a secure pause, 'active' resumes any paused recordings.
 */
 
/**
 * @typedef {object} SettingDirection
 * @property {string} [inbound] - Status for the Inbound Direction
 * @property {string} [outbound] - Status for the Outbound Direction
 */
 
/**
 * @typedef {object} Settings
 * @property {boolean} [communicationBasedACW] - Communication Based ACW
 * @property {boolean} [includeNonAgentConversationSummary] - Display communication summary
 * @property {boolean} [allowCallbackQueueSelection] - Allow Callback Queue Selection
 * @property {boolean} [callbacksInheritRoutingFromInboundCall] - Inherit callback routing data from inbound calls
 * @property {boolean} [completeAcwWhenAgentTransitionsOffline] - Complete ACW When Agent Transitions Offline
 * @property {boolean} [totalActiveCallback] - Exclude the 'interacting' duration from the handle calculations of callbacks
 */
 
/**
 * @typedef {object} SetUuiDataRequest
 * @property {string} [uuiData] - The value of the uuiData to set.
 */
 
/**
 * @typedef {object} Signature
 * @property {boolean} [enabled] - A toggle to enable the signature on email send.
 * @property {string} [cannedResponseId] - The identifier referring to an email signature canned response.
 * @property {boolean} [alwaysIncluded] - A toggle that defines if a signature is always included or only set on the first email in an email chain.
 * @property {string} [inclusionType] - The configuration to indicate when the signature of a conversation has to be included
 */
 
/**
 * @typedef {object} SkillsToRemove
 * @property {string} [name]
 * @property {string} [id]
 * @property {string} [selfUri]
 */
 
/**
 * @typedef {object} SocialExpression
 * @property {string} [state] - The connection state of this communication.
 * @property {string} [id] - A globally unique identifier for this communication.
 * @property {string} [socialMediaId] - A globally unique identifier for the social media.
 * @property {string} [socialMediaHub] - The social network of the communication
 * @property {string} [socialUserName] - The user name for the communication.
 * @property {string} [previewText] - The text preview of the communication contents
 * @property {string} [recordingId] - A globally unique identifier for the recording associated with this chat.
 * @property {Segment[]} [segments] - The time line of the participant's chat, divided into activity segments.
 * @property {boolean} [held] - True if this call is held and the person on this side hears silence.
 * @property {string} [disconnectType] - System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects.
 * @property {string} [startHoldTime] - The timestamp the chat was placed on hold in the cloud clock if the chat is currently on hold. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [startAlertingTime] - The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [connectedTime] - The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [disconnectedTime] - The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [provider] - The source provider for the social expression.
 * @property {string} [scriptId] - The UUID of the script to use.
 * @property {string} [peerId] - The id of the peer communication corresponding to a matching leg for this communication.
 * @property {Wrapup} [wrapup] - Call wrap up or disposition data.
 * @property {AfterCallWork} [afterCallWork] - After-call work for the communication.
 * @property {boolean} [afterCallWorkRequired] - Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested.
 */
 
/**
 * @typedef {object} StorySetting
 * @property {InboundOnlySetting} [mention] - Setting relating to Story Mentions
 * @property {InboundOnlySetting} [reply] - Setting relating to Story Replies
 */
 
/**
 * @typedef {object} SuggestionEngagement
 * @property {string} engagementType - The type of engagement with the suggestion.
 * @property {SuggestionFeedback} [feedback] - The given feedback on the suggestion, if any.
 */
 
/**
 * @typedef {object} SuggestionFeedback
 * @property {string} rating - The rating value of the suggestion feedback.
 */
 
/**
 * Supported content profile for inbound and outbound messages
 * @typedef {object} SupportedContent
 * @property {string} id - A unique supported content Id.
 * @property {string} name - The name of the supported content profile
 * @property {string} [dateCreated] - Date this supported content profile was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateModified] - Date this supported content profile was modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {DomainEntityRef} [createdBy] - User reference that created this supported content profile
 * @property {DomainEntityRef} [modifiedBy] - User reference that modified this supported content profile
 * @property {number} [version] - Version number
 * @property {MediaTypes} [mediaTypes] - Defines the allowable media that may be accepted for an inbound message or to be sent in an outbound message. The following is an example of allowing all inbound media, and for outbound all images and only mpeg video: {
  "mediaTypes": {
    "allow": {
      "inbound": [{"type": "* /*"}],
      "outbound": [{"type": "image/*"}, {"type": "video/mpeg"}]
    }
  }
}
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * Reference to supported content profile associated with the integration
 * @typedef {object} SupportedContentReference
 * @property {string} id - The SupportedContent unique identifier associated with this integration
 * @property {string} [name] - The SupportedContent profile name
 * @property {string} [selfUri] - The SupportedContent profile URI
 * @property {MediaTypes} [mediaTypes] - Media types definition for the supported content
 */
 
/**
 * @typedef {object} SurveyDetailQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {SurveyDetailQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} SurveyDetailQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {SurveyDetailQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {SurveyDetailQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} SurveyDetailQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [metric] - Left hand side for metric predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension or metric predicates
 * @property {NumericRange} [range] - Right hand side for dimension or metric predicates
 */
 
/**
 * @typedef {object} Team
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The team name
 * @property {WritableDivision} [division] - The division to which this entity belongs.
 * @property {string} [description] - Team information.
 * @property {string} [dateCreated] - Last modified datetime. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateModified] - Last modified datetime. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {number} [memberCount] - Number of members in a team
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} TemplateParameter
 * @property {string} [id] - Response substitution identifier
 * @property {string} [value] - Response substitution value
 */
 
/**
 * @typedef {object} TopicDuration
 * @property {number} [totalMilliseconds] - The total duration of the topic phrase within the conversation
 */
 
/**
 * @typedef {object} TopicOffset
 * @property {number} [wordCount] - Count of words before the topic 
 * @property {number} [characterCount] - Count of characters before the topic 
 */
 
/**
 * @typedef {object} TranscriptTopic
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name] - The name of the object.
 * @property {string} [topicPhrase] - The phrase which detected the topic. 
 * @property {string} [transcriptPhrase] - The transcript phrase which detected the topic.
 * @property {number} [confidence] - The detection confidence of the topic.
 * @property {number} [startTimeMilliseconds] - The start time of the topic phrase.
 * @property {TopicDuration} [duration]
 * @property {TopicOffset} [offset] - Location of the phrase
 * @property {number} [recordingLocation] - Location of the phrase in the recording in milliseconds
 */
 
/**
 * @typedef {object} TransferDestination
 * @property {string} [userId] - The id of the user if the command destination is a user.
 * @property {string} [address] - The destination address if the command destination is an endpoint.
 */
 
/**
 * @typedef {object} TransferInitiator
 * @property {string} [userId] - The id of the user who initiated the command if it was initiated by a user.
 */
 
/**
 * @typedef {object} TransferRequest
 * @property {string} [transferType] - The type of transfer to perform. Attended, where the initiating agent maintains ownership of the conversation until the intended recipient accepts the transfer, or Unattended, where the initiating agent immediately disconnects. Default is Unattended.
 * @property {boolean} [keepInternalMessageAlive] - If true, the digital internal message will NOT be terminated.
 * @property {string} [userId] - The user ID of the transfer target.
 * @property {string} [address] - The user ID or queue ID of the transfer target. Address like a phone number can not be used for callbacks, but they can be used for other forms of communication.
 * @property {string} [userName] - The user name of the transfer target.
 * @property {string} [queueId] - The queue ID of the transfer target.
 * @property {boolean} [voicemail] - If true, transfer to the voicemail inbox of the participant that is being replaced.
 */
 
/**
 * @typedef {object} TransferResponse
 * @property {string} [id] - The id of the command.
 * @property {string} [state] - The state of the command.
 * @property {string} [dateIssued] - The date/time that this command was issued. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {TransferInitiator} [initiator] - The initiator of the command.
 * @property {TransferResponseModifiedBy} [modifiedBy] - The user or entity that modified the command.
 * @property {TransferDestination} [destination] - The destination of the command.
 * @property {string} [transferType] - The type of transfer to perform.
 */
 
/**
 * @typedef {object} TransferResponseModifiedBy
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} TransferToAgentRequest
 * @property {string} [transferType] - The type of transfer to perform. Attended, where the initiating agent maintains ownership of the conversation until the intended recipient accepts the transfer, or Unattended, where the initiating agent immediately disconnects. Default is Unattended.
 * @property {boolean} [keepInternalMessageAlive] - If true, the digital internal message will NOT be terminated.
 * @property {string} [userId] - The id of the internal user.
 * @property {string} [userName] - The userName (like user’s email) of the internal user.
 * @property {string} [userDisplayName] - The name of the internal user.
 * @property {boolean} [voicemail] - If true, transfer to the voicemail inbox of the participant that is being replaced.
 */
 
/**
 * @typedef {object} TransferToExternalRequest
 * @property {string} [transferType] - The type of transfer to perform. Attended, where the initiating agent maintains ownership of the conversation until the intended recipient accepts the transfer, or Unattended, where the initiating agent immediately disconnects. Default is Unattended.
 * @property {boolean} [keepInternalMessageAlive] - If true, the digital internal message will NOT be terminated.
 * @property {string} [address] - The address (like phone number) of the external contact.
 */
 
/**
 * @typedef {object} TransferToQueueRequest
 * @property {string} [transferType] - The type of transfer to perform. Attended, where the initiating agent maintains ownership of the conversation until the intended recipient accepts the transfer, or Unattended, where the initiating agent immediately disconnects. Default is Unattended.
 * @property {boolean} [keepInternalMessageAlive] - If true, the digital internal message will NOT be terminated.
 * @property {string} [queueId] - The id of the queue.
 * @property {string} [queueName] - The name of the queue.
 */
 
/**
 * @typedef {object} TwitterIntegrationRequest
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The name of the Twitter Integration
 * @property {SupportedContentReference} [supportedContent] - Defines the SupportedContent profile configured for an integration
 * @property {MessagingSettingRequestReference} [messagingSetting] - Defines the message settings to be applied for this integration
 * @property {string} signupCode - The authorization code returned from the signup flow to request access tokens later on
 * @property {string} appId - The appId of the Twitter app to register the integration on
 * @property {string} codeChallenge - The codeChallenge used during the signup flow
 * @property {string} redirectUri - The redirectUri used during the signup flow
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} TwitterIntegrationUpdateRequest
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name] - The name of the Twitter messaging integration.
 * @property {SupportedContentReference} [supportedContent] - Defines the SupportedContent profile configured for an integration
 * @property {MessagingSettingRequestReference} [messagingSetting] - Defines the message settings to be applied for this integration
 * @property {string} [signupCode] - The authorization code returned from the signup flow to request access tokens later on
 * @property {string} [codeChallenge] - The codeChallenge used during the signup flow
 * @property {string} [redirectUri] - The redirectUri used during the signup flow
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} TypingSetting
 * @property {SettingDirection} [on] - Should typing indication Events be sent
 */
 
/**
 * @typedef {object} User
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {Division} [division] - The division to which this entity belongs.
 * @property {Chat} [chat]
 * @property {string} [department]
 * @property {string} [email]
 * @property {Contact[]} [primaryContactInfo] - Auto populated from addresses.
 * @property {Contact[]} [addresses] - Email addresses and phone numbers for this user
 * @property {string} [state] - The current state for this user.
 * @property {string} [title]
 * @property {string} [username]
 * @property {User} [manager]
 * @property {Image[]} [images]
 * @property {number} version - Required when updating a user, this value should be the current version of the user.  The current version can be obtained with a GET on the user before doing a PATCH.
 * @property {string[]} [certifications]
 * @property {Biography} [biography]
 * @property {EmployerInfo} [employerInfo]
 * @property {string} [preferredName] - Preferred full name of the agent
 * @property {RoutingStatus} [routingStatus] - ACD routing status
 * @property {UserPresence} [presence] - Active presence
 * @property {UserPresence} [integrationPresence] - Integration presence
 * @property {UserConversationSummary} [conversationSummary] - Summary of conversion statistics for conversation types.
 * @property {OutOfOffice} [outOfOffice] - Determine if out of office is enabled
 * @property {Geolocation} [geolocation] - Current geolocation position
 * @property {UserStations} [station] - Effective, default, and last station information
 * @property {UserAuthorization} [authorization] - Roles and permissions assigned to the user
 * @property {string[]} [profileSkills] - Profile skills possessed by the user
 * @property {Location[]} [locations] - The user placement at each site location.
 * @property {Group[]} [groups] - The groups the user is a member of
 * @property {Team} [team] - The team the user is a member of
 * @property {WorkPlanBidRanks} [workPlanBidRanks] - The WFM work plan bid rank settings for the user
 * @property {UserRoutingSkill[]} [skills] - Routing (ACD) skills possessed by the user
 * @property {UserRoutingLanguage[]} [languages] - Routing (ACD) languages possessed by the user
 * @property {boolean} [acdAutoAnswer] - acd auto answer
 * @property {string} [languagePreference] - preferred language by the user
 * @property {OAuthLastTokenIssued} [lastTokenIssued]
 * @property {string} [dateLastLogin] - The last time the user logged in using username and password. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateWelcomeSent] - The date & time the user was sent their welcome email. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} UserAuthorization
 * @property {DomainRole[]} [roles]
 * @property {DomainRole[]} [unusedRoles] - A collection of the roles the user is not using
 * @property {string[]} [permissions] - A collection of the permissions granted by all assigned roles
 * @property {ResourcePermissionPolicy[]} [permissionPolicies] - The policies configured for assigned permissions.
 */
 
/**
 * @typedef {object} UserConversationSummary
 * @property {string} [userId]
 * @property {MediaSummary} [call]
 * @property {MediaSummary} [callback]
 * @property {MediaSummary} [email]
 * @property {MediaSummary} [message]
 * @property {MediaSummary} [chat]
 * @property {MediaSummary} [socialExpression]
 * @property {MediaSummary} [video]
 */
 
/**
 * @typedef {object} UserPresence
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [source] - Deprecated - The sourceID field should be used as a replacement.
 * @property {string} [sourceId] - Represents the ID of a registered source
 * @property {boolean} [primary] - A boolean used to tell whether or not to set this presence source as the primary on a PATCH
 * @property {PresenceDefinition} [presenceDefinition]
 * @property {string} [message]
 * @property {string} [modifiedDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} UserReferenceWithName
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * Represents an organization language assigned to a user. When assigning to a user specify the organization language id as the id.
 * @typedef {object} UserRoutingLanguage
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {number} [proficiency] - A rating from 0.0 to 5.0 that indicates how fluent an agent is in a particular language. ACD interactions are routed to agents with higher proficiency ratings.
 * @property {string} [state] - Activate or deactivate this routing language.
 * @property {string} [languageUri] - URI to the organization language used by this user language.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * Represents an organization skill assigned to a user. When assigning to a user specify the organization skill id as the id.
 * @typedef {object} UserRoutingSkill
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {number} [proficiency] - A rating from 0.0 to 5.0 that indicates how adept an agent is at a particular skill. When "Best available skills" is enabled for a queue in Genesys Cloud, ACD interactions in that queue are routed to agents with higher proficiency ratings.
 * @property {string} [state] - Activate or deactivate this routing skill.
 * @property {string} [skillUri] - URI to the organization skill used by this user skill.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} UserStation
 * @property {string} [id] - A globally unique identifier for this station
 * @property {string} [name]
 * @property {string} [type]
 * @property {User} [associatedUser]
 * @property {string} [associatedDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {User} [defaultUser]
 * @property {object} [providerInfo] - Provider-specific info for this station, e.g. { "edgeGroupId": "ffe7b15c-a9cc-4f4c-88f5-781327819a49" }
 * @property {number} [webRtcCallAppearances] - The number of call appearances on the station.
 */
 
/**
 * @typedef {object} UserStations
 * @property {UserStation} [associatedStation] - Current associated station for this user.
 * @property {UserStation} [effectiveStation] - The station where the user can be reached based on their default and associated station.
 * @property {UserStation} [defaultStation] - Default station to be used if not associated with a station.
 * @property {UserStation} [lastAssociatedStation] - Last associated station for this user.
 */
 
/**
 * @typedef {object} Video
 * @property {string} [state] - The connection state of this communication.
 * @property {string} [initialState] - The initial connection state of this communication.
 * @property {string} [id] - A globally unique identifier for this communication.
 * @property {string} [context] - The room id context (xmpp jid) for the conference session.
 * @property {boolean} [audioMuted] - Indicates whether this participant has muted their outgoing audio.
 * @property {boolean} [videoMuted] - Indicates whether this participant has muted/paused their outgoing video.
 * @property {boolean} [sharingScreen] - Indicates whether this participant is sharing their screen to the session.
 * @property {number} [peerCount] - The number of peer participants from the perspective of the participant in the conference.
 * @property {string} [disconnectType] - System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects.
 * @property {string} [startAlertingTime] - The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [connectedTime] - The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [disconnectedTime] - The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [provider] - The source provider for the video.
 * @property {string} [peerId] - The id of the peer communication corresponding to a matching leg for this communication.
 * @property {string[]} [msids] - List of media stream ids
 * @property {Address} [self] - Address and name data for a call endpoint.
 * @property {Wrapup} [wrapup] - Call wrap up or disposition data.
 * @property {AfterCallWork} [afterCallWork] - After-call work for the communication.
 * @property {boolean} [afterCallWorkRequired] - Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested.
 */
 
/**
 * @typedef {object} VisibilityCondition
 * @property {string} [combiningOperation]
 * @property {object[]} [predicates] - A list of strings, each representing the location in the form of the Answer Option to depend on. In the format of "/form/questionGroup/{questionGroupIndex}/question/{questionIndex}/answer/{answerIndex}" or, to assume the current question group, "../question/{questionIndex}/answer/{answerIndex}". Note: Indexes are zero-based
 */
 
/**
 * @typedef {object} Voicemail
 * @property {string} [id] - The voicemail id
 * @property {string} [uploadStatus] - current state of the voicemail upload
 */
 
/**
 * @typedef {object} WhatsAppEmbeddedSignupIntegrationActivationRequest
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name] - WhatsApp Integration name
 * @property {string} phoneNumber - Phone number to associate with the WhatsApp integration
 * @property {string} pin - Specify the two-step verification PIN for that phone number
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} WhatsAppEmbeddedSignupIntegrationRequest
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The name of the WhatsApp Integration
 * @property {SupportedContentReference} [supportedContent] - Defines the SupportedContent profile configured for an integration
 * @property {MessagingSettingRequestReference} [messagingSetting] - Defines the message settings to be applied for this integration
 * @property {string} embeddedSignupAccessToken - The access token returned from the embedded signup flow
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} WhatsAppIntegrationRequest
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The name of the WhatsApp Integration
 * @property {SupportedContentReference} [supportedContent] - Defines the SupportedContent profile configured for an integration
 * @property {MessagingSettingRequestReference} [messagingSetting] - Defines the message settings to be applied for this integration
 * @property {string} phoneNumber - The phone number associated to the whatsApp integration
 * @property {string} wabaCertificate - The waba(WhatsApp Business Manager) certificate associated to the WhatsApp integration phone number
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} WhatsAppIntegrationUpdateRequest
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name] - WhatsApp Integration name
 * @property {SupportedContentReference} [supportedContent] - Defines the SupportedContent profile configured for an integration
 * @property {MessagingSettingRequestReference} [messagingSetting] - Defines the message settings to be applied for this integration
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} WorkPlanBidRanks
 * @property {string} [id] - The globally unique identifier for the user.
 * @property {number} [workPlanBiddingPerformance] - Work plan bidding agent performance ranking. The range of values is between 0 and 9999.
 * @property {string} [biddingTieBreaker] - Custom agent ranking metric that some customers can use.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} Workspace
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The current name of the workspace.
 * @property {string} [type]
 * @property {boolean} [isCurrentUserWorkspace]
 * @property {DomainEntityRef} [user]
 * @property {string} [bucket]
 * @property {string} [dateCreated] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateModified] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {WorkspaceSummary} [summary]
 * @property {string[]} [acl]
 * @property {string} [description]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} WorkspaceSummary
 * @property {number} [totalDocumentCount]
 * @property {number} [totalDocumentByteCount]
 */
 
/**
 * @typedef {object} Wrapup
 * @property {string} [code] - The user configured wrap up code id.
 * @property {string} [name] - The user configured wrap up code name.
 * @property {string} [notes] - Text entered by the agent to describe the call or disposition.
 * @property {string[]} [tags] - List of tags selected by the agent to describe the call or disposition.
 * @property {number} [durationSeconds] - The length of time in seconds that the agent spent doing after call work.
 * @property {string} [endTime] - The timestamp when the wrapup was finished. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {boolean} [provisional] - Indicates if this is a pending save and should not require a code to be specified.  This allows someone to save some temporary wrapup that will be used later.
 */
 
/**
 * @typedef {object} WrapupInput
 * @property {string} [code] - The user configured wrap up code id.
 * @property {string} [name] - The user configured wrap up code name.
 * @property {string} [notes] - Text entered by the agent to describe the call or disposition.
 * @property {string[]} [tags] - List of tags selected by the agent to describe the call or disposition.
 * @property {number} [durationSeconds] - The length of time in seconds that the agent spent doing after call work.
 * @property {string} [endTime] - The timestamp when the wrapup was finished. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {boolean} [provisional] - Indicates if this is a pending save and should not require a code to be specified.  This allows someone to save some temporary wrapup that will be used later.
 * @property {boolean} [disableEndTimeUpdates] - Prevent updates to wrapup end time when set to true.
 */
 
/**
 * @typedef {object} WritableDivision
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [selfUri] - The URI for this object
 */
 

/**
 * Conversations
 * @class Conversations
 */
class ConversationsAPI {
	// Private instance properties
	#gcPlatformAPIClient = null;

	/**
	 * Constructor for the Conversations class
	 * @constructor
	 * @param {GCPlatformAPIClient} gcPlatformAPIClient - The Genesys Cloud Platform API client instance.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_INSTANCE_TYPE_INVALID} If the Genesys Cloud Platform API client instance argument is not an object.
	 */
	constructor(gcPlatformAPIClient) {
		// Check the Genesys Cloud Platform API client instance argument
		if (typeof gcPlatformAPIClient !== "object" || symbols.GCPlatformAPIClient in gcPlatformAPIClient === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_INSTANCE_TYPE_INVALID();
		}

		// Initialize the instance properties
		this.#gcPlatformAPIClient = gcPlatformAPIClient;
	}

	/**
	 * Query for conversation activity observations
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  The desired page size
	 * @param {number} [query.pageNumber] -  The desired page number
	 * @param {ConversationActivityQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/conversations/activity/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsConversationsActivityQuery(query, body) {
		const endpointPath = "/api/v2/analytics/conversations/activity/query";
		const endpointMethod = "POST";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for conversation details
	 * @async
	 * @param {ConversationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/conversations/details/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsConversationsDetailsQuery(body) {
		const endpointPath = "/api/v2/analytics/conversations/details/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a conversation by id
	 * @async
	 * @param {string} conversationId - conversationId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/conversations/{conversationId}/details" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getAnalyticsConversationDetails(conversationId) {
		const endpointPath = "/api/v2/analytics/conversations/{conversationId}/details";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Gets multiple conversations by id
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string[]} [query.id] -  Comma-separated conversation ids
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/conversations/details" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getAnalyticsConversationsDetails(query) {
		const endpointPath = "/api/v2/analytics/conversations/details";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("id" in query && this.#checkJSONSchemaType(query["id"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "id", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Index conversation properties
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {PropertyIndexRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/conversations/{conversationId}/details/properties" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsConversationDetailsProperties(conversationId, body) {
		const endpointPath = "/api/v2/analytics/conversations/{conversationId}/details/properties";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for conversation details asynchronously
	 * @async
	 * @param {AsyncConversationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/conversations/details/jobs" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsConversationsDetailsJobs(body) {
		const endpointPath = "/api/v2/analytics/conversations/details/jobs";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get status for async query for conversation details
	 * @async
	 * @param {string} jobId - jobId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/conversations/details/jobs/{jobId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getAnalyticsConversationsDetailsJob(jobId) {
		const endpointPath = "/api/v2/analytics/conversations/details/jobs/{jobId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(jobId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "jobId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.jobId = jobId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete/cancel an async details job
	 * @async
	 * @param {string} jobId - jobId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/conversations/details/jobs/{jobId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteAnalyticsConversationsDetailsJob(jobId) {
		const endpointPath = "/api/v2/analytics/conversations/details/jobs/{jobId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(jobId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "jobId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.jobId = jobId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Fetch a page of results for an async details job
	 * @async
	 * @param {string} jobId - jobId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.cursor] -  Indicates where to resume query results (not required for first page)
	 * @param {number} [query.pageSize] -  The desired maximum number of results
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/conversations/details/jobs/{jobId}/results" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getAnalyticsConversationsDetailsJobResults(jobId, query) {
		const endpointPath = "/api/v2/analytics/conversations/details/jobs/{jobId}/results";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(jobId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "jobId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("cursor" in query && this.#checkJSONSchemaType(query["cursor"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "cursor", "string");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.jobId = jobId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Lookup the datalake availability date and time
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/conversations/details/jobs/availability" endpoint.
	 */
	getAnalyticsConversationsDetailsJobsAvailability() {
		const endpointPath = "/api/v2/analytics/conversations/details/jobs/availability";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for conversation aggregates
	 * @async
	 * @param {ConversationAggregationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/conversations/aggregates/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsConversationsAggregatesQuery(body) {
		const endpointPath = "/api/v2/analytics/conversations/aggregates/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Creates a cobrowse session. Requires "conversation:cobrowse:add" (for web messaging) or "conversation:cobrowsevoice:add" permission.
	 * @async
	 * @param {string} conversationId - Conversation ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/cobrowse" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	postConversationCobrowse(conversationId) {
		const endpointPath = "/api/v2/conversations/{conversationId}/cobrowse";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the encryption key configurations
	 * @async
	 * @param {string} keyconfigurationsId - Key Configurations Id
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/keyconfigurations/{keyconfigurationsId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationsKeyconfiguration(keyconfigurationsId) {
		const endpointPath = "/api/v2/conversations/keyconfigurations/{keyconfigurationsId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(keyconfigurationsId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "keyconfigurationsId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.keyconfigurationsId = keyconfigurationsId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update the encryption key configurations
	 * @async
	 * @param {string} keyconfigurationsId - Key Configurations Id
	 * @param {ConversationEncryptionConfiguration} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/keyconfigurations/{keyconfigurationsId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putConversationsKeyconfiguration(keyconfigurationsId, body) {
		const endpointPath = "/api/v2/conversations/keyconfigurations/{keyconfigurationsId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(keyconfigurationsId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "keyconfigurationsId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.keyconfigurationsId = keyconfigurationsId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a list of key configurations data
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/keyconfigurations" endpoint.
	 */
	getConversationsKeyconfigurations() {
		const endpointPath = "/api/v2/conversations/keyconfigurations";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Setup configurations for encryption key creation
	 * @async
	 * @param {ConversationEncryptionConfiguration} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/keyconfigurations" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsKeyconfigurations(body) {
		const endpointPath = "/api/v2/conversations/keyconfigurations";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Validate encryption key configurations without saving it
	 * @async
	 * @param {ConversationEncryptionConfiguration} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/keyconfigurations/validate" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsKeyconfigurationsValidate(body) {
		const endpointPath = "/api/v2/conversations/keyconfigurations/validate";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Search conversations
	 * @async
	 * @param {ConversationParticipantSearchRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/participants/attributes/search" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsParticipantsAttributesSearch(body) {
		const endpointPath = "/api/v2/conversations/participants/attributes/search";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update the tags on a conversation.
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @param {ConversationTagsUpdate} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/tags" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putConversationTags(conversationId, body) {
		const endpointPath = "/api/v2/conversations/{conversationId}/tags";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update the utilization label on a conversation. When there is no value provided, the system default label is applied
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @param {ConversationUtilizationLabelUpdate} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/utilizationlabel" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationUtilizationlabel(conversationId, body) {
		const endpointPath = "/api/v2/conversations/{conversationId}/utilizationlabel";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the secure attributes on a conversation.
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/secureattributes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationSecureattributes(conversationId) {
		const endpointPath = "/api/v2/conversations/{conversationId}/secureattributes";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Set the secure attributes on a conversation.
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @param {ConversationSecureAttributes} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/secureattributes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putConversationSecureattributes(conversationId, body) {
		const endpointPath = "/api/v2/conversations/{conversationId}/secureattributes";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update the secure attributes on a conversation.
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @param {ConversationSecureAttributes} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/secureattributes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationSecureattributes(conversationId, body) {
		const endpointPath = "/api/v2/conversations/{conversationId}/secureattributes";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get conversation
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversation(conversationId) {
		const endpointPath = "/api/v2/conversations/{conversationId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Barge a conversation creating a barged in conference of connected participants.
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/barge" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	postConversationBarge(conversationId) {
		const endpointPath = "/api/v2/conversations/{conversationId}/barge";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Performs a full conversation teardown. Issues disconnect requests for any connected media. Applies a system wrap-up code to any participants that are pending wrap-up. This is not intended to be the normal way of ending interactions but is available in the event of problems with the application to allow a resynchronization of state across all components. It is recommended that users submit a support case if they are relying on this endpoint systematically as there is likely something that needs investigation.
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/disconnect" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	postConversationDisconnect(conversationId) {
		const endpointPath = "/api/v2/conversations/{conversationId}/disconnect";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Attempts to manually assign a specified conversation to a specified user.  Ignores bullseye ring, PAR score, skills, and languages.
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @param {ConversationUser} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/assign" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationAssign(conversationId, body) {
		const endpointPath = "/api/v2/conversations/{conversationId}/assign";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get active conversations for the logged in user
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.communicationType] -  Call or Chat communication filtering
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversations(query) {
		const endpointPath = "/api/v2/conversations";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("communicationType" in query && this.#checkJSONSchemaType(query["communicationType"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationType", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create Fax Conversation
	 * @async
	 * @param {FaxSendRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/faxes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsFaxes(body) {
		const endpointPath = "/api/v2/conversations/faxes";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get Settings
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/settings" endpoint.
	 */
	getConversationsSettings() {
		const endpointPath = "/api/v2/conversations/settings";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update Settings
	 * @async
	 * @param {Settings} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/settings" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsSettings(body) {
		const endpointPath = "/api/v2/conversations/settings";
		const endpointMethod = "PATCH";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update after-call work for this conversation communication.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {AfterCallWorkUpdate} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/aftercallwork/{conversationId}/participants/{participantId}/communications/{communicationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsAftercallworkConversationIdParticipantCommunication(conversationId, participantId, communicationId, body) {
		const endpointPath = "/api/v2/conversations/aftercallwork/{conversationId}/participants/{participantId}/communications/{communicationId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update multiple scheduled callbacks
	 * @async
	 * @param {BulkCallbackPatchRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/callbacks/bulk/update" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsCallbacksBulkUpdate(body) {
		const endpointPath = "/api/v2/conversations/callbacks/bulk/update";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Disconnect multiple scheduled callbacks
	 * @async
	 * @param {BulkCallbackDisconnectRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/callbacks/bulk/disconnect" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsCallbacksBulkDisconnect(body) {
		const endpointPath = "/api/v2/conversations/callbacks/bulk/disconnect";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get active call conversations for the logged in user
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls" endpoint.
	 */
	getConversationsCalls() {
		const endpointPath = "/api/v2/conversations/calls";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a call conversation
	 * @async
	 * @param {CreateCallRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsCalls(body) {
		const endpointPath = "/api/v2/conversations/calls";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Replace this participant with the specified user and/or address
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {TransferRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/replace" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsCallParticipantReplace(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/replace";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Listen in on the conversation from the point of view of a given participant.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/monitor" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	postConversationsCallParticipantMonitor(conversationId, participantId) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/monitor";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get list of wrapup codes for this conversation participant
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/wrapupcodes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationsCallParticipantWrapupcodes(conversationId, participantId) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/wrapupcodes";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get call conversation
	 * @async
	 * @param {string} conversationId - conversationId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationsCall(conversationId) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Place a new call as part of a callback conversation.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {CallCommand} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsCall(conversationId, body) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a conversation by setting its recording state, merging in other conversations to create a conference, or disconnecting all of the participants
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {Conversation} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsCall(conversationId, body) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a conversation by setting its recording state
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {SetRecordingState} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}/recordingstate" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putConversationsCallRecordingstate(conversationId, body) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}/recordingstate";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update the attributes on a conversation participant.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {ParticipantAttributes} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/attributes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsCallParticipantAttributes(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/attributes";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the wrap-up for this conversation participant. 
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.provisional] -  Indicates if the wrap-up code is provisional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsCallParticipantWrapup(conversationId, participantId, query) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/wrapup";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("provisional" in query && this.#checkJSONSchemaType(query["provisional"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "provisional", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update conversation participant's communication by disconnecting it.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {MediaParticipantRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/communications/{communicationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsCallParticipantCommunication(conversationId, participantId, communicationId, body) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/communications/{communicationId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the wrap-up for this conversation communication. 
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.provisional] -  Indicates if the wrap-up code is provisional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsCallParticipantCommunicationWrapup(conversationId, participantId, communicationId, query) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("provisional" in query && this.#checkJSONSchemaType(query["provisional"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "provisional", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Apply wrap-up for this conversation communication
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {WrapupInput} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsCallParticipantCommunicationWrapup(conversationId, participantId, communicationId, body) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update conversation participant
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {MediaParticipantRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}/participants/{participantId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsCallParticipant(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}/participants/{participantId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the maximum number of participants that this user can have on a conference
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/maximumconferenceparties" endpoint.
	 */
	getConversationsCallsMaximumconferenceparties() {
		const endpointPath = "/api/v2/conversations/calls/maximumconferenceparties";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Listen in on the conversation from the point of view of a given participant while speaking to just the given participant.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/coach" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	postConversationsCallParticipantCoach(conversationId, participantId) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/coach";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Barge a given participant's call creating a barged in conference of connected participants.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/barge" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	postConversationsCallParticipantBarge(conversationId, participantId) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/barge";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Initiate and update consult transfer
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {ConsultTransfer} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/consult" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsCallParticipantConsult(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/consult";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Cancel the transfer
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/consult" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteConversationsCallParticipantConsult(conversationId, participantId) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/consult";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Change who can speak
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {ConsultTransferUpdate} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/consult" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsCallParticipantConsult(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/consult";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Initiate a consult transfer to an agent
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {ConsultTransferToAgent} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/consult/agent" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsCallParticipantConsultAgent(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/consult/agent";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Initiate a consult transfer to a queue
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {ConsultTransferToQueue} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/consult/queue" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsCallParticipantConsultQueue(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/consult/queue";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Initiate a consult transfer to an external contact
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {ConsultTransferToExternal} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/consult/external" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsCallParticipantConsultExternal(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/consult/external";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Add participants to a conversation
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {Conversation} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}/participants" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsCallParticipants(conversationId, body) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}/participants";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get call history
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size, maximum 50
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.interval] -  Interval string; format is ISO-8601. Separate start and end times with forward slash '/'
	 * @param {string[]} [query.expand] -  Which fields, if any, to expand.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/history" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsCallsHistory(query) {
		const endpointPath = "/api/v2/conversations/calls/history";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("interval" in query && this.#checkJSONSchemaType(query["interval"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "interval", "string");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Set uuiData to be sent on future commands.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {SetUuiDataRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/communications/{communicationId}/uuidata" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putConversationsCallParticipantCommunicationUuidata(conversationId, participantId, communicationId, body) {
		const endpointPath = "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/communications/{communicationId}/uuidata";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get active callback conversations for the logged in user
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/callbacks" endpoint.
	 */
	getConversationsCallbacks() {
		const endpointPath = "/api/v2/conversations/callbacks";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a Callback
	 * @async
	 * @param {CreateCallbackCommand} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/callbacks" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsCallbacks(body) {
		const endpointPath = "/api/v2/conversations/callbacks";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a scheduled callback
	 * @async
	 * @param {PatchCallbackRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/callbacks" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsCallbacks(body) {
		const endpointPath = "/api/v2/conversations/callbacks";
		const endpointMethod = "PATCH";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Replace this participant with the specified user and/or address
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {TransferRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/replace" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsCallbackParticipantReplace(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/replace";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get list of wrapup codes for this conversation participant
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/wrapupcodes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationsCallbackParticipantWrapupcodes(conversationId, participantId) {
		const endpointPath = "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/wrapupcodes";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get callback conversation
	 * @async
	 * @param {string} conversationId - conversationId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/callbacks/{conversationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationsCallback(conversationId) {
		const endpointPath = "/api/v2/conversations/callbacks/{conversationId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a conversation by disconnecting all of the participants
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {Conversation} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/callbacks/{conversationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsCallback(conversationId, body) {
		const endpointPath = "/api/v2/conversations/callbacks/{conversationId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a conversation by setting its recording state
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {SetRecordingState} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/callbacks/{conversationId}/recordingstate" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putConversationsCallbackRecordingstate(conversationId, body) {
		const endpointPath = "/api/v2/conversations/callbacks/{conversationId}/recordingstate";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update the attributes on a conversation participant.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {ParticipantAttributes} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/attributes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsCallbackParticipantAttributes(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/attributes";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the wrap-up for this conversation participant. 
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.provisional] -  Indicates if the wrap-up code is provisional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsCallbackParticipantWrapup(conversationId, participantId, query) {
		const endpointPath = "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/wrapup";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("provisional" in query && this.#checkJSONSchemaType(query["provisional"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "provisional", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update conversation participant's communication by disconnecting it.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {MediaParticipantRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/communications/{communicationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsCallbackParticipantCommunication(conversationId, participantId, communicationId, body) {
		const endpointPath = "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/communications/{communicationId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the wrap-up for this conversation communication. 
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.provisional] -  Indicates if the wrap-up code is provisional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsCallbackParticipantCommunicationWrapup(conversationId, participantId, communicationId, query) {
		const endpointPath = "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("provisional" in query && this.#checkJSONSchemaType(query["provisional"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "provisional", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Apply wrap-up for this conversation communication
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {WrapupInput} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsCallbackParticipantCommunicationWrapup(conversationId, participantId, communicationId, body) {
		const endpointPath = "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update conversation participant
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {MediaParticipantRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsCallbackParticipant(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a web chat conversation message
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} messageId - messageId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/chats/{conversationId}/messages/{messageId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @deprecated
	 */
	getConversationsChatMessage(conversationId, messageId) {
		const endpointPath = "/api/v2/conversations/chats/{conversationId}/messages/{messageId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(messageId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "messageId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.messageId = messageId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the messages of a chat conversation.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.after] -  If specified, get the messages chronologically after the id of this message
	 * @param {string} [query.before] -  If specified, get the messages chronologically before the id of this message
	 * @param {string} [query.sortOrder] -  Sort order
	 * @param {number} [query.maxResults] -  Limit the returned number of messages, up to a maximum of 100
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/chats/{conversationId}/messages" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @deprecated
	 */
	getConversationsChatMessages(conversationId, query) {
		const endpointPath = "/api/v2/conversations/chats/{conversationId}/messages";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("after" in query && this.#checkJSONSchemaType(query["after"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "after", "string");
			}
			if ("before" in query && this.#checkJSONSchemaType(query["before"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "before", "string");
			}
			if ("sortOrder" in query && this.#checkJSONSchemaType(query["sortOrder"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortOrder", "string");
			}
			if ("maxResults" in query && this.#checkJSONSchemaType(query["maxResults"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "maxResults", "integer");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Send a message on behalf of a communication in a chat conversation.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} communicationId - communicationId
	 * @param {CreateWebChatMessageRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/chats/{conversationId}/communications/{communicationId}/messages" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	postConversationsChatCommunicationMessages(conversationId, communicationId, body) {
		const endpointPath = "/api/v2/conversations/chats/{conversationId}/communications/{communicationId}/messages";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Send a typing-indicator on behalf of a communication in a chat conversation.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} communicationId - communicationId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/chats/{conversationId}/communications/{communicationId}/typing" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @deprecated
	 */
	postConversationsChatCommunicationTyping(conversationId, communicationId) {
		const endpointPath = "/api/v2/conversations/chats/{conversationId}/communications/{communicationId}/typing";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.communicationId = communicationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get active chat conversations for the logged in user
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/chats" endpoint.
	 * @deprecated
	 */
	getConversationsChats() {
		const endpointPath = "/api/v2/conversations/chats";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a web chat conversation
	 * @async
	 * @param {CreateWebChatRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/chats" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	postConversationsChats(body) {
		const endpointPath = "/api/v2/conversations/chats";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Replace this participant with the specified user and/or address
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {TransferRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/replace" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	postConversationsChatParticipantReplace(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/replace";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get list of wrapup codes for this conversation participant
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/wrapupcodes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @deprecated
	 */
	getConversationsChatParticipantWrapupcodes(conversationId, participantId) {
		const endpointPath = "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/wrapupcodes";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get chat conversation
	 * @async
	 * @param {string} conversationId - conversationId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/chats/{conversationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @deprecated
	 */
	getConversationsChat(conversationId) {
		const endpointPath = "/api/v2/conversations/chats/{conversationId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a conversation by disconnecting all of the participants
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {Conversation} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/chats/{conversationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	patchConversationsChat(conversationId, body) {
		const endpointPath = "/api/v2/conversations/chats/{conversationId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a conversation by setting its recording state
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {SetRecordingState} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/chats/{conversationId}/recordingstate" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	putConversationsChatRecordingstate(conversationId, body) {
		const endpointPath = "/api/v2/conversations/chats/{conversationId}/recordingstate";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update the attributes on a conversation participant.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {ParticipantAttributes} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/attributes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	patchConversationsChatParticipantAttributes(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/attributes";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the wrap-up for this conversation participant. 
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.provisional] -  Indicates if the wrap-up code is provisional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @deprecated
	 */
	getConversationsChatParticipantWrapup(conversationId, participantId, query) {
		const endpointPath = "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/wrapup";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("provisional" in query && this.#checkJSONSchemaType(query["provisional"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "provisional", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update conversation participant
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {MediaParticipantRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/chats/{conversationId}/participants/{participantId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	patchConversationsChatParticipant(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/chats/{conversationId}/participants/{participantId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update conversation participant's communication by disconnecting it.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {MediaParticipantRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/communications/{communicationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	patchConversationsChatParticipantCommunication(conversationId, participantId, communicationId, body) {
		const endpointPath = "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/communications/{communicationId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the wrap-up for this conversation communication. 
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.provisional] -  Indicates if the wrap-up code is provisional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @deprecated
	 */
	getConversationsChatParticipantCommunicationWrapup(conversationId, participantId, communicationId, query) {
		const endpointPath = "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("provisional" in query && this.#checkJSONSchemaType(query["provisional"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "provisional", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Apply wrap-up for this conversation communication
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {WrapupInput} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	postConversationsChatParticipantCommunicationWrapup(conversationId, participantId, communicationId, body) {
		const endpointPath = "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Replace this participant with the specified user and/or address
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {TransferRequest} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/replace" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	postConversationsCobrowsesessionParticipantReplace(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/replace";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get active cobrowse conversations for the logged in user
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/cobrowsesessions" endpoint.
	 */
	getConversationsCobrowsesessions() {
		const endpointPath = "/api/v2/conversations/cobrowsesessions";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get list of wrapup codes for this conversation participant
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/wrapupcodes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @deprecated
	 */
	getConversationsCobrowsesessionParticipantWrapupcodes(conversationId, participantId) {
		const endpointPath = "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/wrapupcodes";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get cobrowse conversation
	 * @async
	 * @param {string} conversationId - conversationId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/cobrowsesessions/{conversationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationsCobrowsesession(conversationId) {
		const endpointPath = "/api/v2/conversations/cobrowsesessions/{conversationId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a conversation by disconnecting all of the participants
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {Conversation} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/cobrowsesessions/{conversationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	patchConversationsCobrowsesession(conversationId, body) {
		const endpointPath = "/api/v2/conversations/cobrowsesessions/{conversationId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a conversation by setting its recording state
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {SetRecordingState} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/cobrowsesessions/{conversationId}/recordingstate" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	putConversationsCobrowsesessionRecordingstate(conversationId, body) {
		const endpointPath = "/api/v2/conversations/cobrowsesessions/{conversationId}/recordingstate";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update the attributes on a conversation participant.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {ParticipantAttributes} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/attributes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	patchConversationsCobrowsesessionParticipantAttributes(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/attributes";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the wrap-up for this conversation participant. 
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.provisional] -  Indicates if the wrap-up code is provisional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @deprecated
	 */
	getConversationsCobrowsesessionParticipantWrapup(conversationId, participantId, query) {
		const endpointPath = "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/wrapup";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("provisional" in query && this.#checkJSONSchemaType(query["provisional"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "provisional", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update conversation participant's communication by disconnecting it.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {MediaParticipantRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/communications/{communicationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	patchConversationsCobrowsesessionParticipantCommunication(conversationId, participantId, communicationId, body) {
		const endpointPath = "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/communications/{communicationId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the wrap-up for this conversation communication. 
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.provisional] -  Indicates if the wrap-up code is provisional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @deprecated
	 */
	getConversationsCobrowsesessionParticipantCommunicationWrapup(conversationId, participantId, communicationId, query) {
		const endpointPath = "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("provisional" in query && this.#checkJSONSchemaType(query["provisional"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "provisional", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Apply wrap-up for this conversation communication
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {WrapupInput} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	postConversationsCobrowsesessionParticipantCommunicationWrapup(conversationId, participantId, communicationId, body) {
		const endpointPath = "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update conversation participant
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {MediaParticipantRequest} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	patchConversationsCobrowsesessionParticipant(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Replace this participant with the specified user and/or address
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {TransferRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/replace" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsEmailParticipantReplace(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/replace";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get conversation message
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} messageId - messageId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}/messages/{messageId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationsEmailMessage(conversationId, messageId) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}/messages/{messageId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(messageId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "messageId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.messageId = messageId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get active email conversations for the logged in user
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails" endpoint.
	 */
	getConversationsEmails() {
		const endpointPath = "/api/v2/conversations/emails";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create an email conversation
	 * @async
	 * @param {CreateEmailRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsEmails(body) {
		const endpointPath = "/api/v2/conversations/emails";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get list of wrapup codes for this conversation participant
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/wrapupcodes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationsEmailParticipantWrapupcodes(conversationId, participantId) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/wrapupcodes";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get conversation messages
	 * @async
	 * @param {string} conversationId - conversationId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}/messages" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationsEmailMessages(conversationId) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}/messages";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Send an email reply
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {EmailMessage} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}/messages" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsEmailMessages(conversationId, body) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}/messages";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get email conversation
	 * @async
	 * @param {string} conversationId - conversationId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationsEmail(conversationId) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a conversation by disconnecting all of the participants
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {Conversation} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsEmail(conversationId, body) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a conversation by setting its recording state
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {SetRecordingState} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}/recordingstate" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putConversationsEmailRecordingstate(conversationId, body) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}/recordingstate";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update the attributes on a conversation participant.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {ParticipantAttributes} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/attributes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsEmailParticipantAttributes(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/attributes";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the wrap-up for this conversation participant. 
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.provisional] -  Indicates if the wrap-up code is provisional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsEmailParticipantWrapup(conversationId, participantId, query) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/wrapup";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("provisional" in query && this.#checkJSONSchemaType(query["provisional"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "provisional", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update conversation participant
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {MediaParticipantRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}/participants/{participantId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsEmailParticipant(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}/participants/{participantId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update conversation participant's communication by disconnecting it.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {MediaParticipantRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/communications/{communicationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsEmailParticipantCommunication(conversationId, participantId, communicationId, body) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/communications/{communicationId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the wrap-up for this conversation communication. 
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.provisional] -  Indicates if the wrap-up code is provisional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsEmailParticipantCommunicationWrapup(conversationId, participantId, communicationId, query) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("provisional" in query && this.#checkJSONSchemaType(query["provisional"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "provisional", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Apply wrap-up for this conversation communication
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {WrapupInput} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsEmailParticipantCommunicationWrapup(conversationId, participantId, communicationId, body) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get emails settings for a given conversation
	 * @async
	 * @param {string} conversationId - conversationId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}/settings" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationsEmailSettings(conversationId) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}/settings";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Reconnect the user to the most recently disconnected customer on a fully disconnected email conversation
	 * @async
	 * @param {string} conversationId - conversationId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}/reconnect" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	postConversationsEmailReconnect(conversationId) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}/reconnect";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete attachment from draft
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} attachmentId - attachmentId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}/messages/draft/attachments/{attachmentId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteConversationsEmailMessagesDraftAttachment(conversationId, attachmentId) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}/messages/draft/attachments/{attachmentId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(attachmentId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "attachmentId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.attachmentId = attachmentId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Copy attachments from an email message to the current draft.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {CopyAttachmentsRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}/messages/draft/attachments/copy" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsEmailMessagesDraftAttachmentsCopy(conversationId, body) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}/messages/draft/attachments/copy";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get conversation draft reply
	 * @async
	 * @param {string} conversationId - conversationId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}/messages/draft" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationsEmailMessagesDraft(conversationId) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}/messages/draft";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update conversation draft reply
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {EmailMessage} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}/messages/draft" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putConversationsEmailMessagesDraft(conversationId, body) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}/messages/draft";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Reset conversation draft to its initial state and/or auto-fill draft content
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.autoFill] -  autoFill
	 * @param {boolean} [query.discard] -  discard
	 * @param {DraftManipulationRequest} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}/messages/draft" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsEmailMessagesDraft(conversationId, query, body) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}/messages/draft";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("autoFill" in query && this.#checkJSONSchemaType(query["autoFill"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "autoFill", "boolean");
			}
			if ("discard" in query && this.#checkJSONSchemaType(query["discard"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "discard", "boolean");
			}
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Send an email to an external conversation. An external conversation is one where the provider is not PureCloud based. This endpoint allows the sender of the external email to reply or send a new message to the existing conversation. The new message will be treated as part of the existing conversation and chained to it.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {InboundMessageRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}/inboundmessages" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsEmailInboundmessages(conversationId, body) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}/inboundmessages";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update conversation by setting its parking state
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {ParkingStateRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/parkingstate" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsEmailParticipantParkingstate(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/parkingstate";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create an email conversation, per API
	 * @async
	 * @param {AgentlessEmailSendRequestDto} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/emails/agentless" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsEmailsAgentless(body) {
		const endpointPath = "/api/v2/conversations/emails/agentless";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a cached media item
	 * @async
	 * @param {string} cachedMediaItemId - cachedMediaItemId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/cachedmedia/{cachedMediaItemId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationsMessagesCachedmediaCachedMediaItemId(cachedMediaItemId) {
		const endpointPath = "/api/v2/conversations/messages/cachedmedia/{cachedMediaItemId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(cachedMediaItemId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "cachedMediaItemId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.cachedMediaItemId = cachedMediaItemId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Remove a cached media item asychronously
	 * @async
	 * @param {string} cachedMediaItemId - cachedMediaItemId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/cachedmedia/{cachedMediaItemId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteConversationsMessagesCachedmediaCachedMediaItemId(cachedMediaItemId) {
		const endpointPath = "/api/v2/conversations/messages/cachedmedia/{cachedMediaItemId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(cachedMediaItemId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "cachedMediaItemId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.cachedMediaItemId = cachedMediaItemId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a list of cached media items
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.url] -  URL to search for
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/cachedmedia" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsMessagesCachedmedia(query) {
		const endpointPath = "/api/v2/conversations/messages/cachedmedia";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("url" in query && this.#checkJSONSchemaType(query["url"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "url", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Replace this participant with the specified user and/or address
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {TransferRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/replace" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsMessageParticipantReplace(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/replace";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get message
	 * @async
	 * @param {string} messageId - messageId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.useNormalizedMessage] -  If true, response removes deprecated fields (textBody, media, stickers)
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/{messageId}/details" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsMessageDetails(messageId, query) {
		const endpointPath = "/api/v2/conversations/messages/{messageId}/details";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(messageId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "messageId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("useNormalizedMessage" in query && this.#checkJSONSchemaType(query["useNormalizedMessage"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "useNormalizedMessage", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.messageId = messageId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get active message conversations for the logged in user
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages" endpoint.
	 */
	getConversationsMessages() {
		const endpointPath = "/api/v2/conversations/messages";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create an outbound messaging conversation.
	 * @async
	 * @param {CreateOutboundMessagingConversationRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsMessages(body) {
		const endpointPath = "/api/v2/conversations/messages";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Listen in on the conversation from the point of view of a given participant.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/monitor" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	postConversationsMessageParticipantMonitor(conversationId, participantId) {
		const endpointPath = "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/monitor";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get list of wrapup codes for this conversation participant
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/wrapupcodes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationsMessageParticipantWrapupcodes(conversationId, participantId) {
		const endpointPath = "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/wrapupcodes";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Send message
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} communicationId - communicationId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.useNormalizedMessage] -  If true, response removes deprecated fields (textBody, media, stickers)
	 * @param {AdditionalMessage} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/{conversationId}/communications/{communicationId}/messages" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsMessageCommunicationMessages(conversationId, communicationId, query, body) {
		const endpointPath = "/api/v2/conversations/messages/{conversationId}/communications/{communicationId}/messages";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("useNormalizedMessage" in query && this.#checkJSONSchemaType(query["useNormalizedMessage"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "useNormalizedMessage", "boolean");
			}
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get messages in batch
	 * @async
	 * @param {string} conversationId - 
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.useNormalizedMessage] -  If true, response removes deprecated fields (textBody, media, stickers)
	 * @param {string[]} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/{conversationId}/messages/bulk" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsMessageMessagesBulk(conversationId, query, body) {
		const endpointPath = "/api/v2/conversations/messages/{conversationId}/messages/bulk";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("useNormalizedMessage" in query && this.#checkJSONSchemaType(query["useNormalizedMessage"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "useNormalizedMessage", "boolean");
			}
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "array") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "array", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get message conversation
	 * @async
	 * @param {string} conversationId - conversationId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/{conversationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationsMessage(conversationId) {
		const endpointPath = "/api/v2/conversations/messages/{conversationId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a conversation by disconnecting all of the participants
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {Conversation} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/{conversationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsMessage(conversationId, body) {
		const endpointPath = "/api/v2/conversations/messages/{conversationId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a conversation by setting its recording state
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {SetRecordingState} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/{conversationId}/recordingstate" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putConversationsMessageRecordingstate(conversationId, body) {
		const endpointPath = "/api/v2/conversations/messages/{conversationId}/recordingstate";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update the attributes on a conversation participant.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {ParticipantAttributes} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/attributes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsMessageParticipantAttributes(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/attributes";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the wrap-up for this conversation participant. 
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.provisional] -  Indicates if the wrap-up code is provisional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsMessageParticipantWrapup(conversationId, participantId, query) {
		const endpointPath = "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/wrapup";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("provisional" in query && this.#checkJSONSchemaType(query["provisional"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "provisional", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update conversation participant
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {MediaParticipantRequest} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/{conversationId}/participants/{participantId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsMessageParticipant(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/messages/{conversationId}/participants/{participantId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update conversation participant's communication by disconnecting it.
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {MediaParticipantRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/communications/{communicationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsMessageParticipantCommunication(conversationId, participantId, communicationId, body) {
		const endpointPath = "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/communications/{communicationId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the wrap-up for this conversation communication. 
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.provisional] -  Indicates if the wrap-up code is provisional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsMessageParticipantCommunicationWrapup(conversationId, participantId, communicationId, query) {
		const endpointPath = "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("provisional" in query && this.#checkJSONSchemaType(query["provisional"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "provisional", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Apply wrap-up for this conversation communication
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {WrapupInput} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsMessageParticipantCommunicationWrapup(conversationId, participantId, communicationId, body) {
		const endpointPath = "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get conversation message
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} messageId - messageId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.useNormalizedMessage] -  If true, response removes deprecated fields (textBody, media, stickers)
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/{conversationId}/messages/{messageId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsMessageMessage(conversationId, messageId, query) {
		const endpointPath = "/api/v2/conversations/messages/{conversationId}/messages/{messageId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(messageId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "messageId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("useNormalizedMessage" in query && this.#checkJSONSchemaType(query["useNormalizedMessage"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "useNormalizedMessage", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.messageId = messageId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create media
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} communicationId - communicationId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/{conversationId}/communications/{communicationId}/messages/media" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	postConversationsMessageCommunicationMessagesMedia(conversationId, communicationId) {
		const endpointPath = "/api/v2/conversations/messages/{conversationId}/communications/{communicationId}/messages/media";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.communicationId = communicationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get media
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} communicationId - communicationId
	 * @param {string} mediaId - mediaId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/{conversationId}/communications/{communicationId}/messages/media/{mediaId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationsMessageCommunicationMessagesMediaMediaId(conversationId, communicationId, mediaId) {
		const endpointPath = "/api/v2/conversations/messages/{conversationId}/communications/{communicationId}/messages/media/{mediaId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		if (this.#checkJSONSchemaType(mediaId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "mediaId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.pathParameters.mediaId = mediaId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Send an agentless outbound message
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.useNormalizedMessage] -  If true, response removes deprecated fields (textBody, messagingTemplate)
	 * @param {SendAgentlessOutboundMessageRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/agentless" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsMessagesAgentless(query, body) {
		const endpointPath = "/api/v2/conversations/messages/agentless";
		const endpointMethod = "POST";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("useNormalizedMessage" in query && this.#checkJSONSchemaType(query["useNormalizedMessage"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "useNormalizedMessage", "boolean");
			}
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Send an inbound Open Message
	 * @async
	 * @param {OpenNormalizedMessage} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/inbound/open" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	postConversationsMessagesInboundOpen(body) {
		const endpointPath = "/api/v2/conversations/messages/inbound/open";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Send an inbound Open Event Message
	 * @async
	 * @param {string} integrationId - integrationId
	 * @param {OpenInboundNormalizedEvent} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/{integrationId}/inbound/open/event" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsMessageInboundOpenEvent(integrationId, body) {
		const endpointPath = "/api/v2/conversations/messages/{integrationId}/inbound/open/event";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(integrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "integrationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.integrationId = integrationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Send inbound Open Message
	 * @async
	 * @param {string} integrationId - integrationId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.prefetchConversationId] -  Indicates whether or not to prefetch conversationId
	 * @param {OpenInboundNormalizedMessage} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/{integrationId}/inbound/open/message" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsMessageInboundOpenMessage(integrationId, query, body) {
		const endpointPath = "/api/v2/conversations/messages/{integrationId}/inbound/open/message";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(integrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "integrationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("prefetchConversationId" in query && this.#checkJSONSchemaType(query["prefetchConversationId"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "prefetchConversationId", "boolean");
			}
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.integrationId = integrationId;
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Send an inbound Open Receipt Message
	 * @async
	 * @param {string} integrationId - integrationId
	 * @param {OpenInboundNormalizedReceipt} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/{integrationId}/inbound/open/receipt" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsMessageInboundOpenReceipt(integrationId, body) {
		const endpointPath = "/api/v2/conversations/messages/{integrationId}/inbound/open/receipt";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(integrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "integrationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.integrationId = integrationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Send message typing event
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} communicationId - communicationId
	 * @param {MessageTypingEventRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messages/{conversationId}/communications/{communicationId}/typing" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsMessageCommunicationTyping(conversationId, communicationId, body) {
		const endpointPath = "/api/v2/conversations/messages/{conversationId}/communications/{communicationId}/typing";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a conversation by setting its recording state
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {SetRecordingState} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/screenshares/{conversationId}/recordingstate" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	putConversationsScreenshareRecordingstate(conversationId, body) {
		const endpointPath = "/api/v2/conversations/screenshares/{conversationId}/recordingstate";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the wrap-up for this conversation communication. 
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.provisional] -  Indicates if the wrap-up code is provisional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/screenshares/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @deprecated
	 */
	getConversationsScreenshareParticipantCommunicationWrapup(conversationId, participantId, communicationId, query) {
		const endpointPath = "/api/v2/conversations/screenshares/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("provisional" in query && this.#checkJSONSchemaType(query["provisional"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "provisional", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Apply wrap-up for this conversation communication
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {WrapupInput} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/screenshares/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	postConversationsScreenshareParticipantCommunicationWrapup(conversationId, participantId, communicationId, body) {
		const endpointPath = "/api/v2/conversations/screenshares/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a conversation by setting its recording state
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {SetRecordingState} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/socials/{conversationId}/recordingstate" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putConversationsSocialRecordingstate(conversationId, body) {
		const endpointPath = "/api/v2/conversations/socials/{conversationId}/recordingstate";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the wrap-up for this conversation communication. 
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.provisional] -  Indicates if the wrap-up code is provisional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/socials/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsSocialParticipantCommunicationWrapup(conversationId, participantId, communicationId, query) {
		const endpointPath = "/api/v2/conversations/socials/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("provisional" in query && this.#checkJSONSchemaType(query["provisional"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "provisional", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Apply wrap-up for this conversation communication
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {WrapupInput} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/socials/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsSocialParticipantCommunicationWrapup(conversationId, participantId, communicationId, body) {
		const endpointPath = "/api/v2/conversations/socials/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a conversation by setting its recording state
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {SetRecordingState} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/videos/{conversationId}/recordingstate" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putConversationsVideoRecordingstate(conversationId, body) {
		const endpointPath = "/api/v2/conversations/videos/{conversationId}/recordingstate";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the wrap-up for this conversation communication. 
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.provisional] -  Indicates if the wrap-up code is provisional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/videos/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsVideoParticipantCommunicationWrapup(conversationId, participantId, communicationId, query) {
		const endpointPath = "/api/v2/conversations/videos/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("provisional" in query && this.#checkJSONSchemaType(query["provisional"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "provisional", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Apply wrap-up for this conversation communication
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} participantId - participantId
	 * @param {string} communicationId - communicationId
	 * @param {WrapupInput} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/videos/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsVideoParticipantCommunicationWrapup(conversationId, participantId, communicationId, body) {
		const endpointPath = "/api/v2/conversations/videos/{conversationId}/participants/{participantId}/communications/{communicationId}/wrapup";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(communicationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "communicationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.communicationId = communicationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a list of Integrations
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string[]} [query.expand] -  Expand instructions for the return value.
	 * @param {string} [query.supportedContent.id] -  Filter integrations returned based on the supported content ID
	 * @param {string} [query.messagingSetting.id] -  Filter integrations returned based on the setting ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsMessagingIntegrations(query) {
		const endpointPath = "/api/v2/conversations/messaging/integrations";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "array");
			}
			if ("supportedContent.id" in query && this.#checkJSONSchemaType(query["supportedContent.id"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "supportedContent.id", "string");
			}
			if ("messagingSetting.id" in query && this.#checkJSONSchemaType(query["messagingSetting.id"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "messagingSetting.id", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get conversation threading window timeline for each messaging type
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/threadingtimeline" endpoint.
	 */
	getConversationsMessagingThreadingtimeline() {
		const endpointPath = "/api/v2/conversations/messaging/threadingtimeline";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update conversation threading window timeline for each messaging type
	 * @async
	 * @param {ConversationThreadingWindow} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/threadingtimeline" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putConversationsMessagingThreadingtimeline(body) {
		const endpointPath = "/api/v2/conversations/messaging/threadingtimeline";
		const endpointMethod = "PUT";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get Genesys Facebook App Id
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/facebook/app" endpoint.
	 */
	getConversationsMessagingFacebookApp() {
		const endpointPath = "/api/v2/conversations/messaging/facebook/app";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a Facebook messaging integration
	 * @async
	 * @param {string} integrationId - Integration ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.expand] -  Expand instructions for the return value.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/facebook/{integrationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsMessagingIntegrationsFacebookIntegrationId(integrationId, query) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/facebook/{integrationId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(integrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "integrationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.integrationId = integrationId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a Facebook messaging integration
	 * @async
	 * @param {string} integrationId - Integration ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/facebook/{integrationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteConversationsMessagingIntegrationsFacebookIntegrationId(integrationId) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/facebook/{integrationId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(integrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "integrationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.integrationId = integrationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update Facebook messaging integration
	 * @async
	 * @param {string} integrationId - Integration ID
	 * @param {FacebookIntegrationUpdateRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/facebook/{integrationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsMessagingIntegrationsFacebookIntegrationId(integrationId, body) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/facebook/{integrationId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(integrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "integrationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.integrationId = integrationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a list of Facebook Integrations
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.expand] -  Expand instructions for the return value.
	 * @param {string} [query.supportedContent.id] -  Filter integrations returned based on the supported content ID
	 * @param {string} [query.messagingSetting.id] -  Filter integrations returned based on the setting ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/facebook" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsMessagingIntegrationsFacebook(query) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/facebook";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
			if ("supportedContent.id" in query && this.#checkJSONSchemaType(query["supportedContent.id"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "supportedContent.id", "string");
			}
			if ("messagingSetting.id" in query && this.#checkJSONSchemaType(query["messagingSetting.id"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "messagingSetting.id", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a Facebook Integration
	 * @async
	 * @param {FacebookIntegrationRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/facebook" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsMessagingIntegrationsFacebook(body) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/facebook";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a list of Facebook Permissions
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/facebook/permissions" endpoint.
	 */
	getConversationsMessagingFacebookPermissions() {
		const endpointPath = "/api/v2/conversations/messaging/facebook/permissions";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get Instagram messaging integration
	 * @async
	 * @param {string} integrationId - Integration ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.expand] -  Expand instructions for the return value.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/instagram/{integrationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsMessagingIntegrationsInstagramIntegrationId(integrationId, query) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/instagram/{integrationId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(integrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "integrationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.integrationId = integrationId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete Instagram messaging integration
	 * @async
	 * @param {string} integrationId - Integration ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/instagram/{integrationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteConversationsMessagingIntegrationsInstagramIntegrationId(integrationId) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/instagram/{integrationId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(integrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "integrationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.integrationId = integrationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update Instagram messaging integration
	 * @async
	 * @param {string} integrationId - Integration ID
	 * @param {InstagramIntegrationUpdateRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/instagram/{integrationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsMessagingIntegrationsInstagramIntegrationId(integrationId, body) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/instagram/{integrationId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(integrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "integrationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.integrationId = integrationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a list of Instagram Integrations
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.expand] -  Expand instructions for the return value.
	 * @param {string} [query.supportedContent.id] -  Filter integrations returned based on the supported content ID
	 * @param {string} [query.messagingSetting.id] -  Filter integrations returned based on the setting ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/instagram" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsMessagingIntegrationsInstagram(query) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/instagram";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
			if ("supportedContent.id" in query && this.#checkJSONSchemaType(query["supportedContent.id"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "supportedContent.id", "string");
			}
			if ("messagingSetting.id" in query && this.#checkJSONSchemaType(query["messagingSetting.id"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "messagingSetting.id", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create Instagram Integration
	 * @async
	 * @param {InstagramIntegrationRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/instagram" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsMessagingIntegrationsInstagram(body) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/instagram";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get an Open messaging integration
	 * @async
	 * @param {string} integrationId - Integration ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.expand] -  Expand instructions for the return value.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/open/{integrationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsMessagingIntegrationsOpenIntegrationId(integrationId, query) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/open/{integrationId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(integrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "integrationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.integrationId = integrationId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete an Open messaging integration
	 * @async
	 * @param {string} integrationId - Integration ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/open/{integrationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteConversationsMessagingIntegrationsOpenIntegrationId(integrationId) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/open/{integrationId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(integrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "integrationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.integrationId = integrationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update an Open messaging integration
	 * @async
	 * @param {string} integrationId - Integration ID
	 * @param {OpenIntegrationUpdateRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/open/{integrationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsMessagingIntegrationsOpenIntegrationId(integrationId, body) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/open/{integrationId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(integrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "integrationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.integrationId = integrationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a list of Open messaging integrations
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.expand] -  Expand instructions for the return value.
	 * @param {string} [query.supportedContent.id] -  Filter integrations returned based on the supported content ID
	 * @param {string} [query.messagingSetting.id] -  Filter integrations returned based on the setting ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/open" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsMessagingIntegrationsOpen(query) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/open";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
			if ("supportedContent.id" in query && this.#checkJSONSchemaType(query["supportedContent.id"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "supportedContent.id", "string");
			}
			if ("messagingSetting.id" in query && this.#checkJSONSchemaType(query["messagingSetting.id"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "messagingSetting.id", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create an Open messaging integration
	 * @async
	 * @param {OpenIntegrationRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/open" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsMessagingIntegrationsOpen(body) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/open";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the organization's default settings that will be used as the default when creating an integration.
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/settings/default" endpoint.
	 */
	getConversationsMessagingSettingsDefault() {
		const endpointPath = "/api/v2/conversations/messaging/settings/default";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Set the organization's default setting that may be applied to to integrations without settings
	 * @async
	 * @param {MessagingSettingDefaultRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/settings/default" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putConversationsMessagingSettingsDefault(body) {
		const endpointPath = "/api/v2/conversations/messaging/settings/default";
		const endpointMethod = "PUT";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete the organization's default setting, a global default will be applied to integrations without settings
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/settings/default" endpoint.
	 */
	deleteConversationsMessagingSettingsDefault() {
		const endpointPath = "/api/v2/conversations/messaging/settings/default";
		const endpointMethod = "DELETE";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a list of messaging settings
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/settings" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsMessagingSettings(query) {
		const endpointPath = "/api/v2/conversations/messaging/settings";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a messaging setting
	 * @async
	 * @param {MessagingSettingRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/settings" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsMessagingSettings(body) {
		const endpointPath = "/api/v2/conversations/messaging/settings";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a messaging setting
	 * @async
	 * @param {string} messageSettingId - Message Setting ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/settings/{messageSettingId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationsMessagingSetting(messageSettingId) {
		const endpointPath = "/api/v2/conversations/messaging/settings/{messageSettingId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(messageSettingId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "messageSettingId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.messageSettingId = messageSettingId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a messaging setting
	 * @async
	 * @param {string} messageSettingId - Message Setting ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/settings/{messageSettingId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteConversationsMessagingSetting(messageSettingId) {
		const endpointPath = "/api/v2/conversations/messaging/settings/{messageSettingId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(messageSettingId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "messageSettingId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.messageSettingId = messageSettingId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a messaging setting
	 * @async
	 * @param {string} messageSettingId - Message Setting ID
	 * @param {MessagingSettingPatchRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/settings/{messageSettingId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsMessagingSetting(messageSettingId, body) {
		const endpointPath = "/api/v2/conversations/messaging/settings/{messageSettingId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(messageSettingId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "messageSettingId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.messageSettingId = messageSettingId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the organization's default supported content profile that will be used as the default when creating an integration.
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/supportedcontent/default" endpoint.
	 */
	getConversationsMessagingSupportedcontentDefault() {
		const endpointPath = "/api/v2/conversations/messaging/supportedcontent/default";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Set the organization's default supported content profile that may be assigned to an integration when it is created.
	 * @async
	 * @param {SupportedContentReference} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/supportedcontent/default" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putConversationsMessagingSupportedcontentDefault(body) {
		const endpointPath = "/api/v2/conversations/messaging/supportedcontent/default";
		const endpointMethod = "PUT";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a supported content profile
	 * @async
	 * @param {string} supportedContentId - Supported Content ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/supportedcontent/{supportedContentId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationsMessagingSupportedcontentSupportedContentId(supportedContentId) {
		const endpointPath = "/api/v2/conversations/messaging/supportedcontent/{supportedContentId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(supportedContentId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "supportedContentId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.supportedContentId = supportedContentId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a supported content profile
	 * @async
	 * @param {string} supportedContentId - Supported Content ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/supportedcontent/{supportedContentId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteConversationsMessagingSupportedcontentSupportedContentId(supportedContentId) {
		const endpointPath = "/api/v2/conversations/messaging/supportedcontent/{supportedContentId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(supportedContentId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "supportedContentId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.supportedContentId = supportedContentId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a supported content profile
	 * @async
	 * @param {string} supportedContentId - Supported Content ID
	 * @param {SupportedContent} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/supportedcontent/{supportedContentId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsMessagingSupportedcontentSupportedContentId(supportedContentId, body) {
		const endpointPath = "/api/v2/conversations/messaging/supportedcontent/{supportedContentId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(supportedContentId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "supportedContentId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.supportedContentId = supportedContentId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a list of Supported Content profiles
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/supportedcontent" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsMessagingSupportedcontent(query) {
		const endpointPath = "/api/v2/conversations/messaging/supportedcontent";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a Supported Content profile
	 * @async
	 * @param {SupportedContent} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/supportedcontent" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsMessagingSupportedcontent(body) {
		const endpointPath = "/api/v2/conversations/messaging/supportedcontent";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get Twitter messaging integration
	 * @async
	 * @param {string} integrationId - Integration ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.expand] -  Expand instructions for the return value.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/twitter/{integrationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsMessagingIntegrationsTwitterIntegrationId(integrationId, query) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/twitter/{integrationId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(integrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "integrationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.integrationId = integrationId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete Twitter messaging integration
	 * @async
	 * @param {string} integrationId - Integration ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/twitter/{integrationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteConversationsMessagingIntegrationsTwitterIntegrationId(integrationId) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/twitter/{integrationId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(integrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "integrationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.integrationId = integrationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a Twitter messaging integration
	 * @async
	 * @param {string} integrationId - Integration ID
	 * @param {TwitterIntegrationUpdateRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/twitter/{integrationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsMessagingIntegrationsTwitterIntegrationId(integrationId, body) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/twitter/{integrationId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(integrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "integrationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.integrationId = integrationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a list of Twitter Integrations
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.expand] -  Expand instructions for the return value.
	 * @param {string} [query.supportedContent.id] -  Filter integrations returned based on the supported content ID
	 * @param {string} [query.messagingSetting.id] -  Filter integrations returned based on the setting ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/twitter" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsMessagingIntegrationsTwitter(query) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/twitter";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
			if ("supportedContent.id" in query && this.#checkJSONSchemaType(query["supportedContent.id"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "supportedContent.id", "string");
			}
			if ("messagingSetting.id" in query && this.#checkJSONSchemaType(query["messagingSetting.id"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "messagingSetting.id", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create Twitter Integration
	 * @async
	 * @param {TwitterIntegrationRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/twitter" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsMessagingIntegrationsTwitter(body) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/twitter";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get twitter oauth settings
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/twitter/oauth/settings" endpoint.
	 */
	getConversationsMessagingIntegrationsTwitterOauthSettings() {
		const endpointPath = "/api/v2/conversations/messaging/integrations/twitter/oauth/settings";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get twitter oauth settings to patch an integration
	 * @async
	 * @param {string} integrationId - Integration Id of an existing integration that needs to be patched with new oauth settings
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/{integrationId}/twitter/oauth/settings" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationsMessagingIntegrationTwitterOauthSettings(integrationId) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/{integrationId}/twitter/oauth/settings";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(integrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "integrationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.integrationId = integrationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Activate a WhatsApp messaging integration created using the WhatsApp embedded signup flow
	 * @async
	 * @param {string} integrationId - Integration ID
	 * @param {WhatsAppEmbeddedSignupIntegrationActivationRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/whatsapp/embeddedsignup/{integrationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsMessagingIntegrationsWhatsappEmbeddedsignupIntegrationId(integrationId, body) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/whatsapp/embeddedsignup/{integrationId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(integrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "integrationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.integrationId = integrationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a WhatsApp Integration using the WhatsApp embedded signup flow
	 * @async
	 * @param {WhatsAppEmbeddedSignupIntegrationRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/whatsapp/embeddedsignup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationsMessagingIntegrationsWhatsappEmbeddedsignup(body) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/whatsapp/embeddedsignup";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a WhatsApp messaging integration
	 * @async
	 * @param {string} integrationId - Integration ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.expand] -  Expand instructions for the return value.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/whatsapp/{integrationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsMessagingIntegrationsWhatsappIntegrationId(integrationId, query) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/whatsapp/{integrationId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(integrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "integrationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.integrationId = integrationId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a WhatsApp messaging integration
	 * @async
	 * @param {string} integrationId - Integration ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/whatsapp/{integrationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteConversationsMessagingIntegrationsWhatsappIntegrationId(integrationId) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/whatsapp/{integrationId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(integrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "integrationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.integrationId = integrationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a WhatsApp messaging integration
	 * @async
	 * @param {string} integrationId - Integration ID
	 * @param {WhatsAppIntegrationUpdateRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/whatsapp/{integrationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationsMessagingIntegrationsWhatsappIntegrationId(integrationId, body) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/whatsapp/{integrationId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(integrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "integrationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.integrationId = integrationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a list of WhatsApp Integrations
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.expand] -  Expand instructions for the return value.
	 * @param {string} [query.supportedContent.id] -  Filter integrations returned based on the supported content ID
	 * @param {string} [query.messagingSetting.id] -  Filter integrations returned based on the setting ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/whatsapp" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationsMessagingIntegrationsWhatsapp(query) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/whatsapp";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
			if ("supportedContent.id" in query && this.#checkJSONSchemaType(query["supportedContent.id"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "supportedContent.id", "string");
			}
			if ("messagingSetting.id" in query && this.#checkJSONSchemaType(query["messagingSetting.id"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "messagingSetting.id", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * [This API is deprecated. Use POST /api/v2/conversations/messaging/integrations/whatsapp/embeddedsignup instead] Create a WhatsApp Integration
	 * @async
	 * @param {WhatsAppIntegrationRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/messaging/integrations/whatsapp" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	postConversationsMessagingIntegrationsWhatsapp(body) {
		const endpointPath = "/api/v2/conversations/messaging/integrations/whatsapp";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a code used to add a communication to this participant
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @param {string} participantId - participant ID
	 * @param {string} addCommunicationCode - addCommunicationCode
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/participants/{participantId}/codes/{addCommunicationCode}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteConversationParticipantCode(conversationId, participantId, addCommunicationCode) {
		const endpointPath = "/api/v2/conversations/{conversationId}/participants/{participantId}/codes/{addCommunicationCode}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(addCommunicationCode, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "addCommunicationCode", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.addCommunicationCode = addCommunicationCode;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a new callback for the specified participant on the conversation.
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @param {string} participantId - participant ID
	 * @param {CreateCallbackOnConversationCommand} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/participants/{participantId}/callbacks" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationParticipantCallbacks(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/{conversationId}/participants/{participantId}/callbacks";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a participant.
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @param {string} participantId - participant ID
	 * @param {MediaParticipantRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/participants/{participantId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationParticipant(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/{conversationId}/participants/{participantId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Replace this participant with the specified user and/or address
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @param {string} participantId - participant ID
	 * @param {TransferRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/participants/{participantId}/replace" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationParticipantReplace(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/{conversationId}/participants/{participantId}/replace";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Sends DTMF to the participant
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @param {string} participantId - participant ID
	 * @param {Digits} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/participants/{participantId}/digits" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationParticipantDigits(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/{conversationId}/participants/{participantId}/digits";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get list of wrapup codes for this conversation participant
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @param {string} participantId - participant ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/participants/{participantId}/wrapupcodes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationParticipantWrapupcodes(conversationId, participantId) {
		const endpointPath = "/api/v2/conversations/{conversationId}/participants/{participantId}/wrapupcodes";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update the attributes on a conversation participant.
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @param {string} participantId - participant ID
	 * @param {ParticipantAttributes} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/participants/{participantId}/attributes" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchConversationParticipantAttributes(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/{conversationId}/participants/{participantId}/attributes";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the wrap-up for this conversation participant. 
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @param {string} participantId - participant ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.provisional] -  Indicates if the wrap-up code is provisional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/participants/{participantId}/wrapup" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationParticipantWrapup(conversationId, participantId, query) {
		const endpointPath = "/api/v2/conversations/{conversationId}/participants/{participantId}/wrapup";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("provisional" in query && this.#checkJSONSchemaType(query["provisional"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "provisional", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Replace this participant with the specified agent
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @param {string} participantId - participant ID
	 * @param {TransferToAgentRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/participants/{participantId}/replace/agent" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationParticipantReplaceAgent(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/{conversationId}/participants/{participantId}/replace/agent";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Replace this participant with the specified queue
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @param {string} participantId - participant ID
	 * @param {TransferToQueueRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/participants/{participantId}/replace/queue" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationParticipantReplaceQueue(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/{conversationId}/participants/{participantId}/replace/queue";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Replace this participant with the an external contact
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @param {string} participantId - participant ID
	 * @param {TransferToExternalRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/participants/{participantId}/replace/external" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationParticipantReplaceExternal(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/{conversationId}/participants/{participantId}/replace/external";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Set flagged reason on conversation participant to indicate bad conversation quality.
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @param {string} participantId - participant ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/participants/{participantId}/flaggedreason" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	putConversationParticipantFlaggedreason(conversationId, participantId) {
		const endpointPath = "/api/v2/conversations/{conversationId}/participants/{participantId}/flaggedreason";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Remove flagged reason from conversation participant.
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @param {string} participantId - participant ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/participants/{participantId}/flaggedreason" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteConversationParticipantFlaggedreason(conversationId, participantId) {
		const endpointPath = "/api/v2/conversations/{conversationId}/participants/{participantId}/flaggedreason";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Fetch info on a secure session
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @param {string} participantId - participant ID
	 * @param {string} secureSessionId - secure IVR session ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/participants/{participantId}/secureivrsessions/{secureSessionId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationParticipantSecureivrsession(conversationId, participantId, secureSessionId) {
		const endpointPath = "/api/v2/conversations/{conversationId}/participants/{participantId}/secureivrsessions/{secureSessionId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		if (this.#checkJSONSchemaType(secureSessionId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "secureSessionId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.pathParameters.secureSessionId = secureSessionId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a list of secure sessions for this participant.
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @param {string} participantId - participant ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/participants/{participantId}/secureivrsessions" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationParticipantSecureivrsessions(conversationId, participantId) {
		const endpointPath = "/api/v2/conversations/{conversationId}/participants/{participantId}/secureivrsessions";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create secure IVR session. Only a participant in the conversation can invoke a secure IVR.
	 * @async
	 * @param {string} conversationId - conversation ID
	 * @param {string} participantId - participant ID
	 * @param {CreateSecureSession} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/participants/{participantId}/secureivrsessions" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationParticipantSecureivrsessions(conversationId, participantId, body) {
		const endpointPath = "/api/v2/conversations/{conversationId}/participants/{participantId}/secureivrsessions";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(participantId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "participantId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.participantId = participantId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Suggestion feedback.
	 * @async
	 * @param {string} conversationId - Conversation ID
	 * @param {Feedback} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/suggestions/feedback" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	postConversationSuggestionsFeedback(conversationId, body) {
		const endpointPath = "/api/v2/conversations/{conversationId}/suggestions/feedback";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get all suggestions for a conversation.
	 * @async
	 * @param {string} conversationId - Conversation ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.before] -  The cursor that points to the start of the set of entities that has been returned.
	 * @param {string} [query.after] -  The cursor that points to the end of the set of entities that has been returned.
	 * @param {string} [query.pageSize] -  Number of entities to return. Maximum of 200.
	 * @param {string} [query.type] -  Suggestion type to filter by.
	 * @param {string} [query.state] -  Suggestion state to filter Copilot suggestions.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/suggestions" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getConversationSuggestions(conversationId, query) {
		const endpointPath = "/api/v2/conversations/{conversationId}/suggestions";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("before" in query && this.#checkJSONSchemaType(query["before"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "before", "string");
			}
			if ("after" in query && this.#checkJSONSchemaType(query["after"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "after", "string");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "string");
			}
			if ("type" in query && this.#checkJSONSchemaType(query["type"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "type", "string");
			}
			if ("state" in query && this.#checkJSONSchemaType(query["state"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "state", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get Suggestion.
	 * @async
	 * @param {string} conversationId - Conversation ID
	 * @param {string} suggestionId - Suggestion ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/suggestions/{suggestionId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationSuggestion(conversationId, suggestionId) {
		const endpointPath = "/api/v2/conversations/{conversationId}/suggestions/{suggestionId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(suggestionId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "suggestionId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.suggestionId = suggestionId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Save an engagement on the suggestion.
	 * @async
	 * @param {string} conversationId - Conversation ID
	 * @param {string} suggestionId - Suggestion ID
	 * @param {SuggestionEngagement} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/suggestions/{suggestionId}/engagement" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationSuggestionEngagement(conversationId, suggestionId, body) {
		const endpointPath = "/api/v2/conversations/{conversationId}/suggestions/{suggestionId}/engagement";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(suggestionId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "suggestionId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.suggestionId = suggestionId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the summaries of the conversation.
	 * @async
	 * @param {string} conversationId - Conversation ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/summaries" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getConversationSummaries(conversationId) {
		const endpointPath = "/api/v2/conversations/{conversationId}/summaries";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Submit feedback for the summary.
	 * @async
	 * @param {string} conversationId - Conversation ID
	 * @param {string} summaryId - Summary ID
	 * @param {FeedbackAddRequest} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/conversations/{conversationId}/summaries/{summaryId}/feedback" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postConversationSummaryFeedback(conversationId, summaryId, body) {
		const endpointPath = "/api/v2/conversations/{conversationId}/summaries/{summaryId}/feedback";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(summaryId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "summaryId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.summaryId = summaryId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * @description Checks that a value is of the proper JSON schema type
	 * @param {*} value - The value to check
	 * @param {string} jsonSchemaType - The JSON schema type to check against
	 * @returns {boolean} Returns true if the value is of the proper JSON schema type, false otherwise
	 */
	#checkJSONSchemaType(value, jsonSchemaType) {
		const PASSTHROUGH_JSON_SCHEMA_TYPES = ["boolean", "number", "string", "object"];

		// Check if the type is a passthrough type
		if (PASSTHROUGH_JSON_SCHEMA_TYPES.includes(jsonSchemaType)) {
			return typeof value === jsonSchemaType;
		}

		// Check if the type is an integer
		if (jsonSchemaType === "integer") {
			return Number.isInteger(value);
		}

		// Check if the type is an array
		if (jsonSchemaType === "array") {
			return Array.isArray(value);
		}

		// Check if the type is null
		if (jsonSchemaType === "null") {
			return value === null;
		}

		// Otherwise, return false
		return false;
	}
}

export { ConversationsAPI };