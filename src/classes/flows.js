/**
 * IVR Flows
 * @module gc-platform-api-flows
 * @documentation https://developer.genesys.cloud/analyticsdatamanagement/analytics/aggregate/flow-query
 * @license MIT
 */

// This file was automatically generated by the Generate Genesys Cloud Platform API classes utility on 2025-04-24T15:04:25.221Z

// TODO: Implement JSON schema verification for input and output objects
// TODO: Implement HTTP response typedefs

// Set strict mode
"use strict";

// Errors
import { errors } from "../gc-platform-api-client-errors.js";

// Symbols
import { symbols } from "../gc-platform-api-client-symbols.js";

/** @typedef {import("../gc-platform-api-client-class.js").GCPlatformAPIClient} GCPlatformAPIClient */
/** @typedef {import("@jfabello/http-client").HTTPResponse} HTTPResponse */

/**
 * @typedef {object} AggregationRange
 * @property {number} [gte] - Greater than or equal to
 * @property {number} [lt] - Less than
 */
 
/**
 * @typedef {object} FlowActivityQuery
 * @property {FlowActivityQueryMetric[]} metrics - List of requested metrics
 * @property {string[]} groupBy - Dimension(s) to group by
 * @property {FlowActivityQueryFilter} [filter] - Filter to return a subset of observations. Expresses boolean logical predicates as well as dimensional filters
 * @property {string} [order] - Sort the result set in ascending/descending order. Default is ascending
 */
 
/**
 * @typedef {object} FlowActivityQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {FlowActivityQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} FlowActivityQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {FlowActivityQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {FlowActivityQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} FlowActivityQueryMetric
 * @property {string} metric - The requested metric
 * @property {boolean} [details] - Flag for including observation details for this metric in the response
 */
 
/**
 * @typedef {object} FlowActivityQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} FlowAggregateQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {FlowAggregateQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} FlowAggregateQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {FlowAggregateQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {FlowAggregateQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} FlowAggregateQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} FlowAggregationQuery
 * @property {string} interval - Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string} [granularity] - Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
 * @property {string} [timeZone] - Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 * @property {string[]} [groupBy] - Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group.
 * @property {FlowAggregateQueryFilter} [filter] - Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {boolean} [flattenMultivaluedDimensions] - Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c')
 * @property {FlowAggregationView[]} [views] - Custom derived metric views
 * @property {string} [alternateTimeDimension] - Dimension to use as the alternative timestamp for data in the aggregate.  Choosing "eventTime" uses the actual time of the data event.
 */
 
/**
 * @typedef {object} FlowAggregationView
 * @property {string} target - Target metric name
 * @property {string} name - A unique name for this view. Must be distinct from other views and built-in metric names.
 * @property {string} function - Type of view you wish to create
 * @property {AggregationRange} [range] - Range of numbers for slicing up data
 */
 
/**
 * @typedef {object} FlowObservationQuery
 * @property {FlowObservationQueryFilter} filter - Filter to return a subset of observations. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {string[]} [detailMetrics] - Metrics for which to include additional detailed observations
 */
 
/**
 * @typedef {object} FlowObservationQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {FlowObservationQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} FlowObservationQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {FlowObservationQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {FlowObservationQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} FlowObservationQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} NumericRange
 * @property {number} [gt] - Greater than
 * @property {number} [gte] - Greater than or equal to
 * @property {number} [lt] - Less than
 * @property {number} [lte] - Less than or equal to
 */
 

/**
 * Flows - IVR Flows
 * @class Flows
 */
class FlowsAPI {
	// Private instance properties
	#gcPlatformAPIClient = null;

	/**
	 * Constructor for the Flows class
	 * @constructor
	 * @param {GCPlatformAPIClient} gcPlatformAPIClient - The Genesys Cloud Platform API client instance.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_INSTANCE_TYPE_INVALID} If the Genesys Cloud Platform API client instance argument is not an object.
	 */
	constructor(gcPlatformAPIClient) {
		// Check the Genesys Cloud Platform API client instance argument
		if (typeof gcPlatformAPIClient !== "object" || symbols.GCPlatformAPIClient in gcPlatformAPIClient === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_INSTANCE_TYPE_INVALID();
		}

		// Initialize the instance properties
		this.#gcPlatformAPIClient = gcPlatformAPIClient;
	}

	/**
	 * Query for flow aggregates
	 * @async
	 * @param {FlowAggregationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/flows/aggregates/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsFlowsAggregatesQuery(body) {
		const endpointPath = "/api/v2/analytics/flows/aggregates/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for flow observations
	 * @async
	 * @param {FlowObservationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/flows/observations/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsFlowsObservationsQuery(body) {
		const endpointPath = "/api/v2/analytics/flows/observations/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for flow activity observations
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  The desired page size
	 * @param {number} [query.pageNumber] -  The desired page number
	 * @param {FlowActivityQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/flows/activity/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsFlowsActivityQuery(query, body) {
		const endpointPath = "/api/v2/analytics/flows/activity/query";
		const endpointMethod = "POST";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * @description Checks that a value is of the proper JSON schema type
	 * @param {*} value - The value to check
	 * @param {string} jsonSchemaType - The JSON schema type to check against
	 * @returns {boolean} Returns true if the value is of the proper JSON schema type, false otherwise
	 */
	#checkJSONSchemaType(value, jsonSchemaType) {
		const PASSTHROUGH_JSON_SCHEMA_TYPES = ["boolean", "number", "string", "object"];

		// Check if the type is a passthrough type
		if (PASSTHROUGH_JSON_SCHEMA_TYPES.includes(jsonSchemaType)) {
			return typeof value === jsonSchemaType;
		}

		// Check if the type is an integer
		if (jsonSchemaType === "integer") {
			return Number.isInteger(value);
		}

		// Check if the type is an array
		if (jsonSchemaType === "array") {
			return Array.isArray(value);
		}

		// Check if the type is null
		if (jsonSchemaType === "null") {
			return value === null;
		}

		// Otherwise, return false
		return false;
	}
}

export { FlowsAPI };