/**
 * Analytics querying and reporting.
 * @module gc-platform-api-analytics
 * @documentation https://developer.genesys.cloud/analyticsdatamanagement/analytics/analytics-apis
 * @license MIT
 */

// This file was automatically generated by the Generate Genesys Cloud Platform API classes utility on 2025-11-26T23:43:17.512Z

// TODO: Implement JSON schema verification for input and output objects
// TODO: Implement HTTP response typedefs

// Set strict mode
"use strict";

// Errors
import { errors } from "../gc-platform-api-client-errors.js";

// Symbols
import { symbols } from "../gc-platform-api-client-symbols.js";

/** @typedef {import("../gc-platform-api-client-class.js").GCPlatformAPIClient} GCPlatformAPIClient */
/** @typedef {import("@jfabello/http-client").HTTPResponse} HTTPResponse */

/**
 * @typedef {object} ActionAggregateQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {ActionAggregateQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ActionAggregateQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {ActionAggregateQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {ActionAggregateQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ActionAggregateQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} ActionAggregationQuery
 * @property {string} interval - Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string} [granularity] - Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
 * @property {string} [timeZone] - Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 * @property {string[]} [groupBy] - Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group.
 * @property {ActionAggregateQueryFilter} [filter] - Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {boolean} [flattenMultivaluedDimensions] - Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c')
 * @property {ActionAggregationView[]} [views] - Custom derived metric views
 * @property {string} [alternateTimeDimension] - Dimension to use as the alternative timestamp for data in the aggregate.  Choosing "eventTime" uses the actual time of the data event.
 */
 
/**
 * @typedef {object} ActionAggregationView
 * @property {string} target - Target metric name
 * @property {string} name - A unique name for this view. Must be distinct from other views and built-in metric names.
 * @property {string} function - Type of view you wish to create
 * @property {AggregationRange} [range] - Range of numbers for slicing up data
 */
 
/**
 * @typedef {object} AgentCopilotAggregateQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {AgentCopilotAggregateQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} AgentCopilotAggregateQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {AgentCopilotAggregateQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {AgentCopilotAggregateQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} AgentCopilotAggregateQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} AgentCopilotAggregationQuery
 * @property {string} interval - Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string} [granularity] - Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
 * @property {string} [timeZone] - Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 * @property {string[]} [groupBy] - Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group.
 * @property {AgentCopilotAggregateQueryFilter} [filter] - Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {boolean} [flattenMultivaluedDimensions] - Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c')
 * @property {AgentCopilotAggregationView[]} [views] - Custom derived metric views
 * @property {string} [alternateTimeDimension] - Dimension to use as the alternative timestamp for data in the aggregate.  Choosing "eventTime" uses the actual time of the data event.
 * @property {string} [queryType] - Query type to use. Use groupBy for all matching results, and topN/bottomN for N results ordered by the sortMetric. Default is groupBy.
 * @property {AgentCopilotAggregationSort} [sortMetric] - Required when requesting multiple metrics. Only applicable for topN/bottomN query type.
 * @property {number} [limit] - How many results you want in an ordered list. Only applicable for topN/bottomN query type.
 */
 
/**
 * @typedef {object} AgentCopilotAggregationSort
 * @property {string} name - Name of the metric used for sorting values.
 * @property {string} function - Aggregation function used for the sort metric.
 */
 
/**
 * @typedef {object} AgentCopilotAggregationView
 * @property {string} target - Target metric name
 * @property {string} name - A unique name for this view. Must be distinct from other views and built-in metric names.
 * @property {string} function - Type of view you wish to create
 * @property {AggregationRange} [range] - Range of numbers for slicing up data
 */
 
/**
 * @typedef {object} AgentStateAgentQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {AgentStateAgentQueryPredicate[]} predicates - Describes a <dimension> = <value> filter used to perform matching
 */
 
/**
 * @typedef {object} AgentStateAgentQueryPredicate
 * @property {string} dimension - Left hand side for dimension predicates
 * @property {string} value - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} AgentStateCountsRequest
 * @property {AgentStateUserFilter} [userFilter] - Filters that target user-level data
 * @property {AgentStateSessionFilter} [sessionFilter] - Filters that target session-level data
 */
 
/**
 * @typedef {object} AgentStateQueryRequest
 * @property {AgentStateUserFilter} [userFilter] - Filters that target user-level data
 * @property {AgentStateSessionFilter} [sessionFilter] - Filters that target session-level data
 * @property {string} [userOrderBy] - Search user order dimension names; default to userName
 * @property {string} [userOrder] - Search user order direction; default to asc
 * @property {string} [sessionOrderBy] - Search session order dimension names; default to segmentStart
 * @property {string} [sessionOrder] - Search session order direction; default to asc
 */
 
/**
 * @typedef {object} AgentStateSessionFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {AgentStateSessionQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {AgentStateSessionQueryPredicate[]} [predicates] - Describes a <dimension> = <value> filter used to perform matching
 */
 
/**
 * @typedef {object} AgentStateSessionQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {AgentStateSessionQueryPredicate[]} predicates - Describes a <dimension> = <value> filter used to perform matching
 */
 
/**
 * @typedef {object} AgentStateSessionQueryPredicate
 * @property {string} dimension - Left hand side for dimension predicates
 * @property {string} value - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} AgentStateUserFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {AgentStateAgentQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {AgentStateAgentQueryPredicate[]} [predicates] - Describes a <dimension> = <value> filter used to perform matching
 */
 
/**
 * @typedef {object} AggregationRange
 * @property {number} [gte] - Greater than or equal to
 * @property {number} [lt] - Less than
 */
 
/**
 * @typedef {object} AnalyticsProperty
 * @property {string} [property] - User-defined rather than intrinsic system-observed values. These are tagged onto segments by other components within PureCloud or by API users directly.  This is the name of the user-defined property.
 * @property {string} [propertyType] - Indicates what the data type is (e.g. integer vs string) and therefore how to evaluate what would constitute a match
 * @property {string} [value] - What property value to match against
 */
 
/**
 * @typedef {object} AnalyticsQueryAggregation
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - For use with termFrequency aggregations
 * @property {string} [metric] - For use with numericRange aggregations
 * @property {number} [size] - For use with termFrequency aggregations
 * @property {AggregationRange[]} [ranges] - For use with numericRange aggregations
 */
 
/**
 * @typedef {object} AnalyticsReportingSettings
 * @property {boolean} [piiMaskingEnabled] - Indication of whether or not personal data is masked in data export and the Analytics/Reporting UI
 * @property {boolean} [queueAgentAccessObfuscation] - Indication of whether or not to obfuscate export data from the Queue Agent Details view based on User ACL
 * @property {boolean} [myInteractionsPiiMaskingEnabled] - Indicates whether PII data is masked in My Interaction export and the Analytics/Reporting UI
 */
 
/**
 * @typedef {object} AsyncConversationQuery
 * @property {ConversationDetailQueryFilter[]} [conversationFilters] - Filters that target conversation-level data
 * @property {SegmentDetailQueryFilter[]} [segmentFilters] - Filters that target individual segments within a conversation
 * @property {EvaluationDetailQueryFilter[]} [evaluationFilters] - Filters that target evaluations
 * @property {SurveyDetailQueryFilter[]} [surveyFilters] - Filters that target surveys
 * @property {ResolutionDetailQueryFilter[]} [resolutionFilters] - Filters that target resolutions
 * @property {string} [order] - Sort the result set in ascending/descending order. Default is ascending
 * @property {string} [orderBy] - Specify which data element within the result set to use for sorting. The options  to use as a basis for sorting the results: conversationStart, segmentStart, and segmentEnd. If not specified, the default is conversationStart
 * @property {string} interval - Specifies the date and time range of data being queried. Results will include all conversations that had activity during the interval. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {number} [limit] - Specify number of results to be returned
 * @property {boolean} [startOfDayIntervalMatching] - Add a filter to only include conversations that started after the beginning of the interval start date (UTC)
 */
 
/**
 * @typedef {object} AsyncUserDetailsQuery
 * @property {string} interval - Specifies the date and time range of data being queried. Conversations MUST have started within this time range to potentially be included within the result set. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {UserDetailQueryFilter[]} [userFilters] - Filters that target the users to retrieve data for
 * @property {PresenceDetailQueryFilter[]} [presenceFilters] - Filters that target system and organization presence-level data
 * @property {RoutingStatusDetailQueryFilter[]} [routingStatusFilters] - Filters that target agent routing status-level data
 * @property {string} [order] - Sort the result set in ascending/descending order. Default is ascending
 * @property {number} [limit] - Specify number of results to be returned
 */
 
/**
 * @typedef {object} BotAggregateQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {BotAggregateQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} BotAggregateQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {BotAggregateQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {BotAggregateQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} BotAggregateQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} BotAggregationQuery
 * @property {string} interval - Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string} [granularity] - Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
 * @property {string} [timeZone] - Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 * @property {string[]} [groupBy] - Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group.
 * @property {BotAggregateQueryFilter} [filter] - Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {boolean} [flattenMultivaluedDimensions] - Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c')
 * @property {BotAggregationView[]} [views] - Custom derived metric views
 * @property {string} [alternateTimeDimension] - Dimension to use as the alternative timestamp for data in the aggregate.  Choosing "eventTime" uses the actual time of the data event.
 */
 
/**
 * @typedef {object} BotAggregationView
 * @property {string} target - Target metric name
 * @property {string} name - A unique name for this view. Must be distinct from other views and built-in metric names.
 * @property {string} function - Type of view you wish to create
 * @property {AggregationRange} [range] - Range of numbers for slicing up data
 */
 
/**
 * @typedef {object} ChartColumn
 * @property {string} [id] - Column Id
 * @property {string} [columnType] - Type of column
 */
 
/**
 * @typedef {object} ConversationActivityQuery
 * @property {ConversationActivityQueryMetric[]} metrics - List of requested metrics
 * @property {string[]} groupBy - Dimension(s) to group by
 * @property {ConversationActivityQueryFilter} [filter] - Filter to return a subset of observations. Expresses boolean logical predicates as well as dimensional filters
 * @property {string} [order] - Sort the result set in ascending/descending order. Default is ascending
 */
 
/**
 * @typedef {object} ConversationActivityQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {ConversationActivityQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ConversationActivityQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {ConversationActivityQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {ConversationActivityQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ConversationActivityQueryMetric
 * @property {string} metric - The requested metric
 * @property {boolean} [details] - Flag for including observation details for this metric in the response
 */
 
/**
 * @typedef {object} ConversationActivityQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} ConversationAggregateQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {ConversationAggregateQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ConversationAggregateQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {ConversationAggregateQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {ConversationAggregateQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ConversationAggregateQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} ConversationAggregationQuery
 * @property {string} interval - Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string} [granularity] - Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
 * @property {string} [timeZone] - Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 * @property {string[]} [groupBy] - Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group.
 * @property {ConversationAggregateQueryFilter} [filter] - Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {boolean} [flattenMultivaluedDimensions] - Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c')
 * @property {ConversationAggregationView[]} [views] - Custom derived metric views
 * @property {string} [alternateTimeDimension] - Dimension to use as the alternative timestamp for data in the aggregate.  Choosing "eventTime" uses the actual time of the data event.
 */
 
/**
 * @typedef {object} ConversationAggregationView
 * @property {string} target - Target metric name
 * @property {string} name - A unique name for this view. Must be distinct from other views and built-in metric names.
 * @property {string} function - Type of view you wish to create
 * @property {AggregationRange} [range] - Range of numbers for slicing up data
 */
 
/**
 * @typedef {object} ConversationDetailQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {ConversationDetailQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ConversationDetailQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {ConversationDetailQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {ConversationDetailQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ConversationDetailQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [metric] - Left hand side for metric predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension or metric predicates
 * @property {NumericRange} [range] - Right hand side for dimension or metric predicates
 */
 
/**
 * @typedef {object} ConversationProperties
 * @property {boolean} [isWaiting] - Indicates filtering for waiting
 * @property {boolean} [isActive] - Indicates filtering for active
 * @property {boolean} [isAcd] - Indicates filtering for Acd
 * @property {boolean} [isPreferred] - Indicates filtering for Preferred Agent Routing
 * @property {boolean} [isScreenshare] - Indicates filtering for screenshare
 * @property {boolean} [isCobrowse] - Indicates filtering for Cobrowse
 * @property {boolean} [isVoicemail] - Indicates filtering for Voice mail
 * @property {boolean} [isFlagged] - Indicates filtering for flagged
 * @property {boolean} [isMonitored] - Indicates filtering for monitored
 * @property {boolean} [isScreenMonitored] - Indicates filtering for screenMonitored
 * @property {boolean} [filterWrapUpNotes] - Indicates filtering for WrapUpNotes
 * @property {boolean} [matchAll] - Indicates comparison operation, TRUE indicates filters will use AND logic, FALSE indicates OR logic
 */
 
/**
 * @typedef {object} ConversationQuery
 * @property {ConversationDetailQueryFilter[]} [conversationFilters] - Filters that target conversation-level data
 * @property {SegmentDetailQueryFilter[]} [segmentFilters] - Filters that target individual segments within a conversation
 * @property {EvaluationDetailQueryFilter[]} [evaluationFilters] - Filters that target evaluations
 * @property {SurveyDetailQueryFilter[]} [surveyFilters] - Filters that target surveys
 * @property {ResolutionDetailQueryFilter[]} [resolutionFilters] - Filters that target resolutions
 * @property {string} [order] - Sort the result set in ascending/descending order. Default is ascending
 * @property {string} [orderBy] - Specify which data element within the result set to use for sorting. The options  to use as a basis for sorting the results: conversationStart, segmentStart, and segmentEnd. If not specified, the default is conversationStart
 * @property {string} interval - Specifies the date and time range of data being queried. Results will only include conversations that started on a day touched by the interval. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {AnalyticsQueryAggregation[]} [aggregations] - Include faceted search and aggregate roll-ups describing your search results. This does not function as a filter, but rather, summary data about the data matching your filters
 * @property {PagingSpec} [paging] - Page size and number to control iterating through large result sets. Default page size is 25
 */
 
/**
 * @typedef {object} DashboardConfigurationBulkRequest
 * @property {string[]} dashboardConfigurationIds - The user supplied dashboard configuration ids
 */
 
/**
 * @typedef {object} DashboardConfigurationQueryRequest
 * @property {string[]} dashboardConfigurationIds - The user supplied dashboard configuration ids
 * @property {number} [pageNumber] - The page number of the queried response
 * @property {number} [pageSize] - The number of entities to return of the queried response. The max is 25
 * @property {string} [sortBy] - The order in which response will be sorted
 */
 
/**
 * @typedef {object} EvaluationAggregateQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {EvaluationAggregateQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} EvaluationAggregateQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {EvaluationAggregateQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {EvaluationAggregateQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} EvaluationAggregateQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} EvaluationAggregationQuery
 * @property {string} interval - Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string} [granularity] - Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
 * @property {string} [timeZone] - Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 * @property {string[]} [groupBy] - Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group.
 * @property {EvaluationAggregateQueryFilter} [filter] - Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {boolean} [flattenMultivaluedDimensions] - Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c')
 * @property {EvaluationAggregationView[]} [views] - Custom derived metric views
 * @property {string} [alternateTimeDimension] - Dimension to use as the alternative timestamp for data in the aggregate.  Choosing "eventTime" uses the actual time of the data event.
 */
 
/**
 * @typedef {object} EvaluationAggregationView
 * @property {string} target - Target metric name
 * @property {string} name - A unique name for this view. Must be distinct from other views and built-in metric names.
 * @property {string} function - Type of view you wish to create
 * @property {AggregationRange} [range] - Range of numbers for slicing up data
 */
 
/**
 * @typedef {object} EvaluationDetailQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {EvaluationDetailQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} EvaluationDetailQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {EvaluationDetailQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {EvaluationDetailQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} EvaluationDetailQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [metric] - Left hand side for metric predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension or metric predicates
 * @property {NumericRange} [range] - Right hand side for dimension or metric predicates
 */
 
/**
 * @typedef {object} FlowActivityQuery
 * @property {FlowActivityQueryMetric[]} metrics - List of requested metrics
 * @property {string[]} groupBy - Dimension(s) to group by
 * @property {FlowActivityQueryFilter} [filter] - Filter to return a subset of observations. Expresses boolean logical predicates as well as dimensional filters
 * @property {string} [order] - Sort the result set in ascending/descending order. Default is ascending
 */
 
/**
 * @typedef {object} FlowActivityQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {FlowActivityQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} FlowActivityQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {FlowActivityQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {FlowActivityQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} FlowActivityQueryMetric
 * @property {string} metric - The requested metric
 * @property {boolean} [details] - Flag for including observation details for this metric in the response
 */
 
/**
 * @typedef {object} FlowActivityQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} FlowAggregateQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {FlowAggregateQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} FlowAggregateQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {FlowAggregateQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {FlowAggregateQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} FlowAggregateQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} FlowAggregationQuery
 * @property {string} interval - Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string} [granularity] - Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
 * @property {string} [timeZone] - Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 * @property {string[]} [groupBy] - Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group.
 * @property {FlowAggregateQueryFilter} [filter] - Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {boolean} [flattenMultivaluedDimensions] - Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c')
 * @property {FlowAggregationView[]} [views] - Custom derived metric views
 * @property {string} [alternateTimeDimension] - Dimension to use as the alternative timestamp for data in the aggregate.  Choosing "eventTime" uses the actual time of the data event.
 */
 
/**
 * @typedef {object} FlowAggregationView
 * @property {string} target - Target metric name
 * @property {string} name - A unique name for this view. Must be distinct from other views and built-in metric names.
 * @property {string} function - Type of view you wish to create
 * @property {AggregationRange} [range] - Range of numbers for slicing up data
 */
 
/**
 * @typedef {object} FlowExecutionAggregateQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {FlowExecutionAggregateQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} FlowExecutionAggregateQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {FlowExecutionAggregateQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {FlowExecutionAggregateQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} FlowExecutionAggregateQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} FlowExecutionAggregationQuery
 * @property {string} interval - Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string} [granularity] - Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
 * @property {string} [timeZone] - Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 * @property {string[]} [groupBy] - Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group.
 * @property {FlowExecutionAggregateQueryFilter} [filter] - Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {boolean} [flattenMultivaluedDimensions] - Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c')
 * @property {FlowExecutionAggregationView[]} [views] - Custom derived metric views
 * @property {string} [alternateTimeDimension] - Dimension to use as the alternative timestamp for data in the aggregate.  Choosing "eventTime" uses the actual time of the data event.
 */
 
/**
 * @typedef {object} FlowExecutionAggregationView
 * @property {string} target - Target metric name
 * @property {string} name - A unique name for this view. Must be distinct from other views and built-in metric names.
 * @property {string} function - Type of view you wish to create
 * @property {AggregationRange} [range] - Range of numbers for slicing up data
 */
 
/**
 * @typedef {object} FlowObservationQuery
 * @property {FlowObservationQueryFilter} filter - Filter to return a subset of observations. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {string[]} [detailMetrics] - Metrics for which to include additional detailed observations
 */
 
/**
 * @typedef {object} FlowObservationQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {FlowObservationQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} FlowObservationQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {FlowObservationQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {FlowObservationQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} FlowObservationQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} JourneyAggregateQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {JourneyAggregateQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} JourneyAggregateQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {JourneyAggregateQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {JourneyAggregateQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} JourneyAggregateQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} JourneyAggregationQuery
 * @property {string} interval - Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string} [granularity] - Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
 * @property {string} [timeZone] - Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 * @property {string[]} [groupBy] - Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group.
 * @property {JourneyAggregateQueryFilter} [filter] - Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {boolean} [flattenMultivaluedDimensions] - Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c')
 * @property {JourneyAggregationView[]} [views] - Custom derived metric views
 * @property {string} [alternateTimeDimension] - Dimension to use as the alternative timestamp for data in the aggregate.  Choosing "eventTime" uses the actual time of the data event.
 */
 
/**
 * @typedef {object} JourneyAggregationView
 * @property {string} target - Target metric name
 * @property {string} name - A unique name for this view. Must be distinct from other views and built-in metric names.
 * @property {string} function - Type of view you wish to create
 * @property {AggregationRange} [range] - Range of numbers for slicing up data
 */
 
/**
 * @typedef {object} KnowledgeAggregateQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {KnowledgeAggregateQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} KnowledgeAggregateQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {KnowledgeAggregateQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {KnowledgeAggregateQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} KnowledgeAggregateQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} KnowledgeAggregationQuery
 * @property {string} interval - Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string} [granularity] - Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
 * @property {string} [timeZone] - Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 * @property {string[]} [groupBy] - Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group.
 * @property {KnowledgeAggregateQueryFilter} [filter] - Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {boolean} [flattenMultivaluedDimensions] - Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c')
 * @property {KnowledgeAggregationView[]} [views] - Custom derived metric views
 * @property {string} [alternateTimeDimension] - Dimension to use as the alternative timestamp for data in the aggregate.  Choosing "eventTime" uses the actual time of the data event.
 * @property {string} [queryType] - Query type to use. Use groupBy for all matching results, and topN/bottomN for N results ordered by the sortMetric. Default is groupBy.
 * @property {KnowledgeAggregationSort} [sortMetric] - Required when requesting multiple metrics. Only applicable for topN/bottomN query type.
 * @property {number} [limit] - How many results you want in an ordered list. Only applicable for topN/bottomN query type.
 */
 
/**
 * @typedef {object} KnowledgeAggregationSort
 * @property {string} name - Name of the metric used for sorting values.
 * @property {string} function - Aggregation function used for the sort metric.
 */
 
/**
 * @typedef {object} KnowledgeAggregationView
 * @property {string} target - Target metric name
 * @property {string} name - A unique name for this view. Must be distinct from other views and built-in metric names.
 * @property {string} function - Type of view you wish to create
 * @property {AggregationRange} [range] - Range of numbers for slicing up data
 */
 
/**
 * @typedef {object} NumericRange
 * @property {number} [gt] - Greater than
 * @property {number} [gte] - Greater than or equal to
 * @property {number} [lt] - Less than
 * @property {number} [lte] - Less than or equal to
 */
 
/**
 * @typedef {object} PagingSpec
 * @property {number} pageSize - How many results per page
 * @property {number} pageNumber - How many pages in
 */
 
/**
 * @typedef {object} PresenceDetailQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {PresenceDetailQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} PresenceDetailQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {PresenceDetailQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {PresenceDetailQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} PresenceDetailQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} PropertyIndexRequest
 * @property {string} sessionId - Attach properties to a segment in the indicated session
 * @property {string} targetDate - Attach properties to a segment covering a specific point in time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {AnalyticsProperty[]} properties - The list of properties to index
 */
 
/**
 * @typedef {object} QueueObservationQuery
 * @property {QueueObservationQueryFilter} filter - Filter to return a subset of observations. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {string[]} [detailMetrics] - Metrics for which to include additional detailed observations
 */
 
/**
 * @typedef {object} QueueObservationQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {QueueObservationQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} QueueObservationQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {QueueObservationQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {QueueObservationQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} QueueObservationQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} RateLimitAggregateQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {RateLimitAggregateQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} RateLimitAggregateQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {RateLimitAggregateQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {RateLimitAggregateQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} RateLimitAggregateQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} RateLimitAggregationQuery
 * @property {string} interval - Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string} [granularity] - Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
 * @property {string} [timeZone] - Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 * @property {string[]} [groupBy] - Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group.
 * @property {RateLimitAggregateQueryFilter} [filter] - Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {boolean} [flattenMultivaluedDimensions] - Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c')
 * @property {RateLimitAggregationView[]} [views] - Custom derived metric views
 * @property {string} [alternateTimeDimension] - Dimension to use as the alternative timestamp for data in the aggregate.  Choosing "eventTime" uses the actual time of the data event.
 */
 
/**
 * @typedef {object} RateLimitAggregationView
 * @property {string} target - Target metric name
 * @property {string} name - A unique name for this view. Must be distinct from other views and built-in metric names.
 * @property {string} function - Type of view you wish to create
 * @property {AggregationRange} [range] - Range of numbers for slicing up data
 */
 
/**
 * @typedef {object} ReportingExportJobRequest
 * @property {string} name - The user supplied name of the export request
 * @property {string} timeZone - The requested timezone of the exported data. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 * @property {string} exportFormat - The requested format of the exported data
 * @property {string} interval - The time period used to limit the the exported data. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string} period - The Period of the request in which to break down the intervals. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
 * @property {string} viewType - The type of view export job to be created
 * @property {ViewFilter} filter - Filters to apply to create the view
 * @property {boolean} [read] - Indicates if the request has been marked as read
 * @property {string} locale - The locale used for localization of the exported data, i.e. en-US, es
 * @property {boolean} [hasFormatDurations] - Indicates if durations are formatted in hh:mm:ss format instead of ms
 * @property {boolean} [hasSplitFilters] - Indicates if filters will be split in aggregate detail exports
 * @property {boolean} [excludeEmptyRows] - Excludes empty rows from the exports
 * @property {boolean} [hasSplitByMedia] - Indicates if media type will be split in aggregate detail exports
 * @property {boolean} [hasSummaryRow] - Indicates if summary row needs to be present in exports
 * @property {string} [csvDelimiter] - The user supplied csv delimiter string value either of type 'comma' or 'semicolon' permitted for the export request
 * @property {SelectedColumns[]} [selectedColumns] - The list of ordered selected columns from the export view by the user
 * @property {boolean} [hasCustomParticipantAttributes] - Indicates if custom participant attributes will be exported
 * @property {string[]} [recipientEmails] - The list of email recipients for the exports
 * @property {boolean} [includeDurationFormatInHeader] - Indicates whether to include selected duration format to the column headers
 * @property {string} [durationFormat] - Indicates the duration format for the exports
 * @property {ChartColumn[]} [chartColumns] - The list of columns for which chart is going to be displayed in export
 */
 
/**
 * @typedef {object} ResolutionAggregateQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {ResolutionAggregateQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ResolutionAggregateQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {ResolutionAggregateQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {ResolutionAggregateQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ResolutionAggregateQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} ResolutionAggregationQuery
 * @property {string} interval - Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string} [granularity] - Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
 * @property {string} [timeZone] - Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 * @property {string[]} [groupBy] - Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group.
 * @property {ResolutionAggregateQueryFilter} [filter] - Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {boolean} [flattenMultivaluedDimensions] - Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c')
 * @property {ResolutionAggregationView[]} [views] - Custom derived metric views
 * @property {string} [alternateTimeDimension] - Dimension to use as the alternative timestamp for data in the aggregate.  Choosing "eventTime" uses the actual time of the data event and choosing "wrapUpDate" uses the date when conversation is ended
 */
 
/**
 * @typedef {object} ResolutionAggregationView
 * @property {string} target - Target metric name
 * @property {string} name - A unique name for this view. Must be distinct from other views and built-in metric names.
 * @property {string} function - Type of view you wish to create
 * @property {AggregationRange} [range] - Range of numbers for slicing up data
 */
 
/**
 * @typedef {object} ResolutionDetailQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {ResolutionDetailQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ResolutionDetailQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {ResolutionDetailQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {ResolutionDetailQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} ResolutionDetailQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [metric] - Left hand side for metric predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for metric predicates
 * @property {NumericRange} [range] - Right hand side for metric predicates
 */
 
/**
 * @typedef {object} RoutingActivityQuery
 * @property {RoutingActivityQueryMetric[]} metrics - List of requested metrics
 * @property {string[]} groupBy - Dimension(s) to group by
 * @property {RoutingActivityQueryFilter} [filter] - Filter to return a subset of observations. Expresses boolean logical predicates as well as dimensional filters
 * @property {string} [order] - Sort the result set in ascending/descending order. Default is ascending
 */
 
/**
 * @typedef {object} RoutingActivityQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {RoutingActivityQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} RoutingActivityQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {RoutingActivityQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {RoutingActivityQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} RoutingActivityQueryMetric
 * @property {string} metric - The requested metric
 * @property {boolean} [details] - Flag for including observation details for this metric in the response
 */
 
/**
 * @typedef {object} RoutingActivityQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} RoutingStatusDetailQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {RoutingStatusDetailQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} RoutingStatusDetailQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {RoutingStatusDetailQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {RoutingStatusDetailQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} RoutingStatusDetailQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} SegmentDetailQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {SegmentDetailQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} SegmentDetailQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {SegmentDetailQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {SegmentDetailQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} SegmentDetailQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [propertyType] - Left hand side for property predicates
 * @property {string} [property] - Left hand side for property predicates
 * @property {string} [metric] - Left hand side for metric predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension, metric, or property predicates
 * @property {NumericRange} [range] - Right hand side for dimension, metric, or property predicates
 */
 
/**
 * @typedef {object} SelectedColumns
 * @property {number} [columnOrder] - Indicates the order/position of the selected column
 * @property {string} [columnName] - Indicates enum name of the column from the export view
 */
 
/**
 * @typedef {object} SocialKeyword
 * @property {string[]} [includes] - List of keywords that must be included
 * @property {string[]} [excludes] - List of keywords that must be excluded
 */
 
/**
 * @typedef {object} SummaryAggregateQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {SummaryAggregateQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} SummaryAggregateQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {SummaryAggregateQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {SummaryAggregateQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} SummaryAggregateQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} SummaryAggregationQuery
 * @property {string} interval - Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string} [granularity] - Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
 * @property {string} [timeZone] - Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 * @property {string[]} [groupBy] - Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group.
 * @property {SummaryAggregateQueryFilter} [filter] - Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {boolean} [flattenMultivaluedDimensions] - Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c')
 * @property {SummaryAggregationView[]} [views] - Custom derived metric views
 * @property {string} [alternateTimeDimension] - Dimension to use as the alternative timestamp for data in the aggregate.  Choosing "eventTime" uses the actual time of the data event.
 * @property {string} [queryType] - Query type to use. Use groupBy for all matching results, and topN/bottomN for N results ordered by the sortMetric. Default is groupBy.
 * @property {SummaryAggregationSort} [sortMetric] - Required when requesting multiple metrics. Only applicable for topN/bottomN query type.
 * @property {number} [limit] - How many results you want in an ordered list. Only applicable for topN/bottomN query type.
 */
 
/**
 * @typedef {object} SummaryAggregationSort
 * @property {string} name - Name of the metric used for sorting values.
 * @property {string} function - Aggregation function used for the sort metric.
 */
 
/**
 * @typedef {object} SummaryAggregationView
 * @property {string} target - Target metric name
 * @property {string} name - A unique name for this view. Must be distinct from other views and built-in metric names.
 * @property {string} function - Type of view you wish to create
 * @property {AggregationRange} [range] - Range of numbers for slicing up data
 */
 
/**
 * @typedef {object} SurveyAggregateQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {SurveyAggregateQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} SurveyAggregateQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {SurveyAggregateQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {SurveyAggregateQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} SurveyAggregateQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} SurveyAggregationQuery
 * @property {string} interval - Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string} [granularity] - Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
 * @property {string} [timeZone] - Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 * @property {string[]} [groupBy] - Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group.
 * @property {SurveyAggregateQueryFilter} [filter] - Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {boolean} [flattenMultivaluedDimensions] - Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c')
 * @property {SurveyAggregationView[]} [views] - Custom derived metric views
 * @property {string} [alternateTimeDimension] - Dimension to use as the alternative timestamp for data in the aggregate.  Choosing "eventTime" uses the actual time of the data event.
 */
 
/**
 * @typedef {object} SurveyAggregationView
 * @property {string} target - Target metric name
 * @property {string} name - A unique name for this view. Must be distinct from other views and built-in metric names.
 * @property {string} function - Type of view you wish to create
 * @property {AggregationRange} [range] - Range of numbers for slicing up data
 */
 
/**
 * @typedef {object} SurveyDetailQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {SurveyDetailQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} SurveyDetailQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {SurveyDetailQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {SurveyDetailQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} SurveyDetailQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [metric] - Left hand side for metric predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension or metric predicates
 * @property {NumericRange} [range] - Right hand side for dimension or metric predicates
 */
 
/**
 * @typedef {object} TaskManagementAggregateQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {TaskManagementAggregateQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} TaskManagementAggregateQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {TaskManagementAggregateQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {TaskManagementAggregateQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} TaskManagementAggregateQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} TaskManagementAggregationQuery
 * @property {string} interval - Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string} [granularity] - Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
 * @property {string} [timeZone] - Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 * @property {string[]} [groupBy] - Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group.
 * @property {TaskManagementAggregateQueryFilter} [filter] - Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {boolean} [flattenMultivaluedDimensions] - Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c')
 * @property {TaskManagementAggregationView[]} [views] - Custom derived metric views
 * @property {string} [alternateTimeDimension] - Dimension to use as the alternative timestamp for data in the aggregate.  Choosing "eventTime" uses the actual time of the data event.
 */
 
/**
 * @typedef {object} TaskManagementAggregationView
 * @property {string} target - Target metric name
 * @property {string} name - A unique name for this view. Must be distinct from other views and built-in metric names.
 * @property {string} function - Type of view you wish to create
 * @property {AggregationRange} [range] - Range of numbers for slicing up data
 */
 
/**
 * @typedef {object} TeamActivityQuery
 * @property {TeamActivityQueryMetric[]} metrics - List of requested metrics
 * @property {string[]} groupBy - Dimension(s) to group by
 * @property {TeamActivityQueryFilter} [filter] - Filter to return a subset of observations. Expresses boolean logical predicates as well as dimensional filters
 * @property {string} [order] - Sort the result set in ascending/descending order. Default is ascending
 */
 
/**
 * @typedef {object} TeamActivityQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {TeamActivityQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} TeamActivityQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {TeamActivityQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {TeamActivityQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} TeamActivityQueryMetric
 * @property {string} metric - The requested metric
 * @property {boolean} [details] - Flag for including observation details for this metric in the response
 */
 
/**
 * @typedef {object} TeamActivityQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} TranscriptAggregateQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {TranscriptAggregateQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} TranscriptAggregateQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {TranscriptAggregateQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {TranscriptAggregateQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} TranscriptAggregateQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} TranscriptAggregationQuery
 * @property {string} interval - Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string} [granularity] - Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
 * @property {string} [timeZone] - Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 * @property {string[]} [groupBy] - Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group.
 * @property {TranscriptAggregateQueryFilter} [filter] - Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {boolean} [flattenMultivaluedDimensions] - Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c')
 * @property {TranscriptAggregationView[]} [views] - Custom derived metric views
 * @property {string} [alternateTimeDimension] - Dimension to use as the alternative timestamp for data in the aggregate.  Choosing "eventTime" uses the actual time of the data event.
 */
 
/**
 * @typedef {object} TranscriptAggregationView
 * @property {string} target - Target metric name
 * @property {string} name - A unique name for this view. Must be distinct from other views and built-in metric names.
 * @property {string} function - Type of view you wish to create
 * @property {AggregationRange} [range] - Range of numbers for slicing up data
 */
 
/**
 * @typedef {object} Transcripts
 * @property {string[]} [exactMatch] - List of transcript contents which needs to satisfy exact match criteria
 * @property {string[]} [contains] - List of transcript contents which needs to satisfy contains criteria
 * @property {string[]} [doesNotContain] - List of transcript contents which needs to satisfy does not contain criteria
 * @property {string[]} [notSimilarTo] - List of words or phrases used to filter out transcripts that contain content similar to any item in this list
 */
 
/**
 * @typedef {object} TranscriptTopics
 * @property {string[]} [includes] - List of topics which need to be included in exact match criteria. This field is not mutually exclusive with excludes topic list.
 * @property {string[]} [excludes] - List of topics which need to be excluded in exact match criteria. This field is not mutually exclusive with includes topic list.
 */
 
/**
 * @typedef {object} UpdateAnalyticsDataRetentionRequest
 * @property {number} retentionDays - Analytics data retention period in days to set for the organization.
 */
 
/**
 * @typedef {object} UserActivityQuery
 * @property {UserActivityQueryMetric[]} metrics - List of requested metrics
 * @property {string[]} groupBy - Dimension(s) to group by
 * @property {UserActivityQueryFilter} [filter] - Filter to return a subset of observations. Expresses boolean logical predicates as well as dimensional filters
 * @property {string} [order] - Sort the result set in ascending/descending order. Default is ascending
 */
 
/**
 * @typedef {object} UserActivityQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {UserActivityQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} UserActivityQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {UserActivityQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {UserActivityQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} UserActivityQueryMetric
 * @property {string} metric - The requested metric
 * @property {boolean} [details] - Flag for including observation details for this metric in the response
 */
 
/**
 * @typedef {object} UserActivityQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} UserAggregateQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {UserAggregateQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} UserAggregateQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {UserAggregateQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {UserAggregateQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} UserAggregateQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} UserAggregationQuery
 * @property {string} interval - Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string} [granularity] - Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
 * @property {string} [timeZone] - Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 * @property {string[]} [groupBy] - Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group.
 * @property {UserAggregateQueryFilter} [filter] - Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {boolean} [flattenMultivaluedDimensions] - Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c')
 * @property {UserAggregationView[]} [views] - Custom derived metric views
 * @property {string} [alternateTimeDimension] - Dimension to use as the alternative timestamp for data in the aggregate.  Choosing "eventTime" uses the actual time of the data event.
 */
 
/**
 * @typedef {object} UserAggregationView
 * @property {string} target - Target metric name
 * @property {string} name - A unique name for this view. Must be distinct from other views and built-in metric names.
 * @property {string} function - Type of view you wish to create
 * @property {AggregationRange} [range] - Range of numbers for slicing up data
 */
 
/**
 * @typedef {object} UserDetailQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {UserDetailQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} UserDetailQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {UserDetailQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {UserDetailQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} UserDetailQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} UserDetailsQuery
 * @property {string} interval - Specifies the date and time range of data being queried. Conversations MUST have started within this time range to potentially be included within the result set. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {UserDetailQueryFilter[]} [userFilters] - Filters that target the users to retrieve data for
 * @property {PresenceDetailQueryFilter[]} [presenceFilters] - Filters that target system and organization presence-level data
 * @property {RoutingStatusDetailQueryFilter[]} [routingStatusFilters] - Filters that target agent routing status-level data
 * @property {string} [order] - Sort the result set in ascending/descending order. Default is ascending
 * @property {AnalyticsQueryAggregation[]} [presenceAggregations] - Include faceted search and aggregate roll-ups of presence data in your search results. This does not function as a filter, but rather, summary data about the presence results matching your filters
 * @property {AnalyticsQueryAggregation[]} [routingStatusAggregations] - Include faceted search and aggregate roll-ups of agent routing status data in your search results. This does not function as a filter, but rather, summary data about the agent routing status results matching your filters
 * @property {PagingSpec} [paging] - Page size and number to control iterating through large result sets. Default page size is 25
 */
 
/**
 * @typedef {object} UserObservationQuery
 * @property {UserObservationQueryFilter} filter - Filter to return a subset of observations. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {string[]} [detailMetrics] - Metrics for which to include additional detailed observations
 */
 
/**
 * @typedef {object} UserObservationQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {UserObservationQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} UserObservationQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {UserObservationQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {UserObservationQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} UserObservationQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} ViewFilter
 * @property {string[]} [mediaTypes] - The media types are used to filter the view
 * @property {string[]} [queueIds] - The queue ids are used to filter the view
 * @property {string[]} [skillIds] - The skill ids are used to filter the view
 * @property {string[]} [assignedSkillIds] - The assigned user skill ids are used to filter the view
 * @property {string[]} [skillGroups] - The skill groups used to filter the view
 * @property {string[]} [languageIds] - The language ids are used to filter the view
 * @property {string[]} [assignedLanguageIds] - The assigned user language ids are used to filter the view
 * @property {string[]} [languageGroups] - The language groups used to filter the view
 * @property {string[]} [directions] - The directions are used to filter the view
 * @property {string[]} [originatingDirections] - The list of orginating directions used to filter the view
 * @property {string[]} [wrapUpCodes] - The wrap up codes are used to filter the view
 * @property {string[]} [dnisList] - The dnis list is used to filter the view
 * @property {string[]} [sessionDnisList] - The list of session dnis used to filter the view
 * @property {string[]} [filterQueuesByUserIds] - The user ids are used to fetch associated queues for the view
 * @property {string[]} [filterUsersByQueueIds] - The queue ids are used to fetch associated users for the view
 * @property {string[]} [userIds] - The user ids are used to filter the view
 * @property {string[]} [managementUnitIds] - The management unit ids are used to filter the view
 * @property {string[]} [addressTos] - The address To values are used to filter the view
 * @property {string[]} [addressFroms] - The address from values are used to filter the view
 * @property {string[]} [outboundCampaignIds] - The outbound campaign ids are used to filter the view
 * @property {string[]} [outboundContactListIds] - The outbound contact list ids are used to filter the view
 * @property {string[]} [contactIds] - The contact ids are used to filter the view
 * @property {string[]} [externalContactIds] - The external contact ids are used to filter the view
 * @property {string[]} [externalOrgIds] - The external org ids are used to filter the view
 * @property {string[]} [aniList] - The ani list ids are used to filter the view
 * @property {NumericRange[]} [durationsMilliseconds] - The durations in milliseconds used to filter the view
 * @property {NumericRange[]} [acdDurationsMilliseconds] - The acd durations in milliseconds used to filter the view
 * @property {NumericRange[]} [talkDurationsMilliseconds] - The talk durations in milliseconds used to filter the view
 * @property {NumericRange[]} [acwDurationsMilliseconds] - The acw durations in milliseconds used to filter the view
 * @property {NumericRange[]} [handleDurationsMilliseconds] - The handle durations in milliseconds used to filter the view
 * @property {NumericRange[]} [holdDurationsMilliseconds] - The hold durations in milliseconds used to filter the view
 * @property {NumericRange[]} [abandonDurationsMilliseconds] - The abandon durations in milliseconds used to filter the view
 * @property {NumericRange} [evaluationScore] - The evaluationScore is used to filter the view
 * @property {NumericRange} [evaluationCriticalScore] - The evaluationCriticalScore is used to filter the view
 * @property {string[]} [evaluationFormIds] - The evaluation form ids are used to filter the view
 * @property {string[]} [evaluatedAgentIds] - The evaluated agent ids are used to filter the view
 * @property {string[]} [evaluatorIds] - The evaluator ids are used to filter the view
 * @property {boolean} [transferred] - Indicates filtering for transfers
 * @property {boolean} [abandoned] - Indicates filtering for abandons
 * @property {boolean} [answered] - Indicates filtering for answered interactions
 * @property {string[]} [messageTypes] - The message media types used to filter the view
 * @property {string[]} [divisionIds] - The divison Ids used to filter the view
 * @property {string[]} [surveyFormIds] - The survey form ids used to filter the view
 * @property {NumericRange} [surveyTotalScore] - The survey total score used to filter the view
 * @property {NumericRange} [surveyNpsScore] - The survey NPS score used to filter the view
 * @property {NumericRange} [mos] - The desired range for mos values
 * @property {NumericRange} [surveyQuestionGroupScore] - The survey question group score used to filter the view
 * @property {NumericRange} [surveyPromoterScore] - The survey promoter score used to filter the view
 * @property {string[]} [surveyFormContextIds] - The list of survey form context ids used to filter the view
 * @property {string[]} [conversationIds] - The list of conversation ids used to filter the view
 * @property {string[]} [sipCallIds] - The list of SIP call ids used to filter the view
 * @property {boolean} [isEnded] - Indicates filtering for ended
 * @property {boolean} [isSurveyed] - Indicates filtering for survey
 * @property {NumericRange[]} [surveyScores] - The list of survey score ranges used to filter the view
 * @property {NumericRange[]} [promoterScores] - The list of promoter score ranges used to filter the view
 * @property {boolean} [isCampaign] - Indicates filtering for campaign
 * @property {string[]} [surveyStatuses] - The list of survey statuses used to filter the view
 * @property {ConversationProperties} [conversationProperties] - A grouping of conversation level filters
 * @property {boolean} [isBlindTransferred] - Indicates filtering for blind transferred
 * @property {boolean} [isConsulted] - Indicates filtering for consulted
 * @property {boolean} [isConsultTransferred] - Indicates filtering for consult transferred
 * @property {string[]} [remoteParticipants] - The list of remote participants used to filter the view
 * @property {string[]} [flowIds] - The list of flow Ids
 * @property {string[]} [flowOutcomeIds] - A list of outcome ids of the flow
 * @property {string[]} [flowOutcomeValues] - A list of outcome values of the flow
 * @property {string[]} [flowDestinationTypes] - The list of destination types of the flow
 * @property {string[]} [flowDisconnectReasons] - The list of reasons for the flow to disconnect
 * @property {string[]} [flowTypes] - A list of types of the flow
 * @property {string[]} [flowEntryTypes] - A list of types of the flow entry
 * @property {string[]} [flowEntryReasons] - A list of reasons of flow entry
 * @property {string[]} [flowVersions] - A list of versions of a flow
 * @property {string[]} [groupIds] - A list of directory group ids
 * @property {boolean} [hasJourneyCustomerId] - Indicates filtering for journey customer id
 * @property {boolean} [hasJourneyActionMapId] - Indicates filtering for Journey action map id
 * @property {boolean} [hasJourneyVisitId] - Indicates filtering for Journey visit id
 * @property {boolean} [hasMedia] - Indicates filtering for presence of MMS media
 * @property {string[]} [roleIds] - The role Ids used to filter the view
 * @property {string[]} [reportsTos] - The report to user IDs used to filter the view
 * @property {string[]} [locationIds] - The location Ids used to filter the view
 * @property {string[]} [flowOutTypes] - A list of flow out types
 * @property {string[]} [providerList] - A list of providers
 * @property {string[]} [callbackNumberList] - A list of callback numbers or substrings of numbers (ex: ["317", "13172222222"])
 * @property {string} [callbackInterval] - An interval of time to filter for scheduled callbacks. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string[]} [usedRoutingTypes] - A list of routing types used
 * @property {string[]} [requestedRoutingTypes] - A list of routing types requested
 * @property {boolean} [hasAgentAssistId] - Indicates filtering for agent assist id
 * @property {Transcripts[]} [transcripts] - A list of transcript contents requested
 * @property {string[]} [transcriptLanguages] - A list of transcript languages requested
 * @property {string[]} [participantPurposes] - A list of participant purpose requested
 * @property {boolean} [showFirstQueue] - Indicates filtering for first queue data
 * @property {string[]} [teamIds] - The team ids used to filter the view data
 * @property {string[]} [filterUsersByTeamIds] - The team ids are used to fetch associated users for the view
 * @property {string[]} [journeyActionMapIds] - The journey action map ids are used to fetch action maps for the associated view
 * @property {string[]} [journeyOutcomeIds] - The journey outcome ids are used to fetch outcomes for the associated view
 * @property {string[]} [journeySegmentIds] - The journey segment ids are used to fetch segments for the associated view
 * @property {string[]} [journeyActionMapTypes] - The journey action map types are used to filter action map data for the associated view
 * @property {string[]} [developmentRoleList] - The list of development roles used to filter agent development view
 * @property {string[]} [developmentTypeList] - The list of development types used to filter agent development view
 * @property {string[]} [developmentStatusList] - The list of development status used to filter agent development view
 * @property {string[]} [developmentModuleIds] - The list of development moduleIds used to filter agent development view
 * @property {boolean} [developmentActivityOverdue] - Indicates filtering for development activities
 * @property {NumericRange} [customerSentimentScore] - The customer sentiment score used to filter the view
 * @property {NumericRange} [customerSentimentTrend] - The customer sentiment trend used to filter the view
 * @property {string[]} [flowTransferTargets] - The list of transfer targets used to filter flow data
 * @property {string} [developmentName] - Filter for development name
 * @property {string[]} [topicIds] - Represents the topics detected in the transcript
 * @property {string[]} [externalTags] - The list of external Tags used to filter conversation data
 * @property {boolean} [isNotResponding] - Indicates filtering for not responding users
 * @property {boolean} [isAuthenticated] - Indicates filtering for the authenticated chat
 * @property {string[]} [botIds] - The list of bot IDs used to filter bot views
 * @property {string[]} [botVersions] - The list of bot versions used to filter bot views
 * @property {string[]} [botMessageTypes] - The list of bot message types used to filter bot views
 * @property {string[]} [botProviderList] - The list of bot providers used to filter bot views
 * @property {string[]} [botProductList] - The list of bot products used to filter bot views
 * @property {string[]} [botRecognitionFailureReasonList] - The list of bot recognition failure reasons used to filter bot views
 * @property {string[]} [botIntentList] - The list of bot intents used to filter bot views
 * @property {string[]} [botFinalIntentList] - The list of bot final intents used to filter bot views
 * @property {string[]} [botSlotList] - The list of bot slots used to filter bot views
 * @property {string[]} [botResultList] - The list of bot results used to filter bot views
 * @property {string[]} [blockedReasons] - The list of blocked reason used to filter action map constraints views
 * @property {boolean} [isRecorded] - Indicates filtering for recorded
 * @property {boolean} [hasEvaluation] - Indicates filtering for evaluation
 * @property {boolean} [hasScoredEvaluation] - Indicates filtering for scored evaluation
 * @property {string[]} [emailDeliveryStatusList] - The list of email delivery statuses used to filter views
 * @property {boolean} [isAgentOwnedCallback] - Indicates filtering for agent owned callback interactions
 * @property {string[]} [agentCallbackOwnerIds] - The list of callback owners used to filter interactions
 * @property {TranscriptTopics[]} [transcriptTopics] - The list of transcript topics requested in filter
 * @property {string[]} [journeyFrequencyCapReasons] - The list of frequency cap reasons to filter offer constraints
 * @property {string[]} [journeyBlockingActionMapIds] - The list of blocking action maps to filter offer constraints
 * @property {string[]} [journeyActionTargetIds] - The list of action targets to filter offer constraints
 * @property {string[]} [journeyBlockingScheduleGroupIds] - The list of blocking schedule groups to filter offer constraints
 * @property {string[]} [journeyBlockingEmergencyScheduleGroupIds] - The list of emergency schedule groups to filter offer constraints
 * @property {string[]} [journeyUrlEqualConditions] - The list of url equal conditions to filter offer constraints
 * @property {string[]} [journeyUrlNotEqualConditions] - The list of url not equal conditions to filter offer constraints
 * @property {string[]} [journeyUrlStartsWithConditions] - The list of url starts with conditions to filter offer constraints
 * @property {string[]} [journeyUrlEndsWithConditions] - The list of url ends with conditions to filter offer constraints
 * @property {string[]} [journeyUrlContainsAnyConditions] - The list of url contains any conditions to filter offer constraints
 * @property {string[]} [journeyUrlNotContainsAnyConditions] - The list of url not contains any conditions to filter offer constraints
 * @property {string[]} [journeyUrlContainsAllConditions] - The list of url contains all conditions to filter offer constraints
 * @property {string[]} [journeyUrlNotContainsAllConditions] - The list of url not contains all conditions to filter offer constraints
 * @property {string[]} [flowMilestoneIds] - The list of flow milestones to filter exports
 * @property {boolean} [isAssessmentPassed] - Filter to indicate if Agent passed assessment or not
 * @property {string[]} [conversationInitiators] - The list to filter based on Brands (Bot/User/Agent) or End User who initiated the first message in the conversation
 * @property {boolean} [hasCustomerParticipated] - Indicates if the customer has participated in an initiated conversation
 * @property {boolean} [isAcdInteraction] - Filter to indicate if interaction was ACD or non-ACD
 * @property {boolean} [hasFax] - Filters to indicate if interaction has FAX
 * @property {string[]} [dataActionIds] - The list of Data Action IDs 
 * @property {string} [actionCategoryName] - Deprecated - Please use integrationIds instead
 * @property {string[]} [integrationIds] - The list of integration IDs for Data Action
 * @property {string[]} [responseStatuses] - The list of Response codes for Data Action
 * @property {string} [availableDashboard] - Filter to indicate the availability of the dashboard is public or private.
 * @property {boolean} [favouriteDashboard] - Filter to indicate whether the dashboard is favorite or unfavorite.
 * @property {boolean} [myDashboard] - Filter to indicate the dashboard owned by the user.
 * @property {string[]} [stationErrors] - The list of agent errors that are related to station
 * @property {string[]} [canonicalContactIds] - The canonical contact ids are used to filter the view
 * @property {string[]} [alertRuleIds] - The list of Alert Rule IDs
 * @property {string[]} [evaluationFormContextIds] - The list of Evaluation Form Context IDs
 * @property {string[]} [evaluationStatuses] - The evaluation statuses that are used to filter the view
 * @property {string[]} [workbinIds] - The list of Workbin IDs
 * @property {string[]} [worktypeIds] - The list of Worktype IDs
 * @property {string[]} [workitemIds] - The list of Workitem IDs
 * @property {string[]} [workitemAssigneeIds] - The list of Workitem Assignee IDs
 * @property {string[]} [workitemStatuses] - The list of Workitem Statuses IDs
 * @property {boolean} [isAnalyzedForSensitiveData] - Deprecated - Use hasPciData or hasPiiData instead.
 * @property {boolean} [hasSensitiveData] - Deprecated. Use hasPciData or hasPiiData instead.
 * @property {boolean} [hasPciData] - Filter to indicate the transcript contains Pci data.
 * @property {boolean} [hasPiiData] - Filter to indicate the transcript contains Pii data.
 * @property {string} [subPath] - Filter for Sub Path
 * @property {string} [userState] - The user supplied state value in the view
 * @property {boolean} [isClearedByCustomer] - Filter to indicate if the customer cleared the conversation.
 * @property {string[]} [evaluationAssigneeIds] - The evaluation assignee ids that are used to filter the view.
 * @property {boolean} [evaluationAssigned] - Filter to indicate that the user has no assigned evaluation.
 * @property {string[]} [assistantIds] - The assistant ids that are used to filter the view.
 * @property {string[]} [knowledgeBaseIds] - The knowledge base ids that are used to filter the view.
 * @property {boolean} [isParked] - Filter to indicate if the interactions are parked.
 * @property {NumericRange} [agentEmpathyScore] - The agentEmpathyScore is used to filter the view
 * @property {string[]} [surveyTypes] - The surveyTypes is used to filter the view
 * @property {string[]} [surveyResponseStatuses] - The list of Survey Response Status
 * @property {string[]} [botFlowTypes] - The botFlowTypes is used to filter the view
 * @property {NumericRange[]} [agentTalkDurationMilliseconds] - The agent talk durations in milliseconds used to filter the view
 * @property {NumericRange[]} [customerTalkDurationMilliseconds] - The customer talk durations in milliseconds used to filter the view
 * @property {NumericRange[]} [overtalkDurationMilliseconds] - The overtalk durations in milliseconds used to filter the view
 * @property {NumericRange[]} [silenceDurationMilliseconds] - The silence durations in milliseconds used to filter the view
 * @property {NumericRange[]} [acdDurationMilliseconds] - The acd durations in milliseconds used to filter the view
 * @property {NumericRange[]} [ivrDurationMilliseconds] - The ivr durations in milliseconds used to filter the view
 * @property {NumericRange[]} [otherDurationMilliseconds] - The other (hold/music) durations in milliseconds used to filter the view
 * @property {NumericRange} [agentTalkPercentage] - The agent talk percentage used to filter the view
 * @property {NumericRange} [customerTalkPercentage] - The customer talk percentage used to filter the view
 * @property {NumericRange} [overtalkPercentage] - The overtalk percentage used to filter the view
 * @property {NumericRange} [silencePercentage] - The silence percentage used to filter the view
 * @property {NumericRange} [acdPercentage] - The acd percentage used to filter the view
 * @property {NumericRange} [ivrPercentage] - The ivr percentage used to filter the view
 * @property {NumericRange} [otherPercentage] - The other (hold/music percentage used to filter the view
 * @property {NumericRange} [overtalkInstances] - The overtalk instance range used to filter the view
 * @property {boolean} [isScreenRecorded] - Filter to indicate if the screen is recorded
 * @property {string[]} [screenMonitorUserIds] - The list of Screen Monitor User Ids
 * @property {string} [dashboardState] - The state of dashboard being filtered
 * @property {string} [dashboardType] - The type of dashboard being filtered
 * @property {string} [dashboardAccessFilter] - The type of dashboard access being filtered
 * @property {NumericRange[]} [transcriptDurationMilliseconds] - The transcript durations in milliseconds used to filter the view
 * @property {WorkitemStatusFilter[]} [workitemsStatuses] - The list of workitem status with worktype
 * @property {string[]} [socialCountries] - List of countries for social filtering
 * @property {string[]} [socialLanguages] - List of languages for social filtering
 * @property {string[]} [socialChannels] - List of channels for social filtering
 * @property {string[]} [socialSentimentCategory] - The sentiment of the social post
 * @property {string[]} [socialTopicIds] - The list of topicIds for social filtering
 * @property {string[]} [socialIngestionRuleIds] - The list of ingestion ruleIds for social filtering
 * @property {boolean} [socialConversationCreated] - Filter to indicate if the post has created a conversation
 * @property {string[]} [socialContentType] - The list of content Type for social filtering
 * @property {SocialKeyword[]} [socialKeywords] - The list of keywords for social filtering
 * @property {boolean} [socialPostEscalated] - Filter to indicate if the post is escalated
 * @property {string[]} [socialClassifications] - Indicates if a social message was public or private
 * @property {string[]} [filterUsersByManagerIds] - The manager ids used to fetch associated users for the view
 * @property {string[]} [slideshowIds] - List of Dashboard slideshowIds to be filtered
 * @property {boolean} [conferenced] - Filter to indicate if the conversation has conference
 * @property {boolean} [video] - Filter to indicate if the conversation has video
 * @property {boolean} [linkedInteraction] - Filter to indicate if the conversation has linked interaction
 * @property {string[]} [recommendationSources] - List of recommendation sources for filtering recommendation details pane
 * @property {string} [evaluationRole] - Sets the role when viewing agent evaluations
 * @property {string[]} [comparisonQueueIds] - The queue ids are used to for comparison to the primary queue filter in reporting
 * @property {string[]} [viewMetrics] - A list of metrics selected for the view
 * @property {string[]} [timelineCategories] - A list of timeline categories
 * @property {boolean} [acw] - Filter to indicate for acw state
 * @property {string[]} [segmentTypes] - A list of filtered segment types
 * @property {string[]} [programIds] - A list of program ids for filtering
 * @property {string[]} [categoryIds] - A list of category ids for filtering
 * @property {boolean} [deliveryPushed] - Filter to indicate if push notification is sent
 * @property {number[]} [socialRatings] - A set of ratings for Google Business Profile
 * @property {string[]} [virtualAgentIds] - A list of virtual agent ids for filtering.
 * @property {string[]} [empathyScoreCategories] - A set of Empathy Score Categories for filtering
 * @property {string[]} [sentimentScoreCategories] - A set of Sentiment Score Categories  for filtering
 * @property {string[]} [sentimentTrendCategories] - A set of Sentiment Trend Categories for filtering
 * @property {string[]} [contentModerationFlags] - A set of Content Moderation Flags for filtering
 * @property {boolean} [sessionExpired] - Filter to indicate for if session is expired
 * @property {string[]} [engagementSource] - The engagement sources used to filter the view
 */
 
/**
 * @typedef {object} WorkitemStatusFilter
 * @property {string} [worktypeId] - Worktype ID belonging to the selected workitem status
 * @property {string} [workitemStatusId] - Workitem status ID
 */
 

/**
 * Analytics - Analytics querying and reporting.
 * @class Analytics
 */
class AnalyticsAPI {
	// Private instance properties
	#gcPlatformAPIClient = null;

	/**
	 * Constructor for the Analytics class
	 * @constructor
	 * @param {GCPlatformAPIClient} gcPlatformAPIClient - The Genesys Cloud Platform API client instance.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_INSTANCE_TYPE_INVALID} If the Genesys Cloud Platform API client instance argument is not an object.
	 */
	constructor(gcPlatformAPIClient) {
		// Check the Genesys Cloud Platform API client instance argument
		if (typeof gcPlatformAPIClient !== "object" || symbols.GCPlatformAPIClient in gcPlatformAPIClient === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_INSTANCE_TYPE_INVALID();
		}

		// Initialize the instance properties
		this.#gcPlatformAPIClient = gcPlatformAPIClient;
	}

	/**
	 * Query for action aggregates
	 * @async
	 * @param {ActionAggregationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/actions/aggregates/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsActionsAggregatesQuery(body) {
		const endpointPath = "/api/v2/analytics/actions/aggregates/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for agent copilot aggregates
	 * @async
	 * @param {AgentCopilotAggregationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/agentcopilots/aggregates/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsAgentcopilotsAggregatesQuery(body) {
		const endpointPath = "/api/v2/analytics/agentcopilots/aggregates/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get an agent and their active sessions by user ID
	 * @async
	 * @param {string} userId - userId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/agents/{userId}/status" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getAnalyticsAgentStatus(userId) {
		const endpointPath = "/api/v2/analytics/agents/{userId}/status";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Count agents by different groupings
	 * @async
	 * @param {AgentStateCountsRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/agents/status/counts" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsAgentsStatusCounts(body) {
		const endpointPath = "/api/v2/analytics/agents/status/counts";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Retrieve the top 50 agents matching the query filters
	 * @async
	 * @param {AgentStateQueryRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/agents/status/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsAgentsStatusQuery(body) {
		const endpointPath = "/api/v2/analytics/agents/status/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for bot aggregates
	 * @async
	 * @param {BotAggregationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/bots/aggregates/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsBotsAggregatesQuery(body) {
		const endpointPath = "/api/v2/analytics/bots/aggregates/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for conversation aggregates
	 * @async
	 * @param {ConversationAggregationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/conversations/aggregates/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsConversationsAggregatesQuery(body) {
		const endpointPath = "/api/v2/analytics/conversations/aggregates/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for conversation activity observations
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  The desired page size
	 * @param {number} [query.pageNumber] -  The desired page number
	 * @param {ConversationActivityQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/conversations/activity/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsConversationsActivityQuery(query, body) {
		const endpointPath = "/api/v2/analytics/conversations/activity/query";
		const endpointMethod = "POST";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for conversation details
	 * @async
	 * @param {ConversationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/conversations/details/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsConversationsDetailsQuery(body) {
		const endpointPath = "/api/v2/analytics/conversations/details/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a conversation by id
	 * @async
	 * @param {string} conversationId - conversationId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/conversations/{conversationId}/details" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getAnalyticsConversationDetails(conversationId) {
		const endpointPath = "/api/v2/analytics/conversations/{conversationId}/details";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Gets multiple conversations by id
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string[]} [query.id] -  Comma-separated conversation ids
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/conversations/details" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getAnalyticsConversationsDetails(query) {
		const endpointPath = "/api/v2/analytics/conversations/details";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("id" in query && this.#checkJSONSchemaType(query["id"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "id", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Index conversation properties
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {PropertyIndexRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/conversations/{conversationId}/details/properties" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsConversationDetailsProperties(conversationId, body) {
		const endpointPath = "/api/v2/analytics/conversations/{conversationId}/details/properties";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for conversation details asynchronously
	 * @async
	 * @param {AsyncConversationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/conversations/details/jobs" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsConversationsDetailsJobs(body) {
		const endpointPath = "/api/v2/analytics/conversations/details/jobs";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get status for async query for conversation details
	 * @async
	 * @param {string} jobId - jobId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/conversations/details/jobs/{jobId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getAnalyticsConversationsDetailsJob(jobId) {
		const endpointPath = "/api/v2/analytics/conversations/details/jobs/{jobId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(jobId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "jobId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.jobId = jobId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete/cancel an async details job
	 * @async
	 * @param {string} jobId - jobId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/conversations/details/jobs/{jobId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteAnalyticsConversationsDetailsJob(jobId) {
		const endpointPath = "/api/v2/analytics/conversations/details/jobs/{jobId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(jobId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "jobId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.jobId = jobId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Fetch a page of results for an async details job
	 * @async
	 * @param {string} jobId - jobId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.cursor] -  Indicates where to resume query results (not required for first page)
	 * @param {number} [query.pageSize] -  The desired maximum number of results
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/conversations/details/jobs/{jobId}/results" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getAnalyticsConversationsDetailsJobResults(jobId, query) {
		const endpointPath = "/api/v2/analytics/conversations/details/jobs/{jobId}/results";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(jobId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "jobId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("cursor" in query && this.#checkJSONSchemaType(query["cursor"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "cursor", "string");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.jobId = jobId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Lookup the datalake availability date and time
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/conversations/details/jobs/availability" endpoint.
	 */
	getAnalyticsConversationsDetailsJobsAvailability() {
		const endpointPath = "/api/v2/analytics/conversations/details/jobs/availability";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for evaluation aggregates
	 * @async
	 * @param {EvaluationAggregationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/evaluations/aggregates/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsEvaluationsAggregatesQuery(body) {
		const endpointPath = "/api/v2/analytics/evaluations/aggregates/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for flow execution aggregates
	 * @async
	 * @param {FlowExecutionAggregationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/flowexecutions/aggregates/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsFlowexecutionsAggregatesQuery(body) {
		const endpointPath = "/api/v2/analytics/flowexecutions/aggregates/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for flow observations
	 * @async
	 * @param {FlowObservationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/flows/observations/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsFlowsObservationsQuery(body) {
		const endpointPath = "/api/v2/analytics/flows/observations/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for flow activity observations
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  The desired page size
	 * @param {number} [query.pageNumber] -  The desired page number
	 * @param {FlowActivityQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/flows/activity/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsFlowsActivityQuery(query, body) {
		const endpointPath = "/api/v2/analytics/flows/activity/query";
		const endpointMethod = "POST";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for flow aggregates
	 * @async
	 * @param {FlowAggregationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/flows/aggregates/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsFlowsAggregatesQuery(body) {
		const endpointPath = "/api/v2/analytics/flows/aggregates/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for journey aggregates
	 * @async
	 * @param {JourneyAggregationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/journeys/aggregates/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsJourneysAggregatesQuery(body) {
		const endpointPath = "/api/v2/analytics/journeys/aggregates/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for knowledge aggregates
	 * @async
	 * @param {KnowledgeAggregationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/knowledge/aggregates/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsKnowledgeAggregatesQuery(body) {
		const endpointPath = "/api/v2/analytics/knowledge/aggregates/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for queue observations
	 * @async
	 * @param {QueueObservationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/queues/observations/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsQueuesObservationsQuery(body) {
		const endpointPath = "/api/v2/analytics/queues/observations/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for limits rate limit aggregates. Data populated when limits reach 90% of the maximum. Not a source of truth for limits hit but a best effort estimate.
	 * @async
	 * @param {RateLimitAggregationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/ratelimits/aggregates/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsRatelimitsAggregatesQuery(body) {
		const endpointPath = "/api/v2/analytics/ratelimits/aggregates/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for resolution aggregates
	 * @async
	 * @param {ResolutionAggregationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/resolutions/aggregates/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsResolutionsAggregatesQuery(body) {
		const endpointPath = "/api/v2/analytics/resolutions/aggregates/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for user activity observations
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  The desired page size
	 * @param {number} [query.pageNumber] -  The desired page number
	 * @param {RoutingActivityQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/routing/activity/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsRoutingActivityQuery(query, body) {
		const endpointPath = "/api/v2/analytics/routing/activity/query";
		const endpointMethod = "POST";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for summary aggregates
	 * @async
	 * @param {SummaryAggregationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/summaries/aggregates/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsSummariesAggregatesQuery(body) {
		const endpointPath = "/api/v2/analytics/summaries/aggregates/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for survey aggregates
	 * @async
	 * @param {SurveyAggregationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/surveys/aggregates/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsSurveysAggregatesQuery(body) {
		const endpointPath = "/api/v2/analytics/surveys/aggregates/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for task management aggregates
	 * @async
	 * @param {TaskManagementAggregationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/taskmanagement/aggregates/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsTaskmanagementAggregatesQuery(body) {
		const endpointPath = "/api/v2/analytics/taskmanagement/aggregates/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for team activity observations
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  The desired page size
	 * @param {number} [query.pageNumber] -  The desired page number
	 * @param {TeamActivityQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/teams/activity/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsTeamsActivityQuery(query, body) {
		const endpointPath = "/api/v2/analytics/teams/activity/query";
		const endpointMethod = "POST";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for transcript aggregates
	 * @async
	 * @param {TranscriptAggregationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/transcripts/aggregates/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsTranscriptsAggregatesQuery(body) {
		const endpointPath = "/api/v2/analytics/transcripts/aggregates/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for user aggregates
	 * @async
	 * @param {UserAggregationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/users/aggregates/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsUsersAggregatesQuery(body) {
		const endpointPath = "/api/v2/analytics/users/aggregates/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for user details
	 * @async
	 * @param {UserDetailsQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/users/details/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsUsersDetailsQuery(body) {
		const endpointPath = "/api/v2/analytics/users/details/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for user observations
	 * @async
	 * @param {UserObservationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/users/observations/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsUsersObservationsQuery(body) {
		const endpointPath = "/api/v2/analytics/users/observations/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for user activity observations
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  The desired page size
	 * @param {number} [query.pageNumber] -  The desired page number
	 * @param {UserActivityQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/users/activity/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsUsersActivityQuery(query, body) {
		const endpointPath = "/api/v2/analytics/users/activity/query";
		const endpointMethod = "POST";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for user details asynchronously
	 * @async
	 * @param {AsyncUserDetailsQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/users/details/jobs" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsUsersDetailsJobs(body) {
		const endpointPath = "/api/v2/analytics/users/details/jobs";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get status for async query for user details
	 * @async
	 * @param {string} jobId - jobId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/users/details/jobs/{jobId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getAnalyticsUsersDetailsJob(jobId) {
		const endpointPath = "/api/v2/analytics/users/details/jobs/{jobId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(jobId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "jobId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.jobId = jobId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete/cancel an async request
	 * @async
	 * @param {string} jobId - jobId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/users/details/jobs/{jobId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteAnalyticsUsersDetailsJob(jobId) {
		const endpointPath = "/api/v2/analytics/users/details/jobs/{jobId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(jobId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "jobId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.jobId = jobId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Fetch a page of results for an async query
	 * @async
	 * @param {string} jobId - jobId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.cursor] -  Indicates where to resume query results (not required for first page)
	 * @param {number} [query.pageSize] -  The desired maximum number of results
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/users/details/jobs/{jobId}/results" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getAnalyticsUsersDetailsJobResults(jobId, query) {
		const endpointPath = "/api/v2/analytics/users/details/jobs/{jobId}/results";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(jobId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "jobId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("cursor" in query && this.#checkJSONSchemaType(query["cursor"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "cursor", "string");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.jobId = jobId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Lookup the datalake availability date and time
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/users/details/jobs/availability" endpoint.
	 */
	getAnalyticsUsersDetailsJobsAvailability() {
		const endpointPath = "/api/v2/analytics/users/details/jobs/availability";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get Reporting Turns (division aware).
	 * @async
	 * @param {string} botFlowId - ID of the bot flow.
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.after] -  The cursor that points to the ID of the last item in the list of entities that has been returned.
	 * @param {string} [query.pageSize] -  Max number of entities to return. Maximum of 250
	 * @param {string} [query.interval] -  Date range filter based on the date the individual resources were completed. UTC is the default if no TZ is supplied, however alternate timezones can be used e.g: '2022-11-22T09:11:11.111+08:00/2022-11-30T07:17:44.586-07'. . Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
	 * @param {string} [query.actionId] -  Optional action ID to get the reporting turns associated to a particular flow action
	 * @param {string} [query.sessionId] -  Optional session ID to get the reporting turns for a particular session. Specifying a session ID alongside an action ID or a language or any ask action results is not allowed.
	 * @param {string} [query.language] -  Optional language code to get the reporting turns for a particular language
	 * @param {string} [query.askActionResults] -  Optional case-insensitive comma separated list of ask action results to filter the reporting turns.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/botflows/{botFlowId}/divisions/reportingturns" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getAnalyticsBotflowDivisionsReportingturns(botFlowId, query) {
		const endpointPath = "/api/v2/analytics/botflows/{botFlowId}/divisions/reportingturns";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(botFlowId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "botFlowId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("after" in query && this.#checkJSONSchemaType(query["after"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "after", "string");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "string");
			}
			if ("interval" in query && this.#checkJSONSchemaType(query["interval"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "interval", "string");
			}
			if ("actionId" in query && this.#checkJSONSchemaType(query["actionId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "actionId", "string");
			}
			if ("sessionId" in query && this.#checkJSONSchemaType(query["sessionId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sessionId", "string");
			}
			if ("language" in query && this.#checkJSONSchemaType(query["language"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "language", "string");
			}
			if ("askActionResults" in query && this.#checkJSONSchemaType(query["askActionResults"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "askActionResults", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.botFlowId = botFlowId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get Reporting Turns.
	 * @async
	 * @param {string} botFlowId - ID of the bot flow.
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.after] -  The cursor that points to the ID of the last item in the list of entities that has been returned.
	 * @param {string} [query.pageSize] -  Max number of entities to return. Maximum of 250
	 * @param {string} [query.interval] -  Date range filter based on the date the individual resources were completed. UTC is the default if no TZ is supplied, however alternate timezones can be used e.g: '2022-11-22T09:11:11.111+08:00/2022-11-30T07:17:44.586-07'. . Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
	 * @param {string} [query.actionId] -  Optional action ID to get the reporting turns associated to a particular flow action
	 * @param {string} [query.sessionId] -  Optional session ID to get the reporting turns for a particular session. Specifying a session ID alongside an action ID or a language or any ask action results is not allowed.
	 * @param {string} [query.language] -  Optional language code to get the reporting turns for a particular language
	 * @param {string} [query.askActionResults] -  Optional case-insensitive comma separated list of ask action results to filter the reporting turns.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/botflows/{botFlowId}/reportingturns" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @deprecated
	 */
	getAnalyticsBotflowReportingturns(botFlowId, query) {
		const endpointPath = "/api/v2/analytics/botflows/{botFlowId}/reportingturns";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(botFlowId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "botFlowId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("after" in query && this.#checkJSONSchemaType(query["after"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "after", "string");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "string");
			}
			if ("interval" in query && this.#checkJSONSchemaType(query["interval"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "interval", "string");
			}
			if ("actionId" in query && this.#checkJSONSchemaType(query["actionId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "actionId", "string");
			}
			if ("sessionId" in query && this.#checkJSONSchemaType(query["sessionId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sessionId", "string");
			}
			if ("language" in query && this.#checkJSONSchemaType(query["language"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "language", "string");
			}
			if ("askActionResults" in query && this.#checkJSONSchemaType(query["askActionResults"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "askActionResults", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.botFlowId = botFlowId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get Bot Flow Sessions.
	 * @async
	 * @param {string} botFlowId - ID of the bot flow.
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.after] -  The cursor that points to the ID of the last item in the list of entities that has been returned.
	 * @param {string} [query.pageSize] -  Max number of entities to return. Maximum of 250
	 * @param {string} [query.interval] -  Date range filter based on the date the individual resources were completed. UTC is the default if no TZ is supplied, however alternate timezones can be used e.g: '2022-11-22T09:11:11.111+08:00/2022-11-30T07:17:44.586-07'. . Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
	 * @param {string} [query.botResultCategories] -  Optional case-insensitive comma separated list of Bot Result Categories to filter sessions by.
	 * @param {string} [query.endLanguage] -  Optional case-insensitive language code to filter sessions by the language the sessions ended in.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/botflows/{botFlowId}/sessions" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getAnalyticsBotflowSessions(botFlowId, query) {
		const endpointPath = "/api/v2/analytics/botflows/{botFlowId}/sessions";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(botFlowId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "botFlowId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("after" in query && this.#checkJSONSchemaType(query["after"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "after", "string");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "string");
			}
			if ("interval" in query && this.#checkJSONSchemaType(query["interval"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "interval", "string");
			}
			if ("botResultCategories" in query && this.#checkJSONSchemaType(query["botResultCategories"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "botResultCategories", "string");
			}
			if ("endLanguage" in query && this.#checkJSONSchemaType(query["endLanguage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "endLanguage", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.botFlowId = botFlowId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get analytics data retention setting
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/dataretention/settings" endpoint.
	 */
	getAnalyticsDataretentionSettings() {
		const endpointPath = "/api/v2/analytics/dataretention/settings";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update analytics data retention setting
	 * @async
	 * @param {UpdateAnalyticsDataRetentionRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/dataretention/settings" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putAnalyticsDataretentionSettings(body) {
		const endpointPath = "/api/v2/analytics/dataretention/settings";
		const endpointMethod = "PUT";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get AnalyticsReportingSettings for an organization
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/reporting/settings" endpoint.
	 */
	getAnalyticsReportingSettings() {
		const endpointPath = "/api/v2/analytics/reporting/settings";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Patch AnalyticsReportingSettings values for an organization
	 * @async
	 * @param {AnalyticsReportingSettings} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/reporting/settings" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchAnalyticsReportingSettings(body) {
		const endpointPath = "/api/v2/analytics/reporting/settings";
		const endpointMethod = "PATCH";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Bulk soft delete dashboard configurations
	 * @async
	 * @param {DashboardConfigurationBulkRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/reporting/settings/dashboards/bulk/remove" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsReportingSettingsDashboardsBulkRemove(body) {
		const endpointPath = "/api/v2/analytics/reporting/settings/dashboards/bulk/remove";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get list of dashboard configurations
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.name] -  name of the dashboard
	 * @param {string} query.dashboardType -  List dashboard of given type
	 * @param {string} [query.dashboardState] -  List dashboard of given state
	 * @param {string} query.dashboardAccessFilter -  Filter dashboard based on the owner of dashboard
	 * @param {string} [query.sortBy] -  
	 * @param {number} [query.pageNumber] -  
	 * @param {number} [query.pageSize] -  
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/reporting/settings/dashboards/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING} If a required query string parameter is missing.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getAnalyticsReportingSettingsDashboardsQuery(query) {
		const endpointPath = "/api/v2/analytics/reporting/settings/dashboards/query";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object" || query === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, true);
		}

		if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
		}

		if ("dashboardType" in query === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING(endpointPath, endpointMethod, "dashboardType");
		}

		if (this.#checkJSONSchemaType(query["dashboardType"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "dashboardType", "string");
		}

		if ("dashboardState" in query && this.#checkJSONSchemaType(query["dashboardState"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "dashboardState", "string");
		}

		if ("dashboardAccessFilter" in query === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING(endpointPath, endpointMethod, "dashboardAccessFilter");
		}

		if (this.#checkJSONSchemaType(query["dashboardAccessFilter"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "dashboardAccessFilter", "string");
		}

		if ("sortBy" in query && this.#checkJSONSchemaType(query["sortBy"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortBy", "string");
		}

		if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
		}

		if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query dashboard configurations
	 * @async
	 * @param {DashboardConfigurationQueryRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/reporting/settings/dashboards/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsReportingSettingsDashboardsQuery(body) {
		const endpointPath = "/api/v2/analytics/reporting/settings/dashboards/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get dashboards summary for a user
	 * @async
	 * @param {string} userId - User ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/reporting/dashboards/users/{userId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getAnalyticsReportingDashboardsUser(userId) {
		const endpointPath = "/api/v2/analytics/reporting/dashboards/users/{userId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get dashboards summary for users in a org
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.sortBy] -  
	 * @param {number} [query.pageNumber] -  
	 * @param {number} [query.pageSize] -  
	 * @param {string[]} [query.id] -  A list of user IDs to fetch by bulk
	 * @param {string} [query.state] -  Only list users of this state
	 * @param {boolean} [query.deletedOnly] -  Only list users with deleted dashboards
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/reporting/dashboards/users" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getAnalyticsReportingDashboardsUsers(query) {
		const endpointPath = "/api/v2/analytics/reporting/dashboards/users";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("sortBy" in query && this.#checkJSONSchemaType(query["sortBy"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortBy", "string");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("id" in query && this.#checkJSONSchemaType(query["id"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "id", "array");
			}
			if ("state" in query && this.#checkJSONSchemaType(query["state"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "state", "string");
			}
			if ("deletedOnly" in query && this.#checkJSONSchemaType(query["deletedOnly"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "deletedOnly", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Bulk soft delete dashboards owned by other user(s)
	 * @async
	 * @param {string[]} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/reporting/dashboards/users/bulk/remove" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsReportingDashboardsUsersBulkRemove(body) {
		const endpointPath = "/api/v2/analytics/reporting/dashboards/users/bulk/remove";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "array") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "array", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get list of dashboards for an user
	 * @async
	 * @param {string} userId - User ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.sortBy] -  
	 * @param {number} [query.pageNumber] -  
	 * @param {number} [query.pageSize] -  
	 * @param {boolean} [query.publicOnly] -  If true, retrieve only public dashboards
	 * @param {boolean} [query.favoriteOnly] -  If true, retrieve only favorite dashboards
	 * @param {boolean} [query.deletedOnly] -  If true, retrieve only deleted dashboards that are still recoverable
	 * @param {string} [query.name] -  retrieve dashboards that match with given name
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/reporting/settings/users/{userId}/dashboards" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getAnalyticsReportingSettingsUserDashboards(userId, query) {
		const endpointPath = "/api/v2/analytics/reporting/settings/users/{userId}/dashboards";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(userId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("sortBy" in query && this.#checkJSONSchemaType(query["sortBy"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortBy", "string");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("publicOnly" in query && this.#checkJSONSchemaType(query["publicOnly"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "publicOnly", "boolean");
			}
			if ("favoriteOnly" in query && this.#checkJSONSchemaType(query["favoriteOnly"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "favoriteOnly", "boolean");
			}
			if ("deletedOnly" in query && this.#checkJSONSchemaType(query["deletedOnly"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "deletedOnly", "boolean");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.userId = userId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get all export metadata
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/reporting/exports/metadata" endpoint.
	 */
	getAnalyticsReportingExportsMetadata() {
		const endpointPath = "/api/v2/analytics/reporting/exports/metadata";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get all view export requests for a user
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {number} [query.pageSize] -  Page size
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/reporting/exports" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getAnalyticsReportingExports(query) {
		const endpointPath = "/api/v2/analytics/reporting/exports";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Generate a view export request
	 * @async
	 * @param {ReportingExportJobRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/reporting/exports" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsReportingExports(body) {
		const endpointPath = "/api/v2/analytics/reporting/exports";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * @description Checks that a value is of the proper JSON schema type
	 * @param {*} value - The value to check
	 * @param {string} jsonSchemaType - The JSON schema type to check against
	 * @returns {boolean} Returns true if the value is of the proper JSON schema type, false otherwise
	 */
	#checkJSONSchemaType(value, jsonSchemaType) {
		const PASSTHROUGH_JSON_SCHEMA_TYPES = ["boolean", "number", "string", "object"];

		// Check if the type is a passthrough type
		if (PASSTHROUGH_JSON_SCHEMA_TYPES.includes(jsonSchemaType)) {
			return typeof value === jsonSchemaType;
		}

		// Check if the type is an integer
		if (jsonSchemaType === "integer") {
			return Number.isInteger(value);
		}

		// Check if the type is an array
		if (jsonSchemaType === "array") {
			return Array.isArray(value);
		}

		// Check if the type is null
		if (jsonSchemaType === "null") {
			return value === null;
		}

		// Otherwise, return false
		return false;
	}
}

export { AnalyticsAPI };