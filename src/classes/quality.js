/**
 * Evaluations, calibrations
 * @module gc-platform-api-quality
 * @documentation https://developer.genesys.cloud/useragentman/quality/
 * @license MIT
 */

// This file was automatically generated by the Generate Genesys Cloud Platform API classes utility on 2025-04-24T15:04:25.217Z

// TODO: Implement JSON schema verification for input and output objects
// TODO: Implement HTTP response typedefs

// Set strict mode
"use strict";

// Errors
import { errors } from "../gc-platform-api-client-errors.js";

// Symbols
import { symbols } from "../gc-platform-api-client-symbols.js";

/** @typedef {import("../gc-platform-api-client-class.js").GCPlatformAPIClient} GCPlatformAPIClient */
/** @typedef {import("@jfabello/http-client").HTTPResponse} HTTPResponse */

/**
 * @typedef {object} Actions
 * @property {SkillsToRemove[]} [skillsToRemove]
 */
 
/**
 * @typedef {object} AcwSettings
 * @property {string} [wrapupPrompt] - This field controls how the UI prompts the agent for a wrapup.
 * @property {number} [timeoutMs] - The amount of time the agent can stay in ACW (Min: 1 sec, Max: 60 min).  Can only be used when ACW is AGENT_REQUESTED, MANDATORY_TIMEOUT or MANDATORY_FORCED_TIMEOUT.
 */
 
/**
 * @typedef {object} AddressableEntityRef
 * @property {string} [id]
 * @property {string} [selfUri]
 */
 
/**
 * @typedef {object} AgentOwnedRouting
 * @property {boolean} [enableAgentOwnedCallbacks] - Indicates if Agent Owned Callbacks are enabled for the queue
 * @property {number} [maxOwnedCallbackHours] - The max amount of time a callback can be owned (in hours); Allowable range 1 - 168 hour(s) (inclusive)
 * @property {number} [maxOwnedCallbackDelayHours] - The max amount of time a callback can be scheduled out into the future (in hours); Allowable range 1 - 720 hour(s) (inclusive)
 */
 
/**
 * @typedef {object} AggregationRange
 * @property {number} [gte] - Greater than or equal to
 * @property {number} [lt] - Less than
 */
 
/**
 * @typedef {object} AiAnswer
 * @property {string} [answerId] - The unique identifier of the suggested AI answer.
 * @property {string} [explanation] - An explanation providing the reasoning behind the suggested answer.
 * @property {string} [failureType] - Describes the type of error associated with the AI answer.
 */
 
/**
 * @typedef {object} AiScoring
 * @property {string} [failureType] - The type of error that occurred while processing AI scores. It is null where there is no error.
 * @property {boolean} [pending] - Indicates whether AI scoring is currently processing the evaluation.
 * @property {string} [dateLastChanged] - The date when the AI scores were last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 */
 
/**
 * @typedef {object} AiScoringSetting
 * @property {boolean} [enabled] - True if AI Scoring feature is configured.
 */
 
/**
 * @typedef {object} AiScoringSettings
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {QuestionGroupSettings[]} [questionGroupSettings]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} AnswerOption
 * @property {string} [id]
 * @property {string} [text]
 * @property {number} [value]
 * @property {AssistanceCondition[]} [assistanceConditions] - List of assistance conditions which are combined together with a logical AND operator. Eg ( assistanceCondtion1 && assistanceCondition2 ) wherein assistanceCondition could be ( EXISTS topic1 || topic2 || ... ) or (NOTEXISTS topic3 || topic4 || ...).
 */
 
/**
 * @typedef {object} AssistanceCondition
 * @property {string} [operator] - The operator for the assistance condition. The operator defines whether the listed topicIds should EXIST or NOTEXIST for the condition to be evaluated as true.
 * @property {string[]} [topicIds] - List of topicIds within the assistance condition which would be combined together using logical OR operator. Eg ( topicId_1 || topicId_2 ) .
 */
 
/**
 * @typedef {object} AuditQuerySort
 * @property {string} name - Name of the property to sort.
 * @property {string} sortOrder - Sort Order
 */
 
/**
 * @typedef {object} Biography
 * @property {string} [biography] - Personal detailed description
 * @property {string[]} [interests]
 * @property {string[]} [hobbies]
 * @property {string} [spouse]
 * @property {Education[]} [education] - User education details
 */
 
/**
 * @typedef {object} Bullseye
 * @property {Ring[]} [rings] - The bullseye rings configured for this queue.
 */
 
/**
 * @typedef {object} Calibration
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {User} [calibrator]
 * @property {User} [agent]
 * @property {ConversationReference} [conversation]
 * @property {EvaluationForm} [evaluationForm]
 * @property {string} [contextId]
 * @property {number} [averageScore]
 * @property {number} [highScore]
 * @property {number} [lowScore]
 * @property {string} [createdDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {Evaluation[]} [evaluations]
 * @property {User[]} [evaluators]
 * @property {Evaluation} [scoringIndex]
 * @property {User} [expertEvaluator]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} CalibrationCreate
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {User} [calibrator]
 * @property {User} [agent]
 * @property {ConversationReference} conversation - The conversation to use for the calibration.
 * @property {EvaluationForm} [evaluationForm]
 * @property {string} [contextId]
 * @property {number} [averageScore]
 * @property {number} [highScore]
 * @property {number} [lowScore]
 * @property {string} [createdDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {Evaluation[]} [evaluations]
 * @property {User[]} [evaluators]
 * @property {Evaluation} [scoringIndex]
 * @property {User} [expertEvaluator]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} CallbackMediaSettings
 * @property {boolean} [enableAutoAnswer] - Indicates if auto-answer is enabled for the given media type or subtype (default is false).  Subtype settings take precedence over media type settings.
 * @property {number} [alertingTimeoutSeconds] - The alerting timeout for the media type, in seconds
 * @property {ServiceLevel} [serviceLevel] - The targeted service level for the media type
 * @property {number} [autoAnswerAlertToneSeconds] - How long to play the alerting tone for an auto-answer interaction
 * @property {number} [manualAnswerAlertToneSeconds] - How long to play the alerting tone for a manual-answer interaction
 * @property {object} [subTypeSettings] - Map of media subtype to media subtype specific settings.
 * @property {string} [mode] - The mode callbacks will use on this queue.
 * @property {boolean} [enableAutoDialAndEnd] - Flag to enable Auto-Dial and Auto-End automation for callbacks on this queue.
 * @property {number} [autoDialDelaySeconds] - Time in seconds after agent connects to callback before outgoing call is auto-dialed. Allowable values in range 0 - 1200 seconds. Defaults to 300 seconds.
 * @property {number} [autoEndDelaySeconds] - Time in seconds after agent disconnects from the outgoing call before the encasing callback is auto-ended. Allowable values in range 0 - 1200 seconds. Defaults to 300 seconds.
 * @property {number} [pacingModifier] - Controls the maximum number of outbound calls at one time when mode is CustomerFirst.
 * @property {string} [liveVoiceReactionType] - The action to take if a live voice is detected during the outbound call of a customer first callback.
 * @property {DomainEntityRef} [liveVoiceFlow] - The inbound flow to transfer to if a live voice is detected during the outbound call of a customer first callback.
 * @property {string} [answeringMachineReactionType] - The action to take if an answering machine is detected during the outbound call of a customer first callback.
 * @property {DomainEntityRef} [answeringMachineFlow] - The inbound flow to transfer to if an answering machine is detected during the outbound call of a customer first callback when answeringMachineReactionType is set to TransferToFlow.
 */
 
/**
 * @typedef {object} CannedResponseLibraries
 * @property {string[]} [libraryIds] - Set of canned response library IDs associated with the queue only when mode is SelectedOnly.
 * @property {string} [mode] - The association mode of canned response libraries to queue
 */
 
/**
 * @typedef {object} Chat
 * @property {string} [jabberId]
 */
 
/**
 * @typedef {object} ConditionalGroupRouting
 * @property {ConditionalGroupRoutingRule[]} [rules] - The set of rules to be executed for each conversation
 */
 
/**
 * @typedef {object} ConditionalGroupRoutingRule
 * @property {DomainEntityRef} [queue] - The queue being evaluated for this rule.  If null, the current queue will be used.
 * @property {string} [metric] - The queue metric being evaluated
 * @property {string} [operator] - The operator that compares the actual value against the condition value
 * @property {number} [conditionValue] - The limit value, beyond which a rule evaluates as true
 * @property {MemberGroup[]} [groups] - The group(s) to activate if the rule evaluates as true
 * @property {number} [waitSeconds] - The number of seconds to wait in this rule, if it evaluates as true, before evaluating the next rule.  For the final rule, this is ignored, so need not be specified.
 */
 
/**
 * @typedef {object} Contact
 * @property {string} [address] - Email address or phone number for this contact type
 * @property {string} [display] - Formatted version of the address property
 * @property {string} [mediaType]
 * @property {string} [type]
 * @property {string} [extension] - Use internal extension instead of address. Mutually exclusive with the address field.
 * @property {string} [countryCode]
 * @property {string} [integration] - Integration tag value if this number is associated with an external integration.
 */
 
/**
 * @typedef {object} ConversationReference
 * @property {string} [id]
 * @property {string} [selfUri]
 */
 
/**
 * @typedef {object} DirectRouting
 * @property {DirectRoutingMediaSettings} [callMediaSettings] - Direct Routing Settings specific to Call media.
 * @property {DirectRoutingMediaSettings} [emailMediaSettings] - Direct Routing Settings specific to Email media.
 * @property {DirectRoutingMediaSettings} [messageMediaSettings] - Direct Routing Settings specific to Message media.
 * @property {string} [backupQueueId] - ID of another queue to be used as the default backup if an agent does not have their Backup Settings configured. If not set, the current queue will be used as backup, but with Direct Routing criteria removed from the conversation.
 * @property {boolean} [waitForAgent] - Flag indicating if Direct Routing interactions should wait for Direct Routing agent or go immediately to selected backup.
 * @property {number} [agentWaitSeconds] - Time (in seconds) that a Direct Routing interaction will wait for Direct Routing agent before going to selected backup. Valid range [60, 864000].
 */
 
/**
 * @typedef {object} DirectRoutingMediaSettings
 * @property {boolean} [useAgentAddressOutbound] - Toggle that enables using an agent's Direct Routing address outbound on behalf of queue for this media type.
 */
 
/**
 * @typedef {object} Division
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} DomainEntityListingEvaluationForm
 * @property {EvaluationForm[]} [entities]
 * @property {number} [pageSize]
 * @property {number} [pageNumber]
 * @property {number} [total]
 * @property {string} [firstUri]
 * @property {string} [lastUri]
 * @property {string} [selfUri]
 * @property {string} [nextUri]
 * @property {string} [previousUri]
 * @property {number} [pageCount]
 */
 
/**
 * @typedef {object} DomainEntityListingSurveyForm
 * @property {SurveyForm[]} [entities]
 * @property {number} [pageSize]
 * @property {number} [pageNumber]
 * @property {number} [total]
 * @property {string} [firstUri]
 * @property {string} [lastUri]
 * @property {string} [selfUri]
 * @property {string} [nextUri]
 * @property {string} [previousUri]
 * @property {number} [pageCount]
 */
 
/**
 * @typedef {object} DomainEntityRef
 * @property {string} [id]
 * @property {string} [name]
 * @property {string} [selfUri]
 */
 
/**
 * @typedef {object} DomainRole
 * @property {string} [id] - The ID of the role
 * @property {string} [name] - The name of the role
 */
 
/**
 * @typedef {object} Education
 * @property {string} [school]
 * @property {string} [fieldOfStudy]
 * @property {string} [notes] - Notes about education has a 2000 character limit
 * @property {string} [dateStart] - Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd
 * @property {string} [dateEnd] - Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd
 */
 
/**
 * @typedef {object} EmailAddress
 * @property {string} [email]
 * @property {string} [name]
 */
 
/**
 * @typedef {object} EmailMediaSettings
 * @property {boolean} [enableAutoAnswer] - Indicates if auto-answer is enabled for the given media type or subtype (default is false).  Subtype settings take precedence over media type settings.
 * @property {number} [alertingTimeoutSeconds] - The alerting timeout for the media type, in seconds
 * @property {ServiceLevel} [serviceLevel] - The targeted service level for the media type
 * @property {number} [autoAnswerAlertToneSeconds] - How long to play the alerting tone for an auto-answer interaction
 * @property {number} [manualAnswerAlertToneSeconds] - How long to play the alerting tone for a manual-answer interaction
 * @property {object} [subTypeSettings] - Map of media subtype to media subtype specific settings.
 */
 
/**
 * @typedef {object} EmployerInfo
 * @property {string} [officialName]
 * @property {string} [employeeId]
 * @property {string} [employeeType]
 * @property {string} [dateHire]
 */
 
/**
 * @typedef {object} Evaluation
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {ConversationReference} [conversation]
 * @property {EvaluationForm} [evaluationForm] - Evaluation form used for evaluation.
 * @property {User} [evaluator]
 * @property {User} [agent]
 * @property {Calibration} [calibration]
 * @property {string} [status]
 * @property {EvaluationScoringSet} [answers]
 * @property {boolean} [agentHasRead]
 * @property {User} [assignee]
 * @property {boolean} [assigneeApplicable] - Indicates whether an assignee is applicable for the evaluation. Set to false when assignee is not applicable.
 * @property {string} [releaseDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [assignedDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [changedDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [revisionCreatedDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {Queue} [queue]
 * @property {string[]} [mediaType] - List of different communication types used in conversation.
 * @property {boolean} [rescore] - Is only true when evaluation is re-scored.
 * @property {string} [conversationDate] - Date of conversation. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [conversationEndDate] - End date of conversation if it had completed before evaluation creation. Null if created before the conversation ended. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {boolean} [neverRelease] - Signifies if the evaluation is never to be released. This cannot be set true if release date is also set.
 * @property {boolean} [assigned] - Set to false to unassign the evaluation. This cannot be set to false when assignee is also set.
 * @property {string} [dateAssigneeChanged] - Date when the assignee was last changed. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [resourceId] - Only used for email evaluations. Will be null for all other evaluations.
 * @property {string} [resourceType] - The type of resource. Only used for email evaluations. Will be null for evaluations on all other resources.
 * @property {boolean} [redacted] - Is only true when the user making the request does not have sufficient permissions to see evaluation
 * @property {Team} [agentTeam] - Team of the evaluation agent
 * @property {boolean} [isScoringIndex]
 * @property {string[]} [authorizedActions] - List of user authorized actions on evaluation. Possible values: assign, edit, editScore, editAgentSignoff, delete, release, viewAudit
 * @property {boolean} [hasAssistanceFailed] - Is true when evaluation assistance didn't execute successfully
 * @property {EvaluationSource} [evaluationSource] - The source that created the evaluation.
 * @property {AiScoring} [aiScoring] - AI scoring details for the evaluation.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} EvaluationAggregateQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {EvaluationAggregateQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} EvaluationAggregateQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {EvaluationAggregateQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {EvaluationAggregateQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} EvaluationAggregateQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} EvaluationAggregationQuery
 * @property {string} interval - Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string} [granularity] - Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
 * @property {string} [timeZone] - Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 * @property {string[]} [groupBy] - Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group.
 * @property {EvaluationAggregateQueryFilter} [filter] - Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {boolean} [flattenMultivaluedDimensions] - Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c')
 * @property {EvaluationAggregationView[]} [views] - Custom derived metric views
 * @property {string} [alternateTimeDimension] - Dimension to use as the alternative timestamp for data in the aggregate.  Choosing "eventTime" uses the actual time of the data event.
 */
 
/**
 * @typedef {object} EvaluationAggregationQueryMe
 * @property {string} interval - Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string} [timeZone] - Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 * @property {string[]} [groupBy] - Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group.
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {string} [alternateTimeDimension] - Dimension to use as the alternative timestamp for data in the aggregate.  Choosing "eventTime" uses the actual time of the data event.
 * @property {string} [contextId] - Evaluation context Id
 */
 
/**
 * @typedef {object} EvaluationAggregationView
 * @property {string} target - Target metric name
 * @property {string} name - A unique name for this view. Must be distinct from other views and built-in metric names.
 * @property {string} function - Type of view you wish to create
 * @property {AggregationRange} [range] - Range of numbers for slicing up data
 */
 
/**
 * @typedef {object} EvaluationCreateBody
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {EvaluationCreateEvalForm} [evaluationForm] - Evaluation form used for evaluation (must be included for a successful request)
 * @property {EvaluationCreateUser} [evaluator] - User ID of the evaluator (must be included for a successful request)
 * @property {EvaluationCreateUser} [agent] - User ID of the agent (must be included for a successful request)
 * @property {boolean} [agentHasRead]
 * @property {EvaluationScoringSet} [answers]
 * @property {EvaluationCreateCalibration} [calibration]
 * @property {string} [evaluationContextId]
 * @property {EvaluationCreateConversation} [conversation]
 * @property {string} [resourceType]
 * @property {EvaluationSource} [evaluationSource]
 * @property {boolean} [rescore]
 * @property {EvaluationCreateQueue} [queue]
 * @property {string} [releaseDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [status]
 * @property {boolean} [neverRelease]
 * @property {string} [dateAssigneeChanged] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {EvaluationCreateUser} [assignee]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} EvaluationCreateCalibration
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} EvaluationCreateConversation
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} EvaluationCreateEvalForm
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} EvaluationCreateQueue
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} EvaluationCreateUser
 * @property {string} id - The globally unique identifier for the object.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} EvaluationForm
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The evaluation form name
 * @property {string} [modifiedDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {boolean} [published]
 * @property {string} [contextId]
 * @property {EvaluationQuestionGroup[]} questionGroups - A list of question groups
 * @property {DomainEntityListingEvaluationForm} [publishedVersions] - A list of the published versions of this form. Not populated by default, its availability depends on the endpoint. Use the 'expand=publishHistory' query parameter to retrieve this data where applicable (refer to the endpoint description to see if it is applicable).
 * @property {EvaluationSettings} [evaluationSettings] - Settings for evaluations associated with this form
 * @property {AiScoringSettings} [aiScoring] - AI scoring settings for the evaluation form.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} EvaluationFormAndScoringSet
 * @property {EvaluationForm} [evaluationForm]
 * @property {EvaluationScoringSet} [answers]
 */
 
/**
 * @typedef {object} EvaluationQuestion
 * @property {string} [id]
 * @property {string} [contextId] - An identifier for this question that stays the same across versions of the form.
 * @property {string} [text]
 * @property {string} [helpText]
 * @property {string} [type]
 * @property {boolean} [naEnabled]
 * @property {boolean} [commentsRequired]
 * @property {VisibilityCondition} [visibilityCondition]
 * @property {AnswerOption[]} [answerOptions] - Options from which to choose an answer for this question. Only used by Multiple Choice type questions.
 * @property {boolean} [isKill]
 * @property {boolean} [isCritical]
 */
 
/**
 * @typedef {object} EvaluationQuestionGroup
 * @property {string} [id]
 * @property {string} [contextId] - An identifier for this question group that stays the same across versions of the form.
 * @property {string} [name]
 * @property {string} [type]
 * @property {boolean} [defaultAnswersToHighest]
 * @property {boolean} [defaultAnswersToNA]
 * @property {boolean} [naEnabled]
 * @property {number} [weight]
 * @property {boolean} [manualWeight]
 * @property {EvaluationQuestion[]} [questions]
 * @property {VisibilityCondition} [visibilityCondition]
 */
 
/**
 * @typedef {object} EvaluationQuestionGroupScore
 * @property {string} [questionGroupId]
 * @property {number} [totalScore] - Score of all questions in the group
 * @property {number} [maxTotalScore] - Maximum possible score of all questions in the group
 * @property {boolean} [markedNA] - True when the evaluation is submitted with a question group that does not have any answers. Only allowed when naEnabled is true or if set by the system
 * @property {boolean} [systemMarkedNA] - If markedNA is true, systemMarkedNA indicates whether it was marked by a user or by the system due to visibility conditions. Always false if markedNA is false.
 * @property {number} [totalCriticalScore] - Score of only the critical questions in the group
 * @property {number} [maxTotalCriticalScore] - Maximum possible score of only the critical questions in the group
 * @property {number} [totalNonCriticalScore] - Score of only the non critical questions in the group
 * @property {number} [maxTotalNonCriticalScore] - Maximum possible score of only the non critical questions in the group
 * @property {number} [totalScoreUnweighted] - Unweighted score of all questions in the group
 * @property {number} [maxTotalScoreUnweighted] - Maximum possible unweighted score of all questions in the group
 * @property {number} [totalCriticalScoreUnweighted] - Unweighted score of only the critical questions in the group
 * @property {number} [maxTotalCriticalScoreUnweighted] - Maximum possible unweighted score of only the critical questions in the group
 * @property {number} [totalNonCriticalScoreUnweighted] - Unweighted score of only the non critical questions in the group
 * @property {number} [maxTotalNonCriticalScoreUnweighted] - Maximum possible unweighted score of only the non critical questions in the group
 * @property {EvaluationQuestionScore[]} [questionScores]
 */
 
/**
 * @typedef {object} EvaluationQuestionScore
 * @property {string} [questionId]
 * @property {string} [answerId]
 * @property {number} [score] - Unweighted score of the question
 * @property {boolean} [markedNA] - True when the evaluation is submitted with a question that does not have an answer. Only allowed when naEnabled is true or if set by the system
 * @property {boolean} [systemMarkedNA] - If markedNA is true, systemMarkedNA indicates whether it was marked by a user or by the system due to visibility conditions. Always false if markedNA is false.
 * @property {string} [assistedAnswerId] - AnswerId found with evaluation assistance conditions
 * @property {boolean} [failedKillQuestion] - Applicable only on fatal questions. Indicates that the answer selected was not the highest score available for the question
 * @property {string} [comments] - Comments from the evaluator specific to this question
 * @property {AiAnswer} [aiAnswer] - Suggested AI answer
 */
 
/**
 * @typedef {object} EvaluationScoringSet
 * @property {number} [totalScore] - Score of all questions
 * @property {number} [totalCriticalScore] - Score of only the critical questions
 * @property {number} [totalNonCriticalScore] - Score of only the non-critical questions
 * @property {EvaluationQuestionGroupScore[]} [questionGroupScores]
 * @property {boolean} [anyFailedKillQuestions] - Indicates that at least one fatal question was answered without having the highest score available for the question
 * @property {string} [comments] - Overall comments from the evaluator
 * @property {string} [privateComments] - Overall private comments from the evaluator
 * @property {string} [agentComments] - Comments from the agent while reviewing evaluation results
 * @property {TranscriptTopic[]} [transcriptTopics] - List of topics found within the conversation's transcripts
 */
 
/**
 * @typedef {object} EvaluationSettings
 * @property {boolean} [revisionsEnabled] - Whether revisions are allowed for evaluations. When enabled, rescoring creates a new version of the evaluation and retracts the existing evaluation version. Does not apply for calibration evaluations.
 * @property {boolean} [disputesEnabled] - Whether disputes are allowed for evaluations. Does not apply for calibration evaluations.
 * @property {number} [disputesAllowedPerEvaluation] - The maximum number of disputes allowed for an evaluation.
 * @property {EvaluationSettingsAssignee[]} [disputesAssignees] - A list of assignees responsible for handling each dispute. This list size needs to be equal to disputesAllowedPerEvaluation.
 */
 
/**
 * @typedef {object} EvaluationSettingsAssignee
 * @property {UserReferenceWithName} [user] - The user the dispute should be assigned to
 * @property {string} [type] - The assignee type. Valid values: Original, Individual, None
 */
 
/**
 * @typedef {object} EvaluationSource
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [type] - Type of the evaluation source.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} ExpansionCriterium
 * @property {string} [type]
 * @property {number} [threshold]
 */
 
/**
 * @typedef {object} Geolocation
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [type] - A string used to describe the type of client the geolocation is being updated from e.g. ios, android, web, etc.
 * @property {boolean} [primary] - A boolean used to tell whether or not to set this geolocation client as the primary on a PATCH
 * @property {number} [latitude]
 * @property {number} [longitude]
 * @property {string} [country]
 * @property {string} [region]
 * @property {string} [city]
 * @property {LocationDefinition[]} [locations]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} Group
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The group name.
 * @property {string} [description]
 * @property {string} [dateModified] - Last modified date/time. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {number} [memberCount] - Number of members.
 * @property {string} [state] - Active, inactive, or deleted state.
 * @property {number} [version] - Current version for this resource.
 * @property {string} type - Type of group.
 * @property {Image[]} [images]
 * @property {GroupContact[]} [addresses]
 * @property {boolean} rulesVisible - Are membership rules visible to the person requesting to view the group
 * @property {string} visibility - Who can view this group
 * @property {boolean} [rolesEnabled] - Allow roles to be assigned to this group
 * @property {boolean} [includeOwners] - Allow owners to be included as members of the group
 * @property {boolean} [callsEnabled] - Allow calls to be placed to this group.
 * @property {User[]} [owners] - Owners of the group
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} GroupContact
 * @property {string} address - Phone number for this contact type
 * @property {string} [extension] - Extension is set if the number is e164 valid
 * @property {string} [display] - Formatted version of the address property
 * @property {string} type - Contact type of the address
 * @property {string} mediaType - Media type of the address
 */
 
/**
 * @typedef {object} Image
 * @property {string} [resolution] - Height and/or width of image. ex: 640x480 or x128
 * @property {string} [imageUri]
 */
 
/**
 * @typedef {object} InboundRoute
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} pattern - The search pattern that the mailbox name should match.
 * @property {DomainEntityRef} [queue] - The queue to route the emails to.
 * @property {number} [priority] - The priority to use for routing.
 * @property {DomainEntityRef[]} [skills] - The skills to use for routing.
 * @property {DomainEntityRef} [language] - The language to use for routing.
 * @property {string} fromName - The sender name to use for outgoing replies.
 * @property {string} [fromEmail] - The sender email to use for outgoing replies.
 * @property {DomainEntityRef} [flow] - The flow to use for processing the email.
 * @property {QueueEmailAddress} [replyEmailAddress] - The route to use for email replies.
 * @property {EmailAddress[]} [autoBcc] - The recipients that should be automatically blind copied on outbound emails associated with this InboundRoute.
 * @property {DomainEntityRef} [spamFlow] - The flow to use for processing inbound emails that have been marked as spam.
 * @property {Signature} [signature] - The configuration for the canned response signature that will be appended to outbound emails sent via this route
 * @property {string} [historyInclusion] - The configuration to indicate how the history of a conversation has to be included in a draft
 * @property {boolean} [allowMultipleActions] - Control if multiple actions are allowed on this route. When true the disconnect has to be done manually. When false a conversation will be disconnected by the system after every action
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} Location
 * @property {string} [id] - Unique identifier for the location
 * @property {string} [floorplanId] - Unique identifier for the location floorplan image
 * @property {object} [coordinates] - Users coordinates on the floorplan. Only used when floorplanImage is set
 * @property {string} [notes] - Optional description on the users location
 * @property {LocationDefinition} [locationDefinition]
 */
 
/**
 * @typedef {object} LocationAddress
 * @property {string} [city]
 * @property {string} [country]
 * @property {string} [countryName]
 * @property {string} [state]
 * @property {string} [street1]
 * @property {string} [street2]
 * @property {string} [zipcode]
 */
 
/**
 * @typedef {object} LocationAddressVerificationDetails
 * @property {string} [status] - Status of address verification process
 * @property {string} [dateFinished] - Finished time of address verification process. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateStarted] - Time started of address verification process. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [service] - Third party service used for address verification
 */
 
/**
 * @typedef {object} LocationDefinition
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {AddressableEntityRef} [contactUser] - Site contact for the location entity
 * @property {LocationEmergencyNumber} [emergencyNumber] - Emergency number for the location entity
 * @property {LocationAddress} [address]
 * @property {string} [state] - Current state of the location entity
 * @property {string} [notes] - Notes for the location entity
 * @property {number} [version] - Current version of the location entity, value to be supplied should be retrieved by a GET or on create/update response
 * @property {string[]} [path] - A list of ancestor IDs in order
 * @property {LocationImage[]} [profileImage] - Profile image of the location entity, retrieved with ?expand=images query parameter
 * @property {LocationImage[]} [floorplanImage] - Floorplan images of the location entity, retrieved with ?expand=images query parameter
 * @property {LocationAddressVerificationDetails} [addressVerificationDetails] - Address verification information, retrieve dwith the ?expand=addressVerificationDetails query parameter
 * @property {boolean} [addressVerified] - Boolean field which states if the address has been verified as an actual address
 * @property {boolean} [addressStored] - Boolean field which states if the address has been stored for E911
 * @property {string} [images]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} LocationEmergencyNumber
 * @property {string} [e164]
 * @property {string} [number]
 * @property {string} [type] - The type of emergency number.
 */
 
/**
 * @typedef {object} LocationImage
 * @property {string} [resolution] - Height and/or width of image. ex: 640x480 or x128
 * @property {string} [imageUri]
 */
 
/**
 * @typedef {object} MediaSettings
 * @property {boolean} [enableAutoAnswer] - Indicates if auto-answer is enabled for the given media type or subtype (default is false).  Subtype settings take precedence over media type settings.
 * @property {number} [alertingTimeoutSeconds] - The alerting timeout for the media type, in seconds
 * @property {ServiceLevel} [serviceLevel] - The targeted service level for the media type
 * @property {number} [autoAnswerAlertToneSeconds] - How long to play the alerting tone for an auto-answer interaction
 * @property {number} [manualAnswerAlertToneSeconds] - How long to play the alerting tone for a manual-answer interaction
 * @property {object} [subTypeSettings] - Map of media subtype to media subtype specific settings.
 */
 
/**
 * @typedef {object} MediaSummary
 * @property {MediaSummaryDetail} [contactCenter]
 * @property {MediaSummaryDetail} [enterprise]
 */
 
/**
 * @typedef {object} MediaSummaryDetail
 * @property {number} [active]
 * @property {number} [acw]
 */
 
/**
 * @typedef {object} MemberGroup
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {WritableDivision} [division] - The division to which this entity belongs.
 * @property {string} [type] - The group type
 * @property {number} [memberCount] - The number of members in this group
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} MessageMediaSettings
 * @property {boolean} [enableAutoAnswer] - Indicates if auto-answer is enabled for the given media type or subtype (default is false).  Subtype settings take precedence over media type settings.
 * @property {number} [alertingTimeoutSeconds] - The alerting timeout for the media type, in seconds
 * @property {ServiceLevel} [serviceLevel] - The targeted service level for the media type
 * @property {number} [autoAnswerAlertToneSeconds] - How long to play the alerting tone for an auto-answer interaction
 * @property {number} [manualAnswerAlertToneSeconds] - How long to play the alerting tone for a manual-answer interaction
 * @property {object} [subTypeSettings] - Map of media subtype to media subtype specific settings.
 */
 
/**
 * @typedef {object} NumericRange
 * @property {number} [gt] - Greater than
 * @property {number} [gte] - Greater than or equal to
 * @property {number} [lt] - Less than
 * @property {number} [lte] - Less than or equal to
 */
 
/**
 * @typedef {object} OAuthLastTokenIssued
 * @property {string} [dateIssued] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 */
 
/**
 * @typedef {object} OutOfOffice
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {User} [user]
 * @property {string} [startDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [endDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {boolean} [active]
 * @property {boolean} [indefinite]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} PresenceDefinition
 * @property {string} [id] - description
 * @property {string} [systemPresence]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} PublishForm
 * @property {boolean} published - Is this form published
 * @property {string} id - Unique Id for this version of this form
 */
 
/**
 * @typedef {object} QMAuditQueryRequest
 * @property {string} interval - Date and time range of data to query. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {QualityAuditQueryFilter[]} filters - List of filters for the query.
 * @property {AuditQuerySort[]} [sort] - Sort parameter for the query.
 */
 
/**
 * @typedef {object} QualityAuditQueryFilter
 * @property {string} property - Name of the property to filter.
 * @property {string} value - Value of the property to filter.
 */
 
/**
 * @typedef {object} QuestionGroupSettings
 * @property {string} [questionGroupContextId] - The context id of the question group in the form.
 * @property {QuestionSettings[]} [questionSettings]
 */
 
/**
 * @typedef {object} QuestionSettings
 * @property {string} [questionContextId] - The context id of the question in the group
 * @property {AiScoringSetting} [settings]
 */
 
/**
 * @typedef {object} Queue
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {Division} [division] - The division to which this entity belongs.
 * @property {string} [description] - The queue description.
 * @property {string} [dateCreated] - The date the queue was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateModified] - The date of the last modification to the queue. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [modifiedBy] - The ID of the user that last modified the queue.
 * @property {string} [createdBy] - The ID of the user that created the queue.
 * @property {number} [memberCount] - The total number of members in the queue.
 * @property {number} [userMemberCount] - The number of user members (i.e., non-group members) in the queue.
 * @property {number} [joinedMemberCount] - The number of joined members in the queue.
 * @property {QueueMediaSettings} [mediaSettings] - The media settings for the queue.
 * @property {RoutingRule[]} [routingRules] - The routing rules for the queue, used for Preferred Agent Routing.
 * @property {ConditionalGroupRouting} [conditionalGroupRouting] - The Conditional Group Routing settings for the queue.
 * @property {Bullseye} [bullseye] - The bullseye settings for the queue.
 * @property {string} [scoringMethod] - The Scoring Method for the queue.
 * @property {string} [lastAgentRoutingMode] - The Last Agent Routing Mode for the queue.
 * @property {AcwSettings} [acwSettings] - The ACW settings for the queue.
 * @property {string} [skillEvaluationMethod] - The skill evaluation method to use when routing conversations.
 * @property {MemberGroup[]} [memberGroups] - The groups of agents associated with the queue, if any.  Queue membership will update to match group membership changes.
 * @property {DomainEntityRef} [queueFlow] - The in-queue flow to use for call conversations waiting in queue.
 * @property {DomainEntityRef} [emailInQueueFlow] - The in-queue flow to use for email conversations waiting in queue.
 * @property {DomainEntityRef} [messageInQueueFlow] - The in-queue flow to use for message conversations waiting in queue.
 * @property {DomainEntityRef} [whisperPrompt] - The prompt used for whisper on the queue, if configured.
 * @property {DomainEntityRef} [onHoldPrompt] - The audio to be played when calls on this queue are on hold. If not configured, the default on-hold music will play.
 * @property {boolean} [autoAnswerOnly] - Specifies whether the configured whisper should play for all ACD calls, or only for those which are auto-answered.
 * @property {CannedResponseLibraries} [cannedResponseLibraries] - Canned response library IDs and mode with which they are associated with the queue
 * @property {boolean} [enableTranscription] - Indicates whether voice transcription is enabled for this queue.
 * @property {boolean} [enableAudioMonitoring] - Indicates whether audio monitoring is enabled for this queue.
 * @property {boolean} [enableManualAssignment] - Indicates whether manual assignment is enabled for this queue.
 * @property {AgentOwnedRouting} [agentOwnedRouting] - The Agent Owned Routing settings for the queue
 * @property {DirectRouting} [directRouting] - The Direct Routing settings for the queue
 * @property {string} [callingPartyName] - The name to use for caller identification for outbound calls from this queue.
 * @property {string} [callingPartyNumber] - The phone number to use for caller identification for outbound calls from this queue.
 * @property {object} [defaultScripts] - The default script Ids for the communication types.
 * @property {QueueMessagingAddresses} [outboundMessagingAddresses] - The messaging addresses for the queue.
 * @property {QueueEmailAddress} [outboundEmailAddress] - The default email address to use for outbound email from this queue.
 * @property {string} [peerId] - The ID of an associated external queue.
 * @property {boolean} [suppressInQueueCallRecording] - Indicates whether recording in-queue calls is suppressed for this queue.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} QueueEmailAddress
 * @property {DomainEntityRef} [domain]
 * @property {InboundRoute} [route]
 */
 
/**
 * @typedef {object} QueueMediaSettings
 * @property {MediaSettings} [call] - The queue media settings for call interactions.
 * @property {CallbackMediaSettings} [callback] - The queue media settings for callback interactions.
 * @property {MediaSettings} [chat] - The queue media settings for chat interactions.
 * @property {EmailMediaSettings} [email] - The queue media settings for email interactions.
 * @property {MessageMediaSettings} [message] - The queue media settings for message interactions.
 */
 
/**
 * @typedef {object} QueueMessagingAddresses
 * @property {DomainEntityRef} [smsAddress]
 * @property {DomainEntityRef} [openMessagingRecipient]
 * @property {DomainEntityRef} [whatsAppRecipient]
 */
 
/**
 * @typedef {object} ResourceConditionNode
 * @property {string} [variableName]
 * @property {string} [conjunction]
 * @property {string} [operator]
 * @property {ResourceConditionValue[]} [operands]
 * @property {ResourceConditionNode[]} [terms]
 */
 
/**
 * @typedef {object} ResourceConditionValue
 * @property {string} [type]
 * @property {string} [value]
 */
 
/**
 * @typedef {object} ResourcePermissionPolicy
 * @property {string} [id]
 * @property {string} [domain]
 * @property {string} [entityName]
 * @property {string} [policyName]
 * @property {string} [policyDescription]
 * @property {string} [actionSetKey]
 * @property {boolean} [allowConditions]
 * @property {ResourceConditionNode} [resourceConditionNode]
 * @property {string[]} [namedResources]
 * @property {string} [resourceCondition]
 * @property {string[]} [actionSet]
 */
 
/**
 * @typedef {object} Ring
 * @property {ExpansionCriterium[]} [expansionCriteria] - The conditions that will trigger conversations to move to the next bullseye ring.
 * @property {Actions} [actions] - The actions that will be performed just before moving conversations to the next bullseye ring.
 * @property {MemberGroup[]} [memberGroups] - The groups of agents associated with the ring, if any.  Ring membership will update to match group membership changes.
 */
 
/**
 * @typedef {object} RoutingRule
 * @property {string} [operator] - matching operator.  MEETS_THRESHOLD matches any agent with a score at or above the rule's threshold.  ANY matches all specified agents, regardless of score.
 * @property {number} [threshold] - threshold required for routing attempt (generally an agent score).  may be null for operator ANY.
 * @property {number} [waitSeconds] - seconds to wait in this rule before moving to the next
 */
 
/**
 * @typedef {object} RoutingStatus
 * @property {string} [userId] - The userId of the agent
 * @property {string} [status] - Indicates the Routing State of the agent.  A value of OFF_QUEUE will be returned if the specified user does not exist.
 * @property {string} [startTime] - The timestamp when the agent went into this state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 */
 
/**
 * @typedef {object} ScorableSurvey
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {SurveyForm} [surveyForm] - Survey form used for this survey.
 * @property {string} [status]
 * @property {SurveyScoringSet} [answers]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} ServiceLevel
 * @property {number} [percentage] - The desired Service Level. A value between 0 and 1.
 * @property {number} [durationMs] - Service Level target in milliseconds.
 */
 
/**
 * @typedef {object} Signature
 * @property {boolean} [enabled] - A toggle to enable the signature on email send.
 * @property {string} [cannedResponseId] - The identifier referring to an email signature canned response.
 * @property {boolean} [alwaysIncluded] - A toggle that defines if a signature is always included or only set on the first email in an email chain.
 * @property {string} [inclusionType] - The configuration to indicate when the signature of a conversation has to be included
 */
 
/**
 * @typedef {object} SkillsToRemove
 * @property {string} [name]
 * @property {string} [id]
 * @property {string} [selfUri]
 */
 
/**
 * @typedef {object} SurveyAggregateQueryClause
 * @property {string} type - Boolean operation to apply to the provided predicates
 * @property {SurveyAggregateQueryPredicate[]} predicates - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} SurveyAggregateQueryFilter
 * @property {string} type - Boolean operation to apply to the provided predicates and clauses
 * @property {SurveyAggregateQueryClause[]} [clauses] - Boolean 'and/or' logic with up to two-levels of nesting
 * @property {SurveyAggregateQueryPredicate[]} [predicates] - Like a three-word sentence: (attribute-name) (operator) (target-value).
 */
 
/**
 * @typedef {object} SurveyAggregateQueryPredicate
 * @property {string} [type] - Optional type, can usually be inferred
 * @property {string} [dimension] - Left hand side for dimension predicates
 * @property {string} [operator] - Optional operator, default is matches
 * @property {string} [value] - Right hand side for dimension predicates
 * @property {NumericRange} [range] - Right hand side for dimension predicates
 */
 
/**
 * @typedef {object} SurveyAggregationQuery
 * @property {string} interval - Behaves like one clause in a SQL WHERE. Specifies the date and time range of data being queried. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
 * @property {string} [granularity] - Granularity aggregates metrics into subpartitions within the time interval specified. The default granularity is the same duration as the interval. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
 * @property {string} [timeZone] - Time zone context used to calculate response intervals (this allows resolving DST changes). The interval offset is used even when timeZone is specified. Default is UTC. Time zones are represented as a string of the zone name as found in the IANA time zone database. For example: UTC, Etc/UTC, or Europe/London
 * @property {string[]} [groupBy] - Behaves like a SQL GROUPBY. Allows for multiple levels of grouping as a list of dimensions. Partitions resulting aggregate computations into distinct named subgroups rather than across the entire result set as if it were one group.
 * @property {SurveyAggregateQueryFilter} [filter] - Behaves like a SQL WHERE clause. This is ANDed with the interval parameter. Expresses boolean logical predicates as well as dimensional filters
 * @property {string[]} metrics - Behaves like a SQL SELECT clause. Only named metrics will be retrieved.
 * @property {boolean} [flattenMultivaluedDimensions] - Flattens any multivalued dimensions used in response groups (e.g. ['a','b','c']->'a,b,c')
 * @property {SurveyAggregationView[]} [views] - Custom derived metric views
 * @property {string} [alternateTimeDimension] - Dimension to use as the alternative timestamp for data in the aggregate.  Choosing "eventTime" uses the actual time of the data event.
 */
 
/**
 * @typedef {object} SurveyAggregationView
 * @property {string} target - Target metric name
 * @property {string} name - A unique name for this view. Must be distinct from other views and built-in metric names.
 * @property {string} function - Type of view you wish to create
 * @property {AggregationRange} [range] - Range of numbers for slicing up data
 */
 
/**
 * @typedef {object} SurveyForm
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The survey form name
 * @property {string} [modifiedDate] - Last modified date. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {boolean} [published] - Is this form published
 * @property {boolean} [disabled] - Is this form disabled
 * @property {string} contextId - Unique Id for all versions of this form
 * @property {string} language - Language for survey viewer localization. Currently localized languages: da, de, en-US, es, fi, fr, it, ja, ko, nl, no, pl, pt-BR, sv, th, tr, zh-CH, zh-TW
 * @property {string} [header] - Markdown text for the top of the form.
 * @property {string} [footer] - Markdown text for the bottom of the form.
 * @property {SurveyQuestionGroup[]} [questionGroups] - A list of question groups
 * @property {DomainEntityListingSurveyForm} [publishedVersions] - List of published version of this form
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} SurveyFormAndScoringSet
 * @property {SurveyForm} [surveyForm]
 * @property {SurveyScoringSet} [answers]
 */
 
/**
 * @typedef {object} SurveyQuestion
 * @property {string} [id]
 * @property {string} [text]
 * @property {string} [helpText]
 * @property {string} [type]
 * @property {boolean} [naEnabled]
 * @property {VisibilityCondition} [visibilityCondition]
 * @property {AnswerOption[]} [answerOptions] - Options from which to choose an answer for this question. Only used by Multiple Choice type questions.
 * @property {number} [maxResponseCharacters] - How many characters are allowed in the text response to this question. Used by NPS and Free Text question types.
 * @property {string} [explanationPrompt] - Prompt for details explaining the chosen NPS score. Used by NPS questions.
 */
 
/**
 * @typedef {object} SurveyQuestionGroup
 * @property {string} [id]
 * @property {string} [name]
 * @property {string} [type]
 * @property {boolean} [naEnabled]
 * @property {SurveyQuestion[]} [questions]
 * @property {VisibilityCondition} [visibilityCondition]
 */
 
/**
 * @typedef {object} SurveyQuestionGroupScore
 * @property {string} [questionGroupId]
 * @property {number} [totalScore] - Score of all questions in the group
 * @property {number} [maxTotalScore] - Maximum possible score of all questions in the group
 * @property {boolean} [markedNA] - True when the evaluation is submitted with a question group that does not have any answers. Only allowed when naEnabled is true or if set by the system
 * @property {boolean} [systemMarkedNA] - If markedNA is true, systemMarkedNA indicates whether it was marked by a user or by the system due to visibility conditions. Always false if markedNA is false.
 * @property {SurveyQuestionScore[]} [questionScores]
 */
 
/**
 * @typedef {object} SurveyQuestionScore
 * @property {string} [questionId]
 * @property {string} [answerId]
 * @property {number} [score] - Unweighted score of the question
 * @property {boolean} [markedNA] - True when the evaluation is submitted with a question that does not have an answer. Only allowed when naEnabled is true or if set by the system
 * @property {boolean} [systemMarkedNA] - If markedNA is true, systemMarkedNA indicates whether it was marked by a user or by the system due to visibility conditions. Always false if markedNA is false.
 * @property {string} [assistedAnswerId] - AnswerId found with evaluation assistance conditions
 * @property {number} [npsScore]
 * @property {string} [npsTextAnswer]
 * @property {string} [freeTextAnswer]
 */
 
/**
 * @typedef {object} SurveyScoringSet
 * @property {number} [totalScore]
 * @property {number} [npsScore]
 * @property {SurveyQuestionGroupScore[]} [questionGroupScores]
 */
 
/**
 * @typedef {object} Team
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The team name
 * @property {WritableDivision} [division] - The division to which this entity belongs.
 * @property {string} [description] - Team information.
 * @property {string} [dateCreated] - Last modified datetime. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateModified] - Last modified datetime. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {number} [memberCount] - Number of members in a team
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} TopicDuration
 * @property {number} [totalMilliseconds] - The total duration of the topic phrase within the conversation
 */
 
/**
 * @typedef {object} TopicOffset
 * @property {number} [wordCount] - Count of words before the topic 
 * @property {number} [characterCount] - Count of characters before the topic 
 */
 
/**
 * @typedef {object} TranscriptTopic
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name] - The name of the object.
 * @property {string} [topicPhrase] - The phrase which detected the topic. 
 * @property {string} [transcriptPhrase] - The transcript phrase which detected the topic.
 * @property {number} [confidence] - The detection confidence of the topic.
 * @property {number} [startTimeMilliseconds] - The start time of the topic phrase.
 * @property {TopicDuration} [duration]
 * @property {TopicOffset} [offset] - Location of the phrase
 * @property {number} [recordingLocation] - Location of the phrase in the recording in milliseconds
 */
 
/**
 * @typedef {object} User
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {Division} [division] - The division to which this entity belongs.
 * @property {Chat} [chat]
 * @property {string} [department]
 * @property {string} [email]
 * @property {Contact[]} [primaryContactInfo] - Auto populated from addresses.
 * @property {Contact[]} [addresses] - Email addresses and phone numbers for this user
 * @property {string} [state] - The current state for this user.
 * @property {string} [title]
 * @property {string} [username]
 * @property {User} [manager]
 * @property {Image[]} [images]
 * @property {number} version - Required when updating a user, this value should be the current version of the user.  The current version can be obtained with a GET on the user before doing a PATCH.
 * @property {string[]} [certifications]
 * @property {Biography} [biography]
 * @property {EmployerInfo} [employerInfo]
 * @property {string} [preferredName] - Preferred full name of the agent
 * @property {RoutingStatus} [routingStatus] - ACD routing status
 * @property {UserPresence} [presence] - Active presence
 * @property {UserPresence} [integrationPresence] - Integration presence
 * @property {UserConversationSummary} [conversationSummary] - Summary of conversion statistics for conversation types.
 * @property {OutOfOffice} [outOfOffice] - Determine if out of office is enabled
 * @property {Geolocation} [geolocation] - Current geolocation position
 * @property {UserStations} [station] - Effective, default, and last station information
 * @property {UserAuthorization} [authorization] - Roles and permissions assigned to the user
 * @property {string[]} [profileSkills] - Profile skills possessed by the user
 * @property {Location[]} [locations] - The user placement at each site location.
 * @property {Group[]} [groups] - The groups the user is a member of
 * @property {Team} [team] - The team the user is a member of
 * @property {WorkPlanBidRanks} [workPlanBidRanks] - The WFM work plan bid rank settings for the user
 * @property {UserRoutingSkill[]} [skills] - Routing (ACD) skills possessed by the user
 * @property {UserRoutingLanguage[]} [languages] - Routing (ACD) languages possessed by the user
 * @property {boolean} [acdAutoAnswer] - acd auto answer
 * @property {string} [languagePreference] - preferred language by the user
 * @property {OAuthLastTokenIssued} [lastTokenIssued]
 * @property {string} [dateLastLogin] - The last time the user logged in using username and password. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateWelcomeSent] - The date & time the user was sent their welcome email. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} UserAuthorization
 * @property {DomainRole[]} [roles]
 * @property {DomainRole[]} [unusedRoles] - A collection of the roles the user is not using
 * @property {string[]} [permissions] - A collection of the permissions granted by all assigned roles
 * @property {ResourcePermissionPolicy[]} [permissionPolicies] - The policies configured for assigned permissions.
 */
 
/**
 * @typedef {object} UserConversationSummary
 * @property {string} [userId]
 * @property {MediaSummary} [call]
 * @property {MediaSummary} [callback]
 * @property {MediaSummary} [email]
 * @property {MediaSummary} [message]
 * @property {MediaSummary} [chat]
 * @property {MediaSummary} [socialExpression]
 * @property {MediaSummary} [video]
 */
 
/**
 * @typedef {object} UserPresence
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [source] - Deprecated - The sourceID field should be used as a replacement.
 * @property {string} [sourceId] - Represents the ID of a registered source
 * @property {boolean} [primary] - A boolean used to tell whether or not to set this presence source as the primary on a PATCH
 * @property {PresenceDefinition} [presenceDefinition]
 * @property {string} [message]
 * @property {string} [modifiedDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} UserReferenceWithName
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * Represents an organization language assigned to a user. When assigning to a user specify the organization language id as the id.
 * @typedef {object} UserRoutingLanguage
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {number} [proficiency] - A rating from 0.0 to 5.0 that indicates how fluent an agent is in a particular language. ACD interactions are routed to agents with higher proficiency ratings.
 * @property {string} [state] - Activate or deactivate this routing language.
 * @property {string} [languageUri] - URI to the organization language used by this user language.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * Represents an organization skill assigned to a user. When assigning to a user specify the organization skill id as the id.
 * @typedef {object} UserRoutingSkill
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {number} [proficiency] - A rating from 0.0 to 5.0 that indicates how adept an agent is at a particular skill. When "Best available skills" is enabled for a queue in Genesys Cloud, ACD interactions in that queue are routed to agents with higher proficiency ratings.
 * @property {string} [state] - Activate or deactivate this routing skill.
 * @property {string} [skillUri] - URI to the organization skill used by this user skill.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} UserStation
 * @property {string} [id] - A globally unique identifier for this station
 * @property {string} [name]
 * @property {string} [type]
 * @property {User} [associatedUser]
 * @property {string} [associatedDate] - Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {User} [defaultUser]
 * @property {object} [providerInfo] - Provider-specific info for this station, e.g. { "edgeGroupId": "ffe7b15c-a9cc-4f4c-88f5-781327819a49" }
 * @property {number} [webRtcCallAppearances] - The number of call appearances on the station.
 */
 
/**
 * @typedef {object} UserStations
 * @property {UserStation} [associatedStation] - Current associated station for this user.
 * @property {UserStation} [effectiveStation] - The station where the user can be reached based on their default and associated station.
 * @property {UserStation} [defaultStation] - Default station to be used if not associated with a station.
 * @property {UserStation} [lastAssociatedStation] - Last associated station for this user.
 */
 
/**
 * @typedef {object} VisibilityCondition
 * @property {string} [combiningOperation]
 * @property {object[]} [predicates] - A list of strings, each representing the location in the form of the Answer Option to depend on. In the format of "/form/questionGroup/{questionGroupIndex}/question/{questionIndex}/answer/{answerIndex}" or, to assume the current question group, "../question/{questionIndex}/answer/{answerIndex}". Note: Indexes are zero-based
 */
 
/**
 * @typedef {object} WorkPlanBidRanks
 * @property {string} [id] - The globally unique identifier for the user.
 * @property {number} [workPlanBiddingPerformance] - Work plan bidding agent performance ranking. The range of values is between 0 and 9999.
 * @property {string} [biddingTieBreaker] - Custom agent ranking metric that some customers can use.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} WritableDivision
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} [name]
 * @property {string} [selfUri] - The URI for this object
 */
 

/**
 * Quality - Evaluations, calibrations
 * @class Quality
 */
class QualityAPI {
	// Private instance properties
	#gcPlatformAPIClient = null;

	/**
	 * Constructor for the Quality class
	 * @constructor
	 * @param {GCPlatformAPIClient} gcPlatformAPIClient - The Genesys Cloud Platform API client instance.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_INSTANCE_TYPE_INVALID} If the Genesys Cloud Platform API client instance argument is not an object.
	 */
	constructor(gcPlatformAPIClient) {
		// Check the Genesys Cloud Platform API client instance argument
		if (typeof gcPlatformAPIClient !== "object" || symbols.GCPlatformAPIClient in gcPlatformAPIClient === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_INSTANCE_TYPE_INVALID();
		}

		// Initialize the instance properties
		this.#gcPlatformAPIClient = gcPlatformAPIClient;
	}

	/**
	 * Query for evaluation aggregates
	 * @async
	 * @param {EvaluationAggregationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/evaluations/aggregates/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsEvaluationsAggregatesQuery(body) {
		const endpointPath = "/api/v2/analytics/evaluations/aggregates/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for survey aggregates
	 * @async
	 * @param {SurveyAggregationQuery} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/analytics/surveys/aggregates/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postAnalyticsSurveysAggregatesQuery(body) {
		const endpointPath = "/api/v2/analytics/surveys/aggregates/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a survey as an end-customer, for the purposes of scoring it.
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} query.customerSurveyUrl -  customerSurveyUrl
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/surveys/scorable" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING} If a required query string parameter is missing.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getQualitySurveysScorable(query) {
		const endpointPath = "/api/v2/quality/surveys/scorable";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object" || query === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, true);
		}

		if ("customerSurveyUrl" in query === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING(endpointPath, endpointMethod, "customerSurveyUrl");
		}

		if (this.#checkJSONSchemaType(query["customerSurveyUrl"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "customerSurveyUrl", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a survey as an end-customer, for the purposes of scoring it.
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} query.customerSurveyUrl -  customerSurveyUrl
	 * @param {ScorableSurvey} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/surveys/scorable" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING} If a required query string parameter is missing.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putQualitySurveysScorable(query, body) {
		const endpointPath = "/api/v2/quality/surveys/scorable";
		const endpointMethod = "PUT";

		// Check the query string parameters
		if (typeof query !== "object" || query === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, true);
		}

		if ("customerSurveyUrl" in query === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING(endpointPath, endpointMethod, "customerSurveyUrl");
		}

		if (this.#checkJSONSchemaType(query["customerSurveyUrl"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "customerSurveyUrl", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Gets a list of Agent Activities
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  The total page size requested
	 * @param {number} [query.pageNumber] -  The page number requested
	 * @param {string} [query.sortBy] -  variable name requested to sort by
	 * @param {string[]} [query.expand] -  variable name requested by expand list
	 * @param {string} [query.nextPage] -  next page token
	 * @param {string} [query.previousPage] -  Previous page token
	 * @param {string} [query.startTime] -  Start time of agent activity based on assigned date. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	 * @param {string} [query.endTime] -  End time of agent activity based on assigned date. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	 * @param {string[]} [query.agentUserId] -  user id of agent requested
	 * @param {string} [query.evaluatorUserId] -  user id of the evaluator
	 * @param {string} [query.name] -  name
	 * @param {string} [query.group] -  group id
	 * @param {string} [query.agentTeamId] -  team id of agents requested
	 * @param {string} [query.formContextId] -  shared id between form versions
	 * @param {string} [query.userState] -  'Legacy' fetches active and inactive users when evaluatorUserId or no user filters are supplied; otherwise fetches active users. 
'Any' fetches users of 'active', 'inactive' and 'deleted' states.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/agents/activity" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getQualityAgentsActivity(query) {
		const endpointPath = "/api/v2/quality/agents/activity";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("sortBy" in query && this.#checkJSONSchemaType(query["sortBy"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortBy", "string");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "array");
			}
			if ("nextPage" in query && this.#checkJSONSchemaType(query["nextPage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "nextPage", "string");
			}
			if ("previousPage" in query && this.#checkJSONSchemaType(query["previousPage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "previousPage", "string");
			}
			if ("startTime" in query && this.#checkJSONSchemaType(query["startTime"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "startTime", "string");
			}
			if ("endTime" in query && this.#checkJSONSchemaType(query["endTime"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "endTime", "string");
			}
			if ("agentUserId" in query && this.#checkJSONSchemaType(query["agentUserId"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "agentUserId", "array");
			}
			if ("evaluatorUserId" in query && this.#checkJSONSchemaType(query["evaluatorUserId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "evaluatorUserId", "string");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
			if ("group" in query && this.#checkJSONSchemaType(query["group"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "group", "string");
			}
			if ("agentTeamId" in query && this.#checkJSONSchemaType(query["agentTeamId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "agentTeamId", "string");
			}
			if ("formContextId" in query && this.#checkJSONSchemaType(query["formContextId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "formContextId", "string");
			}
			if ("userState" in query && this.#checkJSONSchemaType(query["userState"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "userState", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a calibration by id.  Requires either calibrator id or conversation id
	 * @async
	 * @param {string} calibrationId - Calibration ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.calibratorId] -  calibratorId
	 * @param {string} [query.conversationId] -  conversationId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/calibrations/{calibrationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getQualityCalibration(calibrationId, query) {
		const endpointPath = "/api/v2/quality/calibrations/{calibrationId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(calibrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "calibrationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("calibratorId" in query && this.#checkJSONSchemaType(query["calibratorId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "calibratorId", "string");
			}
			if ("conversationId" in query && this.#checkJSONSchemaType(query["conversationId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.calibrationId = calibrationId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a calibration to the specified calibration via PUT.  Editable fields include: evaluators, expertEvaluator, and scoringIndex
	 * @async
	 * @param {string} calibrationId - Calibration ID
	 * @param {Calibration} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/calibrations/{calibrationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putQualityCalibration(calibrationId, body) {
		const endpointPath = "/api/v2/quality/calibrations/{calibrationId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(calibrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "calibrationId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.calibrationId = calibrationId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a calibration by id.
	 * @async
	 * @param {string} calibrationId - Calibration ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} query.calibratorId -  calibratorId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/calibrations/{calibrationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING} If a required query string parameter is missing.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	deleteQualityCalibration(calibrationId, query) {
		const endpointPath = "/api/v2/quality/calibrations/{calibrationId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(calibrationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "calibrationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object" || query === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, true);
		}

		if ("calibratorId" in query === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING(endpointPath, endpointMethod, "calibratorId");
		}

		if (this.#checkJSONSchemaType(query["calibratorId"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "calibratorId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.calibrationId = calibrationId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the list of calibrations
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  The total page size requested
	 * @param {number} [query.pageNumber] -  The page number requested
	 * @param {string} [query.sortBy] -  variable name requested to sort by
	 * @param {string[]} [query.expand] -  variable name requested by expand list
	 * @param {string} [query.nextPage] -  next page token
	 * @param {string} [query.previousPage] -  Previous page token
	 * @param {string} [query.conversationId] -  conversation id
	 * @param {string} [query.startTime] -  Beginning of the calibration query. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	 * @param {string} [query.endTime] -  end of the calibration query. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	 * @param {string} query.calibratorId -  user id of calibrator
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/calibrations" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING} If a required query string parameter is missing.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getQualityCalibrations(query) {
		const endpointPath = "/api/v2/quality/calibrations";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object" || query === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, true);
		}

		if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
		}

		if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
		}

		if ("sortBy" in query && this.#checkJSONSchemaType(query["sortBy"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortBy", "string");
		}

		if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "array") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "array");
		}

		if ("nextPage" in query && this.#checkJSONSchemaType(query["nextPage"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "nextPage", "string");
		}

		if ("previousPage" in query && this.#checkJSONSchemaType(query["previousPage"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "previousPage", "string");
		}

		if ("conversationId" in query && this.#checkJSONSchemaType(query["conversationId"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if ("startTime" in query && this.#checkJSONSchemaType(query["startTime"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "startTime", "string");
		}

		if ("endTime" in query && this.#checkJSONSchemaType(query["endTime"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "endTime", "string");
		}

		if ("calibratorId" in query === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING(endpointPath, endpointMethod, "calibratorId");
		}

		if (this.#checkJSONSchemaType(query["calibratorId"], "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "calibratorId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a calibration
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.expand] -  calibratorId
	 * @param {CalibrationCreate} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/calibrations" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postQualityCalibrations(query, body) {
		const endpointPath = "/api/v2/quality/calibrations";
		const endpointMethod = "POST";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create audit query execution
	 * @async
	 * @param {QMAuditQueryRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/conversations/audits/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postQualityConversationsAuditsQuery(body) {
		const endpointPath = "/api/v2/quality/conversations/audits/query";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get status of audit query execution
	 * @async
	 * @param {string} transactionId - Transaction ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/conversations/audits/query/{transactionId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getQualityConversationsAuditsQueryTransactionId(transactionId) {
		const endpointPath = "/api/v2/quality/conversations/audits/query/{transactionId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(transactionId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "transactionId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.transactionId = transactionId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get results of audit query
	 * @async
	 * @param {string} transactionId - Transaction ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.cursor] -  Indicates where to resume query results (not required for first page)
	 * @param {number} [query.pageSize] -  Page size
	 * @param {string[]} [query.expand] -  Which fields, if any, to expand
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/conversations/audits/query/{transactionId}/results" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getQualityConversationsAuditsQueryTransactionIdResults(transactionId, query) {
		const endpointPath = "/api/v2/quality/conversations/audits/query/{transactionId}/results";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(transactionId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "transactionId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("cursor" in query && this.#checkJSONSchemaType(query["cursor"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "cursor", "string");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.transactionId = transactionId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get an evaluation
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} evaluationId - evaluationId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.expand] -  agent, assignee, evaluator, evaluationForm
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/conversations/{conversationId}/evaluations/{evaluationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getQualityConversationEvaluation(conversationId, evaluationId, query) {
		const endpointPath = "/api/v2/quality/conversations/{conversationId}/evaluations/{evaluationId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(evaluationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "evaluationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.evaluationId = evaluationId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update an evaluation
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} evaluationId - evaluationId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.expand] -  evaluatorId, evaluationForm, assignee, evaluator
	 * @param {Evaluation} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/conversations/{conversationId}/evaluations/{evaluationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putQualityConversationEvaluation(conversationId, evaluationId, query, body) {
		const endpointPath = "/api/v2/quality/conversations/{conversationId}/evaluations/{evaluationId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(evaluationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "evaluationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.evaluationId = evaluationId;
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete an evaluation
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {string} evaluationId - evaluationId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.expand] -  evaluatorId, evaluationForm
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/conversations/{conversationId}/evaluations/{evaluationId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	deleteQualityConversationEvaluation(conversationId, evaluationId, query) {
		const endpointPath = "/api/v2/quality/conversations/{conversationId}/evaluations/{evaluationId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		if (this.#checkJSONSchemaType(evaluationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "evaluationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.pathParameters.evaluationId = evaluationId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create an evaluation
	 * @async
	 * @param {string} conversationId - conversationId
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.expand] -  evaluatorId
	 * @param {EvaluationCreateBody} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/conversations/{conversationId}/evaluations" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postQualityConversationEvaluations(conversationId, query, body) {
		const endpointPath = "/api/v2/quality/conversations/{conversationId}/evaluations";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the surveys for a conversation
	 * @async
	 * @param {string} conversationId - conversationId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/conversations/{conversationId}/surveys" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getQualityConversationSurveys(conversationId) {
		const endpointPath = "/api/v2/quality/conversations/{conversationId}/surveys";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(conversationId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.conversationId = conversationId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Query for evaluation aggregates for the current user
	 * @async
	 * @param {EvaluationAggregationQueryMe} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/evaluations/aggregates/query/me" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postQualityEvaluationsAggregatesQueryMe(body) {
		const endpointPath = "/api/v2/quality/evaluations/aggregates/query/me";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update the AI Scoring settings of an evaluation form.
	 * @async
	 * @param {string} formId - Form ID
	 * @param {AiScoringSettings} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms/evaluations/{formId}/aiscoring/settings" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putQualityFormsEvaluationAiscoringSettings(formId, body) {
		const endpointPath = "/api/v2/quality/forms/evaluations/{formId}/aiscoring/settings";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(formId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "formId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.formId = formId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get an evaluation form
	 * @async
	 * @param {string} formId - Form ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms/evaluations/{formId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getQualityFormsEvaluation(formId) {
		const endpointPath = "/api/v2/quality/forms/evaluations/{formId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(formId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "formId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.formId = formId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update an evaluation form.
	 * @async
	 * @param {string} formId - Form ID
	 * @param {EvaluationForm} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms/evaluations/{formId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putQualityFormsEvaluation(formId, body) {
		const endpointPath = "/api/v2/quality/forms/evaluations/{formId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(formId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "formId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.formId = formId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete an evaluation form.
	 * @async
	 * @param {string} formId - Form ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms/evaluations/{formId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteQualityFormsEvaluation(formId) {
		const endpointPath = "/api/v2/quality/forms/evaluations/{formId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(formId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "formId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.formId = formId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Gets all the revisions for a specific evaluation.
	 * @async
	 * @param {string} formId - Form ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.sortOrder] -  Sort order
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms/evaluations/{formId}/versions" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getQualityFormsEvaluationVersions(formId, query) {
		const endpointPath = "/api/v2/quality/forms/evaluations/{formId}/versions";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(formId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "formId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("sortOrder" in query && this.#checkJSONSchemaType(query["sortOrder"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortOrder", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.formId = formId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Retrieve a list of the latest published evaluation form versions by context ids
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string[]} query.contextId -  A comma-delimited list of valid evaluation form context ids
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms/evaluations/bulk/contexts" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING} If a required query string parameter is missing.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getQualityFormsEvaluationsBulkContexts(query) {
		const endpointPath = "/api/v2/quality/forms/evaluations/bulk/contexts";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object" || query === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, true);
		}

		if ("contextId" in query === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING(endpointPath, endpointMethod, "contextId");
		}

		if (this.#checkJSONSchemaType(query["contextId"], "array") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "contextId", "array");
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the list of evaluation forms
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  The total page size requested
	 * @param {number} [query.pageNumber] -  The page number requested
	 * @param {string} [query.sortBy] -  variable name requested to sort by
	 * @param {string} [query.nextPage] -  next page token
	 * @param {string} [query.previousPage] -  Previous page token
	 * @param {string} [query.expand] -  If 'expand=publishHistory', then each unpublished evaluation form includes a listing of its published versions
	 * @param {string} [query.name] -  Name
	 * @param {string} [query.sortOrder] -  Order to sort results, either asc or desc
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms/evaluations" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getQualityFormsEvaluations(query) {
		const endpointPath = "/api/v2/quality/forms/evaluations";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("sortBy" in query && this.#checkJSONSchemaType(query["sortBy"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortBy", "string");
			}
			if ("nextPage" in query && this.#checkJSONSchemaType(query["nextPage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "nextPage", "string");
			}
			if ("previousPage" in query && this.#checkJSONSchemaType(query["previousPage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "previousPage", "string");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
			if ("sortOrder" in query && this.#checkJSONSchemaType(query["sortOrder"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortOrder", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create an evaluation form.
	 * @async
	 * @param {EvaluationForm} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms/evaluations" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postQualityFormsEvaluations(body) {
		const endpointPath = "/api/v2/quality/forms/evaluations";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Queries Evaluations and returns a paged list
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  The total page size requested
	 * @param {number} [query.pageNumber] -  The page number requested
	 * @param {string[]} [query.expand] -  variable name requested by expand list
	 * @param {string} [query.previousPage] -  Previous page token
	 * @param {string} [query.conversationId] -  conversationId specified
	 * @param {string} [query.agentUserId] -  user id of the agent
	 * @param {string} [query.agentTeamId] -  team id of the agent
	 * @param {string} [query.evaluatorUserId] -  evaluator user id
	 * @param {string} [query.assigneeUserId] -  assignee user id
	 * @param {string} [query.queueId] -  queue id
	 * @param {string} [query.startTime] -  start time of the evaluation query
	 * @param {string} [query.endTime] -  end time of the evaluation query
	 * @param {string} [query.formContextId] -  shared id between form versions
	 * @param {string[]} [query.evaluationState] -  
	 * @param {boolean} [query.isReleased] -  the evaluation has been released
	 * @param {boolean} [query.agentHasRead] -  agent has the evaluation
	 * @param {boolean} [query.expandAnswerTotalScores] -  get the total scores for evaluations. NOTE: The answers will only be populated if this parameter is set to true in the request.
	 * @param {number} [query.maximum] -  the maximum number of results to return
	 * @param {string} [query.sortOrder] -  NOTE: Does not work when conversationId is supplied.
	 * @param {boolean} [query.includeDeletedUsers] -  Allow returning an agent or evaluator user with a 'delete' status. Defaults to false.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/evaluations/query" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getQualityEvaluationsQuery(query) {
		const endpointPath = "/api/v2/quality/evaluations/query";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "array");
			}
			if ("previousPage" in query && this.#checkJSONSchemaType(query["previousPage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "previousPage", "string");
			}
			if ("conversationId" in query && this.#checkJSONSchemaType(query["conversationId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "conversationId", "string");
			}
			if ("agentUserId" in query && this.#checkJSONSchemaType(query["agentUserId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "agentUserId", "string");
			}
			if ("agentTeamId" in query && this.#checkJSONSchemaType(query["agentTeamId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "agentTeamId", "string");
			}
			if ("evaluatorUserId" in query && this.#checkJSONSchemaType(query["evaluatorUserId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "evaluatorUserId", "string");
			}
			if ("assigneeUserId" in query && this.#checkJSONSchemaType(query["assigneeUserId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "assigneeUserId", "string");
			}
			if ("queueId" in query && this.#checkJSONSchemaType(query["queueId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "queueId", "string");
			}
			if ("startTime" in query && this.#checkJSONSchemaType(query["startTime"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "startTime", "string");
			}
			if ("endTime" in query && this.#checkJSONSchemaType(query["endTime"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "endTime", "string");
			}
			if ("formContextId" in query && this.#checkJSONSchemaType(query["formContextId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "formContextId", "string");
			}
			if ("evaluationState" in query && this.#checkJSONSchemaType(query["evaluationState"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "evaluationState", "array");
			}
			if ("isReleased" in query && this.#checkJSONSchemaType(query["isReleased"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "isReleased", "boolean");
			}
			if ("agentHasRead" in query && this.#checkJSONSchemaType(query["agentHasRead"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "agentHasRead", "boolean");
			}
			if ("expandAnswerTotalScores" in query && this.#checkJSONSchemaType(query["expandAnswerTotalScores"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expandAnswerTotalScores", "boolean");
			}
			if ("maximum" in query && this.#checkJSONSchemaType(query["maximum"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "maximum", "integer");
			}
			if ("sortOrder" in query && this.#checkJSONSchemaType(query["sortOrder"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortOrder", "string");
			}
			if ("includeDeletedUsers" in query && this.#checkJSONSchemaType(query["includeDeletedUsers"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "includeDeletedUsers", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Score evaluation
	 * @async
	 * @param {EvaluationFormAndScoringSet} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/evaluations/scoring" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postQualityEvaluationsScoring(body) {
		const endpointPath = "/api/v2/quality/evaluations/scoring";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get an evaluator activity
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  The total page size requested
	 * @param {number} [query.pageNumber] -  The page number requested
	 * @param {string} [query.sortBy] -  variable name requested to sort by
	 * @param {string[]} [query.expand] -  variable name requested by expand list
	 * @param {string} [query.nextPage] -  next page token
	 * @param {string} [query.previousPage] -  Previous page token
	 * @param {string} [query.startTime] -  The start time specified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	 * @param {string} [query.endTime] -  The end time specified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	 * @param {string} [query.name] -  Evaluator name
	 * @param {string[]} [query.permission] -  permission strings
	 * @param {string} [query.group] -  group id
	 * @param {string} [query.agentTeamId] -  team id of agents to be considered
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/evaluators/activity" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getQualityEvaluatorsActivity(query) {
		const endpointPath = "/api/v2/quality/evaluators/activity";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("sortBy" in query && this.#checkJSONSchemaType(query["sortBy"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortBy", "string");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "array");
			}
			if ("nextPage" in query && this.#checkJSONSchemaType(query["nextPage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "nextPage", "string");
			}
			if ("previousPage" in query && this.#checkJSONSchemaType(query["previousPage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "previousPage", "string");
			}
			if ("startTime" in query && this.#checkJSONSchemaType(query["startTime"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "startTime", "string");
			}
			if ("endTime" in query && this.#checkJSONSchemaType(query["endTime"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "endTime", "string");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
			if ("permission" in query && this.#checkJSONSchemaType(query["permission"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "permission", "array");
			}
			if ("group" in query && this.#checkJSONSchemaType(query["group"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "group", "string");
			}
			if ("agentTeamId" in query && this.#checkJSONSchemaType(query["agentTeamId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "agentTeamId", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the most recent published version of an evaluation form.
	 * @async
	 * @param {string} formId - Form ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/publishedforms/evaluations/{formId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getQualityPublishedformsEvaluation(formId) {
		const endpointPath = "/api/v2/quality/publishedforms/evaluations/{formId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(formId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "formId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.formId = formId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the published evaluation forms.
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.name] -  Name
	 * @param {boolean} [query.onlyLatestPerContext] -  onlyLatestPerContext
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/publishedforms/evaluations" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getQualityPublishedformsEvaluations(query) {
		const endpointPath = "/api/v2/quality/publishedforms/evaluations";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
			if ("onlyLatestPerContext" in query && this.#checkJSONSchemaType(query["onlyLatestPerContext"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "onlyLatestPerContext", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Publish an evaluation form.
	 * @async
	 * @param {PublishForm} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/publishedforms/evaluations" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postQualityPublishedformsEvaluations(body) {
		const endpointPath = "/api/v2/quality/publishedforms/evaluations";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the most recent published version of a survey form.
	 * @async
	 * @param {string} formId - Form ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/publishedforms/surveys/{formId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getQualityPublishedformsSurvey(formId) {
		const endpointPath = "/api/v2/quality/publishedforms/surveys/{formId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(formId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "formId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.formId = formId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the published survey forms.
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.name] -  Name
	 * @param {boolean} [query.onlyLatestEnabledPerContext] -  onlyLatestEnabledPerContext
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/publishedforms/surveys" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getQualityPublishedformsSurveys(query) {
		const endpointPath = "/api/v2/quality/publishedforms/surveys";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
			if ("onlyLatestEnabledPerContext" in query && this.#checkJSONSchemaType(query["onlyLatestEnabledPerContext"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "onlyLatestEnabledPerContext", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Publish a survey form.
	 * @async
	 * @param {PublishForm} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/publishedforms/surveys" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postQualityPublishedformsSurveys(body) {
		const endpointPath = "/api/v2/quality/publishedforms/surveys";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a survey form
	 * @async
	 * @param {string} formId - Form ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms/surveys/{formId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getQualityFormsSurvey(formId) {
		const endpointPath = "/api/v2/quality/forms/surveys/{formId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(formId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "formId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.formId = formId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update a survey form.
	 * @async
	 * @param {string} formId - Form ID
	 * @param {SurveyForm} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms/surveys/{formId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putQualityFormsSurvey(formId, body) {
		const endpointPath = "/api/v2/quality/forms/surveys/{formId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(formId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "formId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.formId = formId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a survey form.
	 * @async
	 * @param {string} formId - Form ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms/surveys/{formId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteQualityFormsSurvey(formId) {
		const endpointPath = "/api/v2/quality/forms/surveys/{formId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(formId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "formId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.formId = formId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Disable a particular version of a survey form and invalidates any invitations that have already been sent to customers using this version of the form.
	 * @async
	 * @param {string} formId - Form ID
	 * @param {SurveyForm} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms/surveys/{formId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchQualityFormsSurvey(formId, body) {
		const endpointPath = "/api/v2/quality/forms/surveys/{formId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(formId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "formId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.formId = formId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Gets all the revisions for a specific survey.
	 * @async
	 * @param {string} formId - Form ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms/surveys/{formId}/versions" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getQualityFormsSurveyVersions(formId, query) {
		const endpointPath = "/api/v2/quality/forms/surveys/{formId}/versions";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(formId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "formId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.formId = formId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Retrieve a list of survey forms by their ids
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string[]} query.id -  A comma-delimited list of valid survey form ids
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms/surveys/bulk" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING} If a required query string parameter is missing.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getQualityFormsSurveysBulk(query) {
		const endpointPath = "/api/v2/quality/forms/surveys/bulk";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object" || query === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, true);
		}

		if ("id" in query === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING(endpointPath, endpointMethod, "id");
		}

		if (this.#checkJSONSchemaType(query["id"], "array") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "id", "array");
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Retrieve a list of the latest form versions by context ids
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string[]} query.contextId -  A comma-delimited list of valid survey form context ids. The maximum number of ids allowed in this list is 100.
	 * @param {boolean} [query.published] -  If true, the latest published version will be included. If false, only the unpublished version will be included.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms/surveys/bulk/contexts" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING} If a required query string parameter is missing.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getQualityFormsSurveysBulkContexts(query) {
		const endpointPath = "/api/v2/quality/forms/surveys/bulk/contexts";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object" || query === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, true);
		}

		if ("contextId" in query === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_MISSING(endpointPath, endpointMethod, "contextId");
		}

		if (this.#checkJSONSchemaType(query["contextId"], "array") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "contextId", "array");
		}

		if ("published" in query && this.#checkJSONSchemaType(query["published"], "boolean") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "published", "boolean");
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the list of survey forms. If you set "expand=publishHistory", then you will be able to get published versions for each corresponding survey form.
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  The total page size requested
	 * @param {number} [query.pageNumber] -  The page number requested
	 * @param {string} [query.sortBy] -  variable name requested to sort by
	 * @param {string} [query.nextPage] -  next page token
	 * @param {string} [query.previousPage] -  Previous page token
	 * @param {string} [query.expand] -  If 'expand=publishHistory', then each unpublished evaluation form includes a listing of its published versions
	 * @param {string} [query.name] -  Name
	 * @param {string} [query.sortOrder] -  Order to sort results, either asc or desc
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms/surveys" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getQualityFormsSurveys(query) {
		const endpointPath = "/api/v2/quality/forms/surveys";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("sortBy" in query && this.#checkJSONSchemaType(query["sortBy"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortBy", "string");
			}
			if ("nextPage" in query && this.#checkJSONSchemaType(query["nextPage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "nextPage", "string");
			}
			if ("previousPage" in query && this.#checkJSONSchemaType(query["previousPage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "previousPage", "string");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
			if ("sortOrder" in query && this.#checkJSONSchemaType(query["sortOrder"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortOrder", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a survey form.
	 * @async
	 * @param {SurveyForm} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms/surveys" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postQualityFormsSurveys(body) {
		const endpointPath = "/api/v2/quality/forms/surveys";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get a survey for a conversation
	 * @async
	 * @param {string} surveyId - surveyId
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/surveys/{surveyId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getQualitySurvey(surveyId) {
		const endpointPath = "/api/v2/quality/surveys/{surveyId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(surveyId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "surveyId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.surveyId = surveyId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Score survey
	 * @async
	 * @param {SurveyFormAndScoringSet} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/surveys/scoring" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postQualitySurveysScoring(body) {
		const endpointPath = "/api/v2/quality/surveys/scoring";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get an evaluation form
	 * @async
	 * @param {string} formId - Form ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms/{formId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @deprecated
	 */
	getQualityForm(formId) {
		const endpointPath = "/api/v2/quality/forms/{formId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(formId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "formId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.formId = formId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update an evaluation form.
	 * @async
	 * @param {string} formId - Form ID
	 * @param {EvaluationForm} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms/{formId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	putQualityForm(formId, body) {
		const endpointPath = "/api/v2/quality/forms/{formId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(formId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "formId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.formId = formId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete an evaluation form.
	 * @async
	 * @param {string} formId - Form ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms/{formId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @deprecated
	 */
	deleteQualityForm(formId) {
		const endpointPath = "/api/v2/quality/forms/{formId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(formId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "formId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.formId = formId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Gets all the revisions for a specific evaluation.
	 * @async
	 * @param {string} formId - Form ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms/{formId}/versions" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @deprecated
	 */
	getQualityFormVersions(formId, query) {
		const endpointPath = "/api/v2/quality/forms/{formId}/versions";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(formId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "formId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.formId = formId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the list of evaluation forms. If you set "expand=publishHistory", then you will be able to get published versions for each corresponding evaluation form.
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  The total page size requested
	 * @param {number} [query.pageNumber] -  The page number requested
	 * @param {string} [query.sortBy] -  variable name requested to sort by
	 * @param {string} [query.nextPage] -  next page token
	 * @param {string} [query.previousPage] -  Previous page token
	 * @param {string} [query.expand] -  If 'expand=publishHistory', then each unpublished evaluation form includes a listing of its published versions
	 * @param {string} [query.name] -  Name
	 * @param {string} [query.sortOrder] -  Order to sort results, either asc or desc
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @deprecated
	 */
	getQualityForms(query) {
		const endpointPath = "/api/v2/quality/forms";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("sortBy" in query && this.#checkJSONSchemaType(query["sortBy"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortBy", "string");
			}
			if ("nextPage" in query && this.#checkJSONSchemaType(query["nextPage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "nextPage", "string");
			}
			if ("previousPage" in query && this.#checkJSONSchemaType(query["previousPage"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "previousPage", "string");
			}
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
			if ("sortOrder" in query && this.#checkJSONSchemaType(query["sortOrder"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "sortOrder", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create an evaluation form.
	 * @async
	 * @param {EvaluationForm} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/forms" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	postQualityForms(body) {
		const endpointPath = "/api/v2/quality/forms";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the published evaluation forms.
	 * @async
	 * @param {string} formId - Form ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/publishedforms/{formId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @deprecated
	 */
	getQualityPublishedform(formId) {
		const endpointPath = "/api/v2/quality/publishedforms/{formId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(formId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "formId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.formId = formId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get the published evaluation forms.
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageSize] -  Page size
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {string} [query.name] -  Name
	 * @param {boolean} [query.onlyLatestPerContext] -  onlyLatestPerContext
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/publishedforms" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @deprecated
	 */
	getQualityPublishedforms(query) {
		const endpointPath = "/api/v2/quality/publishedforms";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("name" in query && this.#checkJSONSchemaType(query["name"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "name", "string");
			}
			if ("onlyLatestPerContext" in query && this.#checkJSONSchemaType(query["onlyLatestPerContext"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "onlyLatestPerContext", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Publish an evaluation form.
	 * @async
	 * @param {PublishForm} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/quality/publishedforms" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 * @deprecated
	 */
	postQualityPublishedforms(body) {
		const endpointPath = "/api/v2/quality/publishedforms";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * @description Checks that a value is of the proper JSON schema type
	 * @param {*} value - The value to check
	 * @param {string} jsonSchemaType - The JSON schema type to check against
	 * @returns {boolean} Returns true if the value is of the proper JSON schema type, false otherwise
	 */
	#checkJSONSchemaType(value, jsonSchemaType) {
		const PASSTHROUGH_JSON_SCHEMA_TYPES = ["boolean", "number", "string", "object"];

		// Check if the type is a passthrough type
		if (PASSTHROUGH_JSON_SCHEMA_TYPES.includes(jsonSchemaType)) {
			return typeof value === jsonSchemaType;
		}

		// Check if the type is an integer
		if (jsonSchemaType === "integer") {
			return Number.isInteger(value);
		}

		// Check if the type is an array
		if (jsonSchemaType === "array") {
			return Array.isArray(value);
		}

		// Check if the type is null
		if (jsonSchemaType === "null") {
			return value === null;
		}

		// Otherwise, return false
		return false;
	}
}

export { QualityAPI };