/**
 * Language Understanding
 * @module gc-platform-api-language-understanding
 * @documentation https://developer.genesys.cloud/organization/languageunderstanding/languageunderstanding-apis
 * @license MIT
 */

// This file was automatically generated by the Generate Genesys Cloud Platform API classes utility on 2025-04-24T15:04:25.279Z

// TODO: Implement JSON schema verification for input and output objects
// TODO: Implement HTTP response typedefs

// Set strict mode
"use strict";

// Errors
import { errors } from "../gc-platform-api-client-errors.js";

// Symbols
import { symbols } from "../gc-platform-api-client-symbols.js";

/** @typedef {import("../gc-platform-api-client-class.js").GCPlatformAPIClient} GCPlatformAPIClient */
/** @typedef {import("@jfabello/http-client").HTTPResponse} HTTPResponse */

/**
 * @typedef {object} ContextEntity
 * @property {string} name - The name of the entity.
 */
 
/**
 * @typedef {object} ContextIntent
 * @property {string} name - The name of the intent.
 */
 
/**
 * @typedef {object} DetectedNamedEntity
 * @property {string} [name] - The name of the detected named entity.
 * @property {string} [entityType] - The type of the detected named entity.
 * @property {number} [probability] - The probability of the detected named entity.
 * @property {DetectedNamedEntityValue} [value] - The value of the detected named entity.
 */
 
/**
 * @typedef {object} DetectedNamedEntityValue
 * @property {string} [raw] - The raw value of the detected named entity.
 * @property {string} [resolved] - The resolved value of the detected named entity.
 * @property {string} [unit] - The unit of the detected amount of money entity, e.g. EUR, USD.
 */
 
/**
 * @typedef {object} Draft
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - Draft name
 * @property {Miner} [miner] - Miner to which the draft belongs.
 * @property {DraftIntents[]} [intents] - Draft intent object.
 * @property {DraftTopics[]} [topics] - Draft topic object.
 * @property {string} [dateCreated] - Date when the draft was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateModified] - Date when the draft was updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} DraftIntents
 * @property {string} id - Id for an intent.
 * @property {string} name - Name/Label for an intent.
 * @property {string[]} utterances - The utterances that are extracted for an Intent.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} DraftRequest
 * @property {DraftIntents[]} [intents] - Draft intent object.
 * @property {DraftTopicRequest[]} [topics] - Draft topic object.
 */
 
/**
 * @typedef {object} DraftTopicRequest
 * @property {string} id - Id for a topic.
 * @property {string} name - Name/Label for a topic.
 * @property {string[]} phrases - The phrases that are extracted for a topic.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} DraftTopics
 * @property {string} id - Id for a topic.
 * @property {string} [name] - Topic name.
 * @property {Miner} [miner] - The miner to which the topic belongs.
 * @property {number} [conversationCount] - Number of conversations where a topic has occurred.
 * @property {number} [conversationPercent] - Percentage of conversations where a topic has occurred.
 * @property {number} [utteranceCount] - Number of unique utterances where a topic has occurred.
 * @property {number} [phraseCount] - Number of unique phrases (sub-utterances) where a topic has occurred.
 * @property {string[]} phrases - The phrases that are extracted for a topic.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} IntentDefinition
 * @property {string} [id] - ID of the intent.
 * @property {string} name - The name of the intent.
 * @property {string} [description] - The description of the intent.
 * @property {NamedEntityTypeBinding[]} [entityTypeBindings] - The bindings for the named entity types used in this intent.This field is mutually exclusive with entityNameReferences and entities
 * @property {string[]} [entityNameReferences] - The references for the named entity used in this intent.This field is mutually exclusive with entityTypeBindings
 * @property {NluUtterance[]} utterances - The utterances that act as training phrases for the intent.
 * @property {object} [additionalLanguages] - Additional languages for intents
 */
 
/**
 * @typedef {object} IntentFeedback
 * @property {string} [name] - The name of the detected intent.
 * @property {number} [probability] - The probability of the detected intent.
 * @property {DetectedNamedEntity[]} [entities] - The collection of named entities detected.
 * @property {string} [assessment] - The assessment on the detection for feedback text.
 */
 
/**
 * @typedef {object} Miner
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - Chat Corpus Name.
 * @property {string} [language] - Language Localization code.
 * @property {string} [minerType] - Type of the miner, intent or topic.
 * @property {string} [dateCreated] - Date when the miner was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [status] - Status of the miner.
 * @property {string} [conversationsDateRangeStart] - Date from which the conversations need to be taken for mining. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd
 * @property {string} [conversationsDateRangeEnd] - Date till which the conversations need to be taken for mining. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd
 * @property {string} [dateCompleted] - Date when the mining process was completed. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [message] - Mining message if present.
 * @property {MinerErrorInfo} [errorInfo] - Error Information
 * @property {MinerErrorInfo} [warningInfo] - Warning Information
 * @property {boolean} [conversationDataUploaded] - Flag to indicate whether data file to be mined was uploaded.
 * @property {string} [mediaType] - Media type for filtering conversations.
 * @property {string} [participantType] - Type of the participant, either agent, customer or both.
 * @property {string[]} [queueIds] - List of queue IDs for filtering conversations.
 * @property {string} [dateTriggered] - Date when the miner started execution. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateModified] - Date when the miner was last modified. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {Draft} [latestDraftVersion] - Latest draft details of the miner.
 * @property {number} [conversationsFetchedCount] - Number of conversations/transcripts fetched.
 * @property {number} [conversationsValidCount] - Number of conversations/recordings/transcripts that were found valid for mining purposes.
 * @property {number} [getminedItemCount] - Number of intents or topics based on the miner type.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} MinerErrorInfo
 * @property {string} [message]
 * @property {string} [code]
 * @property {string} [messageWithParams] - Error message with params included.
 * @property {object} [messageParams] - Map of variables and params for the error message.
 */
 
/**
 * @typedef {object} MinerExecuteRequest
 * @property {string} [dateStart] - Start date for the date range to mine. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd
 * @property {string} [dateEnd] - End date for the date range to mine. Dates are represented as an ISO-8601 string. For example: yyyy-MM-dd
 * @property {string} [uploadKey] - Location of input conversations.
 * @property {string} [mediaType] - Media type for filtering conversations.
 * @property {string} [participantType] - Type of the participant, either agent, customer or both.
 * @property {string[]} [queueIds] - List of queue IDs for filtering conversations.
 */
 
/**
 * @typedef {object} NamedEntityAnnotation
 * @property {string} name - The name of the annotated named entity.
 */
 
/**
 * @typedef {object} NamedEntityDefinition
 * @property {string} name - The name of the entity.
 * @property {string} type - The name of the entity type.
 */
 
/**
 * @typedef {object} NamedEntityTypeBinding
 * @property {string} entityType - The named entity type of the binding. It can be a built-in one such as builtin:number or a custom entity type such as BeverageType.
 * @property {string} entityName - The name that this named entity type is bound to.
 */
 
/**
 * @typedef {object} NamedEntityTypeDefinition
 * @property {string} name - The name of the entity type.
 * @property {string} [description] - Description of the of the named entity type.
 * @property {NamedEntityTypeMechanism} mechanism - The mechanism enabling detection of the named entity type.
 */
 
/**
 * @typedef {object} NamedEntityTypeItem
 * @property {string} value - A value for an named entity type definition.
 * @property {string[]} [synonyms] - Synonyms for the given named entity value.
 * @property {object} [additionalLanguages] - Additional Language Synonyms for the given named entity value.
 */
 
/**
 * @typedef {object} NamedEntityTypeMechanism
 * @property {NamedEntityTypeItem[]} items - The items that define the named entity type.
 * @property {boolean} [restricted] - Whether the named entity type is restricted to the items provided. Default: false
 * @property {string} type - The type of the mechanism.
 * @property {string} [subType] - Subtype of detection mechanism
 * @property {number} [maxLength] - The maximum length of the entity resolved value
 * @property {number} [minLength] - The minimum length of the entity resolved value
 * @property {NamedEntityTypeMechanismExample[]} [examples] - Examples for entity detection
 */
 
/**
 * @typedef {object} NamedEntityTypeMechanismExample
 * @property {string} text - Example input text
 * @property {string} resolvedValue - Resolved entity value
 */
 
/**
 * @typedef {object} NluDetectionContext
 * @property {ContextIntent} [intent] - Restrict detection to this intent.
 * @property {ContextEntity} [entity] - Use this entity to restrict detection.
 */
 
/**
 * @typedef {object} NluDetectionInput
 * @property {string} text - The text to perform NLU detection on.
 * @property {string} [language] - Language of the version for multilingual detection, e.g. `en-us`, `de-de`
 */
 
/**
 * @typedef {object} NluDetectionRequest
 * @property {NluDetectionInput} input - The input subject to NLU detection.
 * @property {NluDetectionContext} [context] - The context for the input to NLU detection.
 */
 
/**
 * @typedef {object} NluDomain
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {string} name - The name of the NLU domain.
 * @property {string} [language] - The language culture of the NLU domain, e.g. `en-us`, `de-de`.
 * @property {NluDomainVersion} [draftVersion] - The draft version of that NLU domain.
 * @property {NluDomainVersion} [lastPublishedVersion] - The last published version of that NLU domain.
 * @property {string} [dateCreated] - The date when the NLU domain was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateModified] - The date when the NLU domain was updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [engineVersion] - The version of the NLU engine to use.
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} NluDomainVersion
 * @property {string} [id] - The globally unique identifier for the object.
 * @property {NluDomain} [domain] - The NLU domain of the version.
 * @property {string} [description] - The description of the NLU domain version.
 * @property {string} language - The language that the NLU domain version supports.
 * @property {boolean} [published] - Whether this NLU domain version has been published.
 * @property {string} [dateCreated] - The date when the NLU domain version was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateModified] - The date when the NLU domain version was updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [dateTrained] - The date when the NLU domain version was trained. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [datePublished] - The date when the NLU domain version was published. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
 * @property {string} [trainingStatus] - The training status of the NLU domain version.
 * @property {string} [evaluationStatus] - The evaluation status of the NLU domain version.
 * @property {IntentDefinition[]} [intents] - The intents defined for this NLU domain version.
 * @property {NamedEntityTypeDefinition[]} [entityTypes] - The entity types defined for this NLU domain version.
 * @property {NamedEntityDefinition[]} [entities] - The entities defined for this NLU domain version.This field is mutually exclusive with entityTypeBindings
 * @property {string} [selfUri] - The URI for this object
 */
 
/**
 * @typedef {object} NluFeedbackRequest
 * @property {string} text - The feedback text.
 * @property {IntentFeedback[]} intents - Detected intent of the utterance
 * @property {string} versionId - The domain version ID of the feedback.
 * @property {string} [language] - The language of the version to which feedback is linked, e.g. en-us, de-de
 */
 
/**
 * @typedef {object} NluUtterance
 * @property {string} [id] - ID of the utterance.
 * @property {string} [source] - The source of the utterance.
 * @property {NluUtteranceSegment[]} segments - The list of segments that that constitute this utterance for the given intent.
 */
 
/**
 * @typedef {object} NluUtteranceSegment
 * @property {string} text - The text of the segment.
 * @property {NamedEntityAnnotation} [entity] - The entity annotation of the segment.
 */
 

/**
 * LanguageUnderstanding - Language Understanding
 * @class LanguageUnderstanding
 */
class LanguageUnderstandingAPI {
	// Private instance properties
	#gcPlatformAPIClient = null;

	/**
	 * Constructor for the LanguageUnderstanding class
	 * @constructor
	 * @param {GCPlatformAPIClient} gcPlatformAPIClient - The Genesys Cloud Platform API client instance.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_INSTANCE_TYPE_INVALID} If the Genesys Cloud Platform API client instance argument is not an object.
	 */
	constructor(gcPlatformAPIClient) {
		// Check the Genesys Cloud Platform API client instance argument
		if (typeof gcPlatformAPIClient !== "object" || symbols.GCPlatformAPIClient in gcPlatformAPIClient === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_INSTANCE_TYPE_INVALID();
		}

		// Initialize the instance properties
		this.#gcPlatformAPIClient = gcPlatformAPIClient;
	}

	/**
	 * Find an NLU Domain.
	 * @async
	 * @param {string} domainId - ID of the NLU domain.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/domains/{domainId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getLanguageunderstandingDomain(domainId) {
		const endpointPath = "/api/v2/languageunderstanding/domains/{domainId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete an NLU Domain.
	 * @async
	 * @param {string} domainId - ID of the NLU domain.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/domains/{domainId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteLanguageunderstandingDomain(domainId) {
		const endpointPath = "/api/v2/languageunderstanding/domains/{domainId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update an NLU Domain.
	 * @async
	 * @param {string} domainId - ID of the NLU domain.
	 * @param {NluDomain} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/domains/{domainId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchLanguageunderstandingDomain(domainId, body) {
		const endpointPath = "/api/v2/languageunderstanding/domains/{domainId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get all NLU Domains.
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {number} [query.pageSize] -  Page size
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/domains" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getLanguageunderstandingDomains(query) {
		const endpointPath = "/api/v2/languageunderstanding/domains";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create an NLU Domain.
	 * @async
	 * @param {NluDomain} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/domains" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postLanguageunderstandingDomains(body) {
		const endpointPath = "/api/v2/languageunderstanding/domains";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Find a Feedback
	 * @async
	 * @param {string} domainId - ID of the NLU domain.
	 * @param {string} feedbackId - ID of the Feedback
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string[]} [query.fields] -  Fields and properties to get, comma-separated
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/domains/{domainId}/feedback/{feedbackId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getLanguageunderstandingDomainFeedbackFeedbackId(domainId, feedbackId, query) {
		const endpointPath = "/api/v2/languageunderstanding/domains/{domainId}/feedback/{feedbackId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		if (this.#checkJSONSchemaType(feedbackId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "feedbackId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("fields" in query && this.#checkJSONSchemaType(query["fields"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "fields", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;
		apiCallOptions.pathParameters.feedbackId = feedbackId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete the feedback on the NLU Domain Version.
	 * @async
	 * @param {string} domainId - ID of the NLU domain.
	 * @param {string} feedbackId - ID of the Feedback
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/domains/{domainId}/feedback/{feedbackId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteLanguageunderstandingDomainFeedbackFeedbackId(domainId, feedbackId) {
		const endpointPath = "/api/v2/languageunderstanding/domains/{domainId}/feedback/{feedbackId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		if (this.#checkJSONSchemaType(feedbackId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "feedbackId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;
		apiCallOptions.pathParameters.feedbackId = feedbackId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get all feedback in the given NLU Domain Version.
	 * @async
	 * @param {string} domainId - ID of the NLU domain.
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.intentName] -  The top intent name to retrieve feedback for.
	 * @param {string} [query.assessment] -  The top assessment to retrieve feedback for.
	 * @param {string} [query.dateStart] -  Begin of time window as ISO-8601 date.
	 * @param {string} [query.dateEnd] -  End of time window as ISO-8601 date.
	 * @param {boolean} [query.includeDeleted] -  Whether to include soft-deleted items in the result.
	 * @param {string} [query.language] -  Whether to filter response based on the language, e.g. en-us, pt-br.
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {number} [query.pageSize] -  Page size
	 * @param {boolean} [query.enableCursorPagination] -  Enable Cursor Pagination
	 * @param {boolean} [query.includeTrainingUtterances] -  Include Training Utterances. By default they're included.
	 * @param {string} [query.after] -  The cursor that points to the end of the set of entities that has been returned. This is considered only when enableCursorPagination=true
	 * @param {string[]} [query.fields] -  Fields and properties to get, comma-separated
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/domains/{domainId}/feedback" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getLanguageunderstandingDomainFeedback(domainId, query) {
		const endpointPath = "/api/v2/languageunderstanding/domains/{domainId}/feedback";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("intentName" in query && this.#checkJSONSchemaType(query["intentName"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "intentName", "string");
			}
			if ("assessment" in query && this.#checkJSONSchemaType(query["assessment"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "assessment", "string");
			}
			if ("dateStart" in query && this.#checkJSONSchemaType(query["dateStart"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "dateStart", "string");
			}
			if ("dateEnd" in query && this.#checkJSONSchemaType(query["dateEnd"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "dateEnd", "string");
			}
			if ("includeDeleted" in query && this.#checkJSONSchemaType(query["includeDeleted"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "includeDeleted", "boolean");
			}
			if ("language" in query && this.#checkJSONSchemaType(query["language"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "language", "string");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
			if ("enableCursorPagination" in query && this.#checkJSONSchemaType(query["enableCursorPagination"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "enableCursorPagination", "boolean");
			}
			if ("includeTrainingUtterances" in query && this.#checkJSONSchemaType(query["includeTrainingUtterances"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "includeTrainingUtterances", "boolean");
			}
			if ("after" in query && this.#checkJSONSchemaType(query["after"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "after", "string");
			}
			if ("fields" in query && this.#checkJSONSchemaType(query["fields"], "array") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "fields", "array");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create feedback for the NLU Domain Version.
	 * @async
	 * @param {string} domainId - ID of the NLU domain.
	 * @param {NluFeedbackRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/domains/{domainId}/feedback" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postLanguageunderstandingDomainFeedback(domainId, body) {
		const endpointPath = "/api/v2/languageunderstanding/domains/{domainId}/feedback";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get information about a draft.
	 * @async
	 * @param {string} minerId - Miner ID
	 * @param {string} draftId - Draft ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.draftIntentId] -  Parameter to filter a specific intent.
	 * @param {string} [query.draftTopicId] -  Parameter to filter a specific topic.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/miners/{minerId}/drafts/{draftId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getLanguageunderstandingMinerDraft(minerId, draftId, query) {
		const endpointPath = "/api/v2/languageunderstanding/miners/{minerId}/drafts/{draftId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(minerId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "minerId", "string");
		}

		if (this.#checkJSONSchemaType(draftId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "draftId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("draftIntentId" in query && this.#checkJSONSchemaType(query["draftIntentId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "draftIntentId", "string");
			}
			if ("draftTopicId" in query && this.#checkJSONSchemaType(query["draftTopicId"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "draftTopicId", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.minerId = minerId;
		apiCallOptions.pathParameters.draftId = draftId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a draft
	 * @async
	 * @param {string} minerId - Miner ID
	 * @param {string} draftId - Draft ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/miners/{minerId}/drafts/{draftId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteLanguageunderstandingMinerDraft(minerId, draftId) {
		const endpointPath = "/api/v2/languageunderstanding/miners/{minerId}/drafts/{draftId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(minerId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "minerId", "string");
		}

		if (this.#checkJSONSchemaType(draftId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "draftId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.minerId = minerId;
		apiCallOptions.pathParameters.draftId = draftId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Save information for the draft. Either topic draft or intent draft should be sent.
	 * @async
	 * @param {string} minerId - Miner ID
	 * @param {string} draftId - Draft ID
	 * @param {DraftRequest} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/miners/{minerId}/drafts/{draftId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	patchLanguageunderstandingMinerDraft(minerId, draftId, body) {
		const endpointPath = "/api/v2/languageunderstanding/miners/{minerId}/drafts/{draftId}";
		const endpointMethod = "PATCH";

		// Check the path parameters
		if (this.#checkJSONSchemaType(minerId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "minerId", "string");
		}

		if (this.#checkJSONSchemaType(draftId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "draftId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.minerId = minerId;
		apiCallOptions.pathParameters.draftId = draftId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Retrieve the list of drafts created.
	 * @async
	 * @param {string} minerId - Miner ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/miners/{minerId}/drafts" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getLanguageunderstandingMinerDrafts(minerId) {
		const endpointPath = "/api/v2/languageunderstanding/miners/{minerId}/drafts";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(minerId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "minerId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.minerId = minerId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a new draft resource.
	 * @async
	 * @param {string} minerId - Miner ID
	 * @param {Draft} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/miners/{minerId}/drafts" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postLanguageunderstandingMinerDrafts(minerId, body) {
		const endpointPath = "/api/v2/languageunderstanding/miners/{minerId}/drafts";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(minerId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "minerId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.minerId = minerId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get information about a mined intent
	 * @async
	 * @param {string} minerId - Miner ID
	 * @param {string} intentId - The ID of the intent to be retrieved.
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.expand] -  Option to fetch utterances
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/miners/{minerId}/intents/{intentId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getLanguageunderstandingMinerIntent(minerId, intentId, query) {
		const endpointPath = "/api/v2/languageunderstanding/miners/{minerId}/intents/{intentId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(minerId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "minerId", "string");
		}

		if (this.#checkJSONSchemaType(intentId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "intentId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.minerId = minerId;
		apiCallOptions.pathParameters.intentId = intentId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Retrieve a list of mined intents.
	 * @async
	 * @param {string} minerId - Miner ID
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.expand] -  Option to fetch utterances.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/miners/{minerId}/intents" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getLanguageunderstandingMinerIntents(minerId, query) {
		const endpointPath = "/api/v2/languageunderstanding/miners/{minerId}/intents";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(minerId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "minerId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.minerId = minerId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get information about a miner.
	 * @async
	 * @param {string} minerId - Miner ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/miners/{minerId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getLanguageunderstandingMiner(minerId) {
		const endpointPath = "/api/v2/languageunderstanding/miners/{minerId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(minerId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "minerId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.minerId = minerId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete a miner.
	 * @async
	 * @param {string} minerId - Miner ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/miners/{minerId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteLanguageunderstandingMiner(minerId) {
		const endpointPath = "/api/v2/languageunderstanding/miners/{minerId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(minerId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "minerId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.minerId = minerId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Start the mining process. Specify date range pair with mediaType, queueIds, participantType for mining data from Genesys Cloud. Specify only uploadKey for mining through an external file.
	 * @async
	 * @param {string} minerId - Miner ID
	 * @param {MinerExecuteRequest} [body] - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/miners/{minerId}/execute" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postLanguageunderstandingMinerExecute(minerId, body) {
		const endpointPath = "/api/v2/languageunderstanding/miners/{minerId}/execute";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(minerId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "minerId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false && body !== null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", false);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.minerId = minerId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Retrieve the list of miners created.
	 * @async
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.minerType] -  Type of miner, either intent or topic
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/miners" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getLanguageunderstandingMiners(query) {
		const endpointPath = "/api/v2/languageunderstanding/miners";
		const endpointMethod = "GET";

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("minerType" in query && this.#checkJSONSchemaType(query["minerType"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "minerType", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create a unique miner.
	 * @async
	 * @param {Miner} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/miners" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postLanguageunderstandingMiners(body) {
		const endpointPath = "/api/v2/languageunderstanding/miners";
		const endpointMethod = "POST";

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Retrieves details of a particular topic.
	 * @async
	 * @param {string} minerId - Miner ID
	 * @param {string} topicId - The ID of the topic to be retrieved.
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {string} [query.expand] -  Option to fetch phrases
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/miners/{minerId}/topics/{topicId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getLanguageunderstandingMinerTopic(minerId, topicId, query) {
		const endpointPath = "/api/v2/languageunderstanding/miners/{minerId}/topics/{topicId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(minerId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "minerId", "string");
		}

		if (this.#checkJSONSchemaType(topicId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "topicId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("expand" in query && this.#checkJSONSchemaType(query["expand"], "string") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "expand", "string");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.minerId = minerId;
		apiCallOptions.pathParameters.topicId = topicId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Retrieve a list of mined topics.
	 * @async
	 * @param {string} minerId - Miner ID
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/miners/{minerId}/topics" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getLanguageunderstandingMinerTopics(minerId) {
		const endpointPath = "/api/v2/languageunderstanding/miners/{minerId}/topics";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(minerId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "minerId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.minerId = minerId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Retrieves utterances related to a phrase in a topic.
	 * @async
	 * @param {string} minerId - Miner ID
	 * @param {string} topicId - The ID of the topic to be retrieved.
	 * @param {string} phraseId - The ID of the phrase to be retrieved.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/miners/{minerId}/topics/{topicId}/phrases/{phraseId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getLanguageunderstandingMinerTopicPhrase(minerId, topicId, phraseId) {
		const endpointPath = "/api/v2/languageunderstanding/miners/{minerId}/topics/{topicId}/phrases/{phraseId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(minerId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "minerId", "string");
		}

		if (this.#checkJSONSchemaType(topicId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "topicId", "string");
		}

		if (this.#checkJSONSchemaType(phraseId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "phraseId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.minerId = minerId;
		apiCallOptions.pathParameters.topicId = topicId;
		apiCallOptions.pathParameters.phraseId = phraseId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get Organization Configuration
	 * @async
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/settings" endpoint.
	 */
	getLanguageunderstandingSettings() {
		const endpointPath = "/api/v2/languageunderstanding/settings";
		const endpointMethod = "GET";

		const apiCallOptions = {};

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Retrieved quality report for the specified NLU Domain Version
	 * @async
	 * @param {string} domainId - ID of the NLU domain.
	 * @param {string} domainVersionId - ID of the NLU domain version.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/domains/{domainId}/versions/{domainVersionId}/report" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	getLanguageunderstandingDomainVersionReport(domainId, domainVersionId) {
		const endpointPath = "/api/v2/languageunderstanding/domains/{domainId}/versions/{domainVersionId}/report";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		if (this.#checkJSONSchemaType(domainVersionId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainVersionId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;
		apiCallOptions.pathParameters.domainVersionId = domainVersionId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Find an NLU Domain Version.
	 * @async
	 * @param {string} domainId - ID of the NLU domain.
	 * @param {string} domainVersionId - ID of the NLU domain version.
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.includeUtterances] -  Whether utterances for intent definition should be included when marshalling response.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/domains/{domainId}/versions/{domainVersionId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getLanguageunderstandingDomainVersion(domainId, domainVersionId, query) {
		const endpointPath = "/api/v2/languageunderstanding/domains/{domainId}/versions/{domainVersionId}";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		if (this.#checkJSONSchemaType(domainVersionId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainVersionId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("includeUtterances" in query && this.#checkJSONSchemaType(query["includeUtterances"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "includeUtterances", "boolean");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;
		apiCallOptions.pathParameters.domainVersionId = domainVersionId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Update an NLU Domain Version.
	 * @async
	 * @param {string} domainId - ID of the NLU domain.
	 * @param {string} domainVersionId - ID of the NLU domain version.
	 * @param {NluDomainVersion} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/domains/{domainId}/versions/{domainVersionId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	putLanguageunderstandingDomainVersion(domainId, domainVersionId, body) {
		const endpointPath = "/api/v2/languageunderstanding/domains/{domainId}/versions/{domainVersionId}";
		const endpointMethod = "PUT";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		if (this.#checkJSONSchemaType(domainVersionId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainVersionId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;
		apiCallOptions.pathParameters.domainVersionId = domainVersionId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Delete an NLU Domain Version
	 * @async
	 * @param {string} domainId - ID of the NLU domain.
	 * @param {string} domainVersionId - ID of the NLU domain version.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/domains/{domainId}/versions/{domainVersionId}" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	deleteLanguageunderstandingDomainVersion(domainId, domainVersionId) {
		const endpointPath = "/api/v2/languageunderstanding/domains/{domainId}/versions/{domainVersionId}";
		const endpointMethod = "DELETE";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		if (this.#checkJSONSchemaType(domainVersionId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainVersionId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;
		apiCallOptions.pathParameters.domainVersionId = domainVersionId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Publish the draft NLU Domain Version.
	 * @async
	 * @param {string} domainId - ID of the NLU domain.
	 * @param {string} domainVersionId - ID of the NLU domain version.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/domains/{domainId}/versions/{domainVersionId}/publish" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	postLanguageunderstandingDomainVersionPublish(domainId, domainVersionId) {
		const endpointPath = "/api/v2/languageunderstanding/domains/{domainId}/versions/{domainVersionId}/publish";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		if (this.#checkJSONSchemaType(domainVersionId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainVersionId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;
		apiCallOptions.pathParameters.domainVersionId = domainVersionId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Train the draft NLU Domain Version.
	 * @async
	 * @param {string} domainId - ID of the NLU domain.
	 * @param {string} domainVersionId - ID of the NLU domain version.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/domains/{domainId}/versions/{domainVersionId}/train" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 */
	postLanguageunderstandingDomainVersionTrain(domainId, domainVersionId) {
		const endpointPath = "/api/v2/languageunderstanding/domains/{domainId}/versions/{domainVersionId}/train";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		if (this.#checkJSONSchemaType(domainVersionId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainVersionId", "string");
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;
		apiCallOptions.pathParameters.domainVersionId = domainVersionId;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Detect intent, entities, etc. in the submitted text using the specified NLU domain version.
	 * @async
	 * @param {string} domainId - ID of the NLU domain.
	 * @param {string} domainVersionId - ID of the NLU domain version.
	 * @param {NluDetectionRequest} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/domains/{domainId}/versions/{domainVersionId}/detect" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postLanguageunderstandingDomainVersionDetect(domainId, domainVersionId, body) {
		const endpointPath = "/api/v2/languageunderstanding/domains/{domainId}/versions/{domainVersionId}/detect";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		if (this.#checkJSONSchemaType(domainVersionId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainVersionId", "string");
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;
		apiCallOptions.pathParameters.domainVersionId = domainVersionId;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Get all NLU Domain Versions for a given Domain.
	 * @async
	 * @param {string} domainId - ID of the NLU domain.
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.includeUtterances] -  Whether utterances for intent definition should be included when marshalling response.
	 * @param {number} [query.pageNumber] -  Page number
	 * @param {number} [query.pageSize] -  Page size
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/domains/{domainId}/versions" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 */
	getLanguageunderstandingDomainVersions(domainId, query) {
		const endpointPath = "/api/v2/languageunderstanding/domains/{domainId}/versions";
		const endpointMethod = "GET";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("includeUtterances" in query && this.#checkJSONSchemaType(query["includeUtterances"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "includeUtterances", "boolean");
			}
			if ("pageNumber" in query && this.#checkJSONSchemaType(query["pageNumber"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageNumber", "integer");
			}
			if ("pageSize" in query && this.#checkJSONSchemaType(query["pageSize"], "integer") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "pageSize", "integer");
			}
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;
		apiCallOptions.queryParameters = query;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * Create an NLU Domain Version.
	 * @async
	 * @param {string} domainId - ID of the NLU domain.
	 * @param {object} query - The query string parameters for the request. An empty object or null is allowed if all query string parameters are optional.
	 * @param {boolean} [query.includeUtterances] -  Whether utterances for intent definition should be included when marshalling response.
	 * @param {NluDomainVersion} body - The body of the request. An empty object or null is allowed if the body is optional.
	 * @returns {Promise<HTTPResponse>} A promise that settles to the HTTP response of the call to the "/api/v2/languageunderstanding/domains/{domainId}/versions" endpoint.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID} If a path parameter argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID} If the query string parameters argument is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID} If a query string parameter is not of the proper type.
	 * @throws {ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID} If the request body argument is not of the proper type.
	 */
	postLanguageunderstandingDomainVersions(domainId, query, body) {
		const endpointPath = "/api/v2/languageunderstanding/domains/{domainId}/versions";
		const endpointMethod = "POST";

		// Check the path parameters
		if (this.#checkJSONSchemaType(domainId, "string") === false) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_PATH_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "domainId", "string");
		}

		// Check the query string parameters
		if (typeof query !== "object") {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETERS_TYPE_INVALID(endpointPath, endpointMethod, false);
		}

		if (query !== null) {
			if ("includeUtterances" in query && this.#checkJSONSchemaType(query["includeUtterances"], "boolean") === false) {
				throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_QUERY_PARAMETER_TYPE_INVALID(endpointPath, endpointMethod, "includeUtterances", "boolean");
			}
		}

		// Check the body argument
		if (this.#checkJSONSchemaType(body, "object") === false || body === null) {
			throw new errors.ERROR_GC_PLATFORM_API_CLIENT_API_CALL_REQUEST_BODY_TYPE_INVALID(endpointPath, endpointMethod, "object", true);
		}

		const apiCallOptions = {};
		apiCallOptions.pathParameters = {};
		apiCallOptions.pathParameters.domainId = domainId;
		apiCallOptions.queryParameters = query;
		apiCallOptions.body = body;

		return this.#gcPlatformAPIClient.queueAPICall(endpointPath, endpointMethod, apiCallOptions);
	}

	/**
	 * @description Checks that a value is of the proper JSON schema type
	 * @param {*} value - The value to check
	 * @param {string} jsonSchemaType - The JSON schema type to check against
	 * @returns {boolean} Returns true if the value is of the proper JSON schema type, false otherwise
	 */
	#checkJSONSchemaType(value, jsonSchemaType) {
		const PASSTHROUGH_JSON_SCHEMA_TYPES = ["boolean", "number", "string", "object"];

		// Check if the type is a passthrough type
		if (PASSTHROUGH_JSON_SCHEMA_TYPES.includes(jsonSchemaType)) {
			return typeof value === jsonSchemaType;
		}

		// Check if the type is an integer
		if (jsonSchemaType === "integer") {
			return Number.isInteger(value);
		}

		// Check if the type is an array
		if (jsonSchemaType === "array") {
			return Array.isArray(value);
		}

		// Check if the type is null
		if (jsonSchemaType === "null") {
			return value === null;
		}

		// Otherwise, return false
		return false;
	}
}

export { LanguageUnderstandingAPI };